// Code generated from docs/UniversalParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package grammar // UniversalParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type UniversalParser struct {
	*antlr.BaseParser
}

var UniversalParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func universalparserParserInit() {
	staticData := &UniversalParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "'+'", "'-'", "'*'", "'/'",
		"'%'", "'~'", "':'", "','", "';'", "'!'", "'^'", "'|'", "'||'", "'&'",
		"'.'", "'='", "'=='", "'<>'", "'!='", "'>'", "'>='", "'!<'", "'<'",
		"'<='", "'!>'", "'<=>'", "'->'", "'/*+'", "'*/'", "'('", "'['", "')'",
		"']'",
	}
	staticData.SymbolicNames = []string{
		"", "T_ADD", "T_AFTER", "T_ALL", "T_ALTER", "T_ALWAYS", "T_ANALYZE",
		"T_AND", "T_ANTI", "T_ANY", "T_ANY_VALUE", "T_ARCHIVE", "T_ARRAY", "T_AS",
		"T_ASC", "T_AT", "T_AUTHORIZATION", "T_BETWEEN", "T_BOTH", "T_BUCKET",
		"T_BUCKETS", "T_BY", "T_CACHE", "T_CASCADE", "T_CASE", "T_CAST", "T_CATALOG",
		"T_CATALOGS", "T_CHANGE", "T_CHECK", "T_CLEAR", "T_CLUSTER", "T_CLUSTERED",
		"T_CODEGEN", "T_COLLATE", "T_COLLECTION", "T_COLUMN", "T_COLUMNS", "T_COMMENT",
		"T_COMMIT", "T_COMPACT", "T_COMPACTIONS", "T_COMPUTE", "T_CONCATENATE",
		"T_CONSTRAINT", "T_COST", "T_CREATE", "T_CROSS", "T_CUBE", "T_CURRENT",
		"T_CURRENT_DATE", "T_CURRENT_TIME", "T_CURRENT_TIMESTAMP", "T_CURRENT_USER",
		"T_DAY", "T_DAYS", "T_DAYOFYEAR", "T_DATA", "T_DATABASE", "T_DATABASES",
		"T_DATEADD", "T_DATEDIFF", "T_DBPROPERTIES", "T_DEFAULT", "T_DEFINED",
		"T_DELETE", "T_DELIMITED", "T_DESC", "T_DESCRIBE", "T_DFS", "T_DIRECTORIES",
		"T_DIRECTORY", "T_DISTINCT", "T_DISTRIBUTE", "T_DIV", "T_DROP", "T_ELSE",
		"T_END", "T_ESCAPE", "T_ESCAPED", "T_EXCEPT", "T_EXCHANGE", "T_EXCLUDE",
		"T_EXISTS", "T_EXPLAIN", "T_EXPORT", "T_EXTENDED", "T_EXTERNAL", "T_EXTRACT",
		"T_FALSE", "T_FETCH", "T_FIELDS", "T_FILTER", "T_FILEFORMAT", "T_FIRST",
		"T_FOLLOWING", "T_FOR", "T_FOREIGN", "T_FORMAT", "T_FORMATTED", "T_FROM",
		"T_FULL", "T_FUNCTION", "T_FUNCTIONS", "T_GENERATED", "T_GLOBAL", "T_GRANT",
		"T_GROUP", "T_GROUPING", "T_HAVING", "T_HOUR", "T_HOURS", "T_IF", "T_IGNORE",
		"T_IMPORT", "T_IN", "T_INCLUDE", "T_INDEX", "T_INDEXES", "T_INNER",
		"T_INPATH", "T_INPUTFORMAT", "T_INSERT", "T_INTERSECT", "T_INTERVAL",
		"T_INTO", "T_IS", "T_ITEMS", "T_JOIN", "T_KEYS", "T_LAST", "T_LATERAL",
		"T_LAZY", "T_LEADING", "T_LEFT", "T_LIKE", "T_ILIKE", "T_LIMIT", "T_LINES",
		"T_LIST", "T_LOAD", "T_LOCAL", "T_LOCATION", "T_LOCK", "T_LOCKS", "T_LOGICAL",
		"T_MACRO", "T_MAP", "T_MATCHED", "T_MERGE", "T_MICROSECOND", "T_MICROSECONDS",
		"T_MILLISECOND", "T_MILLISECONDS", "T_MINUTE", "T_MINUTES", "T_MINUS",
		"T_MONTH", "T_MONTHS", "T_MSCK", "T_NAMESPACE", "T_NAMESPACES", "T_NANOSECOND",
		"T_NANOSECONDS", "T_NATURAL", "T_NO", "T_NOT", "T_NULL", "T_NULLS",
		"T_OF", "T_OFFSET", "T_ON", "T_ONLY", "T_OPTION", "T_OPTIONS", "T_OR",
		"T_ORDER", "T_OUT", "T_OUTER", "T_OUTPUTFORMAT", "T_OVER", "T_OVERLAPS",
		"T_OVERLAY", "T_OVERWRITE", "T_PARTITION", "T_PARTITIONED", "T_PARTITIONS",
		"T_PERCENTILE_CONT", "T_PERCENTILE_DISC", "T_PERCENTLIT", "T_PIVOT",
		"T_PLACING", "T_POSITION", "T_PRECEDING", "T_PRIMARY", "T_PRINCIPALS",
		"T_PROPERTIES", "T_PURGE", "T_QUARTER", "T_QUERY", "T_RANGE", "T_RECORDREADER",
		"T_RECORDWRITER", "T_RECOVER", "T_REDUCE", "T_REFERENCES", "T_REFRESH",
		"T_RENAME", "T_REPAIR", "T_REPEATABLE", "T_REPLACE", "T_RESET", "T_RESPECT",
		"T_RESTRICT", "T_REVOKE", "T_RIGHT", "T_RLIKE", "T_ROLE", "T_ROLES",
		"T_ROLLBACK", "T_ROLLUP", "T_ROW", "T_ROWS", "T_SECOND", "T_SECONDS",
		"T_SCHEMA", "T_SCHEMAS", "T_SELECT", "T_SEMI", "T_SEPARATED", "T_SERDE",
		"T_SERDEPROPERTIES", "T_SESSION_USER", "T_SET", "T_SETMINUS", "T_SETS",
		"T_SHOW", "T_SKEWED", "T_SOME", "T_SORT", "T_SORTED", "T_SOURCE", "T_START",
		"T_STATISTICS", "T_STORED", "T_STRATIFY", "T_STRUCT", "T_SUBSTR", "T_SUBSTRING",
		"T_SYNC", "T_SYSTEM_TIME", "T_SYSTEM_VERSION", "T_TABLE", "T_TABLES",
		"T_TABLESAMPLE", "T_TARGET", "T_TBLPROPERTIES", "T_TEMPORARY", "T_TERMINATED",
		"T_THEN", "T_TIME", "T_TIMESTAMP", "T_TIMESTAMPADD", "T_TIMESTAMPDIFF",
		"T_TO", "T_TOUCH", "T_TRAILING", "T_TRANSACTION", "T_TRANSACTIONS",
		"T_TRANSFORM", "T_TRIM", "T_TRUE", "T_TRUNCATE", "T_TRY_CAST", "T_TYPE",
		"T_UNARCHIVE", "T_UNBOUNDED", "T_UNCACHE", "T_UNION", "T_UNIQUE", "T_UNKNOWN",
		"T_UNLOCK", "T_UNPIVOT", "T_UNSET", "T_UPDATE", "T_USE", "T_USER", "T_USING",
		"T_VALUES", "T_VERSION", "T_VIEW", "T_VIEWS", "T_WEEK", "T_WEEKS", "T_WHEN",
		"T_WHERE", "T_WINDOW", "T_WITH", "T_WITHIN", "T_YEAR", "T_YEARS", "T_ZONE",
		"T_ACTION", "T_ADD2", "T_ALLOCATE", "T_ANSI_NULLS", "T_ANSI_PADDING",
		"T_ASSOCIATE", "T_AUTO_INCREMENT", "T_AVG", "T_BATCHSIZE", "T_BEGIN",
		"T_BIGINT", "T_BINARY_DOUBLE", "T_BINARY_FLOAT", "T_BINARY_INTEGER",
		"T_BIT", "T_BODY", "T_BREAK", "T_BULK", "T_BYTE", "T_CALL", "T_CALLER",
		"T_CASESPECIFIC", "T_CHAR", "T_CHARACTER", "T_CHARSET", "T_CLIENT",
		"T_CLOSE", "T_CMP", "T_COLLECT", "T_CONSTANT", "T_COMPRESS", "T_CONCAT",
		"T_CONDITION", "T_CONTINUE", "T_COPY", "T_COUNT", "T_COUNT_BIG", "T_CREATION",
		"T_CREATOR", "T_CS", "T_CURRENT_SCHEMA", "T_CURSOR", "T_DATE", "T_DATETIME",
		"T_DEC", "T_DECIMAL", "T_DECLARE", "T_DEFERRED", "T_DEFINER", "T_DEFINITION",
		"T_DELIMITER", "T_DIAGNOSTICS", "T_DIR", "T_DO", "T_DOUBLE", "T_DYNAMIC",
		"T_ELSEIF", "T_ELSIF", "T_ENABLE", "T_ENGINE", "T_EXEC", "T_EXECUTE",
		"T_EXCEPTION", "T_EXCLUSIVE", "T_EXIT", "T_FALLBACK", "T_FILE", "T_FILES",
		"T_FLOAT", "T_FOUND", "T_GET", "T_GO", "T_HANDLER", "T_HASH", "T_HDFS",
		"T_HIVE", "T_HOST", "T_IDENTITY", "T_IMMEDIATE", "T_INITRANS", "T_INOUT",
		"T_INT", "T_INT2", "T_INT4", "T_INT8", "T_INTEGER", "T_INVOKER", "T_ISOPEN",
		"T_KEEP", "T_KEY", "T_LANGUAGE", "T_LEAVE", "T_LOCATOR", "T_LOCATORS",
		"T_LOG", "T_LOGGED", "T_LOGGING", "T_LOOP", "T_MAX", "T_MAXTRANS", "T_MESSAGE_TEXT",
		"T_MIN", "T_MULTISET", "T_NCHAR", "T_NEW", "T_NVARCHAR", "T_NOCOUNT",
		"T_NOCOMPRESS", "T_NOLOGGING", "T_NONE", "T_NOTFOUND", "T_NUMERIC",
		"T_NUMBER", "T_OBJECT", "T_OFF", "T_OPEN", "T_OWNER", "T_PACKAGE", "T_PCTFREE",
		"T_PCTUSED", "T_PLS_INTEGER", "T_PRECISION", "T_PRESERVE", "T_PRINT",
		"T_PROC", "T_PROCEDURE", "T_QUALIFY", "T_QUERY_BAND", "T_QUIT", "T_QUOTED_IDENTIFIER",
		"T_RAISE", "T_REAL", "T_REGEXP", "T_RESIGNAL", "T_RESULT", "T_RESULT_SET_LOCATOR",
		"T_RETURN", "T_RETURNS", "T_REVERSE", "T_ROWTYPE", "T_ROW_COUNT", "T_RR",
		"T_RS", "T_PWD", "T_SECURITY", "T_SEGMENT", "T_SEL", "T_SESSION", "T_SESSIONS",
		"T_SHARE", "T_SIGNAL", "T_SIMPLE_DOUBLE", "T_SIMPLE_FLOAT", "T_SIMPLE_INTEGER",
		"T_SMALLDATETIME", "T_SMALLINT", "T_SQL", "T_SQLEXCEPTION", "T_SQLINSERT",
		"T_SQLSTATE", "T_SQLWARNING", "T_STATS", "T_STEP", "T_STORAGE", "T_STRING",
		"T_SUBDIR", "T_SUM", "T_SUMMARY", "T_SYS_REFCURSOR", "T_TABLESPACE",
		"T_TEXTIMAGE_ON", "T_TINYINT", "T_TITLE", "T_TOP", "T_UR", "T_VALUE",
		"T_VAR", "T_VARCHAR", "T_VARCHAR2", "T_VARYING", "T_VOLATILE", "T_WHILE",
		"T_WITHOUT", "T_WORK", "T_XACT_ABORT", "T_XML", "T_YES", "T_ACTIVITY_COUNT",
		"T_CUME_DIST", "T_DENSE_RANK", "T_FIRST_VALUE", "T_LAG", "T_LAST_VALUE",
		"T_LEAD", "T_MAX_PART_STRING", "T_MIN_PART_STRING", "T_MAX_PART_INT",
		"T_MIN_PART_INT", "T_MAX_PART_DATE", "T_MIN_PART_DATE", "T_PART_COUNT",
		"T_PART_LOC", "T_RANK", "T_ROW_NUMBER", "T_STDEV", "T_SYSDATE", "T_VARIANCE",
		"T_ABS", "T_ACOS", "T_ADD_MONTHS", "T_ALL_MATCH", "T_ANY_MATCH", "T_ATAN2",
		"T_APPROX_DISTINCT", "T_ARG_MAX", "T_ARG_MIN", "T_ARRAY_CONTAINS", "T_ARRAY_DISTINCT",
		"T_ARRAY_EXCEPT", "T_ARRAY_INTERSECT", "T_ARRAY_JOIN", "T_ARRAY_MAX",
		"T_ARRAY_MIN", "T_ARRAY_NORMALIZE", "T_ARRAY_POSITION", "T_ARRAY_REDUCE",
		"T_ARRAY_REMOVE", "T_ARRAY_REPEAT", "T_ARRAY_SORT", "T_ARRAY_UNION",
		"T_ARRAYS_OVERLAP", "T_ARRAYS_ZIP", "T_ASCII", "T_ASIN", "T_ATAN", "T_BASE64",
		"T_BIN", "T_BITWISE_AND_AGG", "T_BITWISE_OR_AGG", "T_CBRT", "T_CEIL",
		"T_CHAR_MATCHCOUNT", "T_CHR", "T_CLUSTER_SAMPLE", "T_COALESCE", "T_COLLECT_LIST",
		"T_COLLECT_SET", "T_COMBINATIONS", "T_CONCAT_WS", "T_CONV", "T_CORR",
		"T_COS", "T_COSH", "T_COT", "T_COUNT_IF", "T_COVAR_POP", "T_COVAR_SAMP",
		"T_CRC32", "T_CURRENT_TIMEZONE", "T_DATE_ADD", "T_DATE_FORMAT", "T_DATE_SUB",
		"T_DATEPART", "T_DATETRUNC", "T_DAYOFMONTH", "T_DAYOFWEEK", "T_DECODE",
		"T_DECOMPRESS", "T_DEGREES", "T_E", "T_ENCODE", "T_EXP", "T_EXPLODE",
		"T_FACTORIAL", "T_FIELD", "T_FIND_IN_SET", "T_FLATTEN", "T_FLOOR", "T_FORMAT_NUMBER",
		"T_FROM_JSON", "T_FROM_UNIXTIME", "T_FROM_UTC_TIMESTAMP", "T_GET_IDCARD_AGE",
		"T_GET_IDCARD_BIRTHDAY", "T_GET_IDCARD_SEX", "T_GET_JSON_OBJECT", "T_GET_USER_ID",
		"T_GETDATE", "T_GREATEST", "T_HEX", "T_HISTOGRAM", "T_INLINE", "T_INITCAP",
		"T_INSTR", "T_IS_ENCODING", "T_ISDATE", "T_ISNAN", "T_JSON_OBJECT",
		"T_JSON_ARRAY", "T_JSON_EXTRACT", "T_JSON_EXISTS", "T_JSON_PRETTY",
		"T_JSON_TYPE", "T_JSON_FORMAT", "T_JSON_PARSE", "T_JSON_VALID", "T_JSON_TUPLE",
		"T_KEYVALUE", "T_KEYVALUE_TUPLE", "T_LAST_DAY", "T_LASTDAY", "T_LEAST",
		"T_LENGTH", "T_LENGTHB", "T_LN", "T_LOCATE", "T_LOG10", "T_LOG2", "T_LPAD",
		"T_LTRIM", "T_MAP_AGG", "T_MAP_CONCAT", "T_MAP_ENTRIES", "T_MAP_FILTER",
		"T_MAP_FROM_ARRAYS", "T_MAP_FROM_ENTRIES", "T_MAP_KEYS", "T_MAP_UNION",
		"T_MAP_UNION_SUM", "T_MAP_VALUES", "T_MAP_ZIP_WITH", "T_MASK_HASH",
		"T_MAX_BY", "T_MAX_PT", "T_MD5", "T_MEDIAN", "T_MIN_BY", "T_MONTHS_BETWEEN",
		"T_MULTIMAP_AGG", "T_MULTIMAP_FROM_ENTRIES", "T_NAMED_STRUCT", "T_NEGATIVE",
		"T_NEXT_DAY", "T_NGRAMS", "T_NOW", "T_NTILE", "T_NTH_VALUE", "T_NULLIF",
		"T_NUMERIC_HISTOGRAM", "T_NVL", "T_ORDINAL", "T_PARSE_URL", "T_PARSE_URL_TUPLE",
		"T_PARTITION_EXISTS", "T_PERCENT_RANK", "T_PERCENTILE", "T_PERCENTILE_APPROX",
		"T_PI", "T_POSEXPLODE", "T_POSITIVE", "T_POW", "T_RADIANS", "T_RAND",
		"T_REGEXP_COUNT", "T_REGEXP_EXTRACT", "T_REGEXP_EXTRACT_ALL", "T_REGEXP_INSTR",
		"T_REGEXP_REPLACE", "T_REGEXP_SUBSTR", "T_REPEAT", "T_ROUND", "T_RPAD",
		"T_RTRIM", "T_SAMPLE", "T_SEQUENCE", "T_SHA", "T_SHA1", "T_SHA2", "T_SHIFTLEFT",
		"T_SHIFTRIGHT", "T_SHIFTRIGHTUNSIGNED", "T_SHUFFLE", "T_SIGN", "T_SIN",
		"T_SINH", "T_SIZE", "T_SLICE", "T_SORT_ARRAY", "T_SOUNDEX", "T_SPACE",
		"T_SPLIT", "T_SPLIT_PART", "T_SQRT", "T_STACK", "T_STDDEV", "T_STDDEV_SAMP",
		"T_STR_TO_MAP", "T_SUBSTRING_INDEX", "T_SYM_DECRYPT", "T_SYM_ENCRYPT",
		"T_TABLE_EXISTS", "T_TAN", "T_TANH", "T_TO_CHAR", "T_TO_DATE", "T_TO_JSON",
		"T_TO_MILLIS", "T_TOLOWER", "T_TOUPPER", "T_TRANS_ARRAY", "T_TRANS_COLS",
		"T_TRANSFORM_KEYS", "T_TRANSFORM_VALUES", "T_TRANSLATE", "T_TRUNC",
		"T_UNBASE64", "T_UNHEX", "T_UNIQUE_ID", "T_UNIX_TIMESTAMP", "T_URL_DECODE",
		"T_URL_ENCODE", "T_UUID", "T_VAR_SAMP", "T_VAR_POP", "T_WEEKDAY", "T_WEEKOFYEAR",
		"T_WIDTH_BUCKET", "T_WM_CONCAT", "T_ZIP_WITH", "T_SEQUENCEFILE", "T_TEXTFILE",
		"T_RCFILE", "T_ORC", "T_PARQUET", "T_AVRO", "T_JSONFILE", "T_TRANSACTIONAL",
		"T_LIFECYCLE", "T_MATERIALIZED", "T_CHANGEOWNER", "T_BUILD", "T_DISABLE",
		"T_REWRITE", "T_REBUILD", "SINGLE_QUOTED_STRING", "DOUBLE_QUOTED_STRING",
		"BIGINT_VALUE", "SMALLINT_VALUE", "INTEGER_VALUE", "TINYINT_VALUE",
		"EXPONENT_VALUE", "DECIMAL_VALUE", "FLOAT_VALUE", "DOUBLE_VALUE", "BIGDECIMAL_VALUE",
		"IDENTIFIER", "BACKQUOTED_IDENTIFIER", "K_ADD", "K_MINUS", "K_MULTIPLY",
		"K_DIVIDE", "K_PERCENT", "K_TILDE", "K_COLON", "K_COMMA", "K_SEMICOLON",
		"K_EXCLAMATION", "K_HAT", "K_PIPE", "K_CONCAT_PIPE", "K_AMPERSAND",
		"K_DOT", "K_EQ", "K_EQ2", "K_NEQ", "K_NEQJ", "K_GT", "K_GTE", "K_GTEJ",
		"K_LT", "K_LTE", "K_LTEJ", "K_NSEQ", "K_ARROW", "K_HINT_START", "K_HINT_END",
		"K_OPEN_PAREN", "K_OPEN_BRACKET", "K_CLOSE_PAREN", "K_CLOSE_BRACKET",
		"MULTI_LINE_COMMENT", "LINE_COMMENT", "WHITE_SPACE", "UNMATCH",
	}
	staticData.RuleNames = []string{
		"statements", "statement", "setStatement", "viewTableAndView", "createMaterializedViewStatement",
		"updateMaterializedViewStatement", "setMaterializedViewLifecycleStatement",
		"updateMaterializedViewLifecycleStatement", "dropMaterializedViewStatement",
		"dropMaterializedViewPartitionStatement", "createViewStatement", "viewColumns",
		"renameViewStatement", "changeViewStatement", "dropViewStatement", "createTableStatement",
		"dropTableStatement", "createTableBodyspec", "createTableItems", "createTableItem",
		"tablePartitionSpec", "partitionItems", "partitionItem", "sortSpec",
		"skewedBySpec", "skewedByColumns", "skewedByValues", "multiSkewedValue",
		"simpleValue", "storageDirectories", "formatSpec", "tableRowFormat",
		"storedBy", "serdeProperties", "storedSpec", "formatType", "propertiesSpec",
		"tableSelectSpec", "lifecycleSpec", "insertQueryStatement", "insertValueStatement",
		"dropTablePartitions", "addTablePartitions", "renameTablePartitions",
		"insertInto", "insertValues", "insertTableColumns", "partitionSpec",
		"partitionVal", "ifOption", "replaceOption", "nullOption", "defaultOption",
		"query", "cte", "namedQuery", "columnAliases", "queryOrganization",
		"queryTerm", "queryPrimary", "querySpecification", "selectClause", "fromClause",
		"inlineTable", "functionTable", "temporalClause", "sample", "sampleMethod",
		"relationPrimary", "relation", "relationExtension", "joinRelation",
		"joinCondtion", "joinType", "pivotClause", "pivotAggregateItem", "pivotColumn",
		"pivotValue", "unpivotClause", "unpivotOption", "unpivotSingleValueColumn",
		"unpivotMultiValueColumn", "unpivotNameColumn", "unpivotColumnItem",
		"unpivotMultiColumnItem", "unpivotColumnAlias", "unpivotColumnAliasOption",
		"unpivotColumnAliasValueList", "unpivotColumnAliasValue", "unpivotColumn",
		"lateralView", "whereClause", "havingClause", "aggregationClause", "groupOption",
		"groupByClause", "groupingElement", "groupingAnalytics", "groupingSet",
		"hint", "hintStatement", "namedExpressionSeq", "namedExpression", "allQueryColumns",
		"expressionSeqs", "expressionSeq", "expression", "booleanExpression",
		"predicate", "valueExpression", "defaultExpression", "caseExpress",
		"searchedCase", "simpleCase", "whenClause", "elseClause", "function",
		"specFunction", "castFunction", "structFunction", "firstFunction", "anyValueFunction",
		"lastFunction", "subQueryExpress", "trimFunction", "extractFunction",
		"substringFunction", "overlayFunction", "percentileFunction", "transArrayFunction",
		"standardFunction", "overSpec", "filterSpec", "constant", "compareOperator",
		"dataType", "complexColTypeList", "complexColType", "setQuantifier",
		"interval", "multiUnitsInterval", "unitToUnitInterval", "multiUnits",
		"unitToUnit", "commentSpec", "windowClause", "namedWindow", "windowSpec",
		"windowFrame", "frameBound", "tableProvider", "createFileFormat", "fileFormat",
		"storageHandler", "rowFormat", "propertyList", "property", "propertyKey",
		"propertyValue", "arguments", "orderBy", "sortBy", "distributeBy", "partitionBy",
		"clusterBy", "bucketsOption", "limitItem", "offsetItem", "sortItems",
		"sortItem", "sortType", "aliasSpec", "locationSpec", "multiIdentifierSeq",
		"multiIdentifier", "identifierSeq", "identifier", "quotedIdentifier",
		"number", "string", "boolean", "null", "version", "noReservedKeywords",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 795, 2209, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 1, 0, 1, 0, 1, 0,
		5, 0, 372, 8, 0, 10, 0, 12, 0, 375, 9, 0, 1, 0, 3, 0, 378, 8, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 400, 8, 1, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 3, 2, 407, 8, 2, 1, 3, 1, 3, 3, 3, 411, 8, 3, 1, 3, 1,
		3, 3, 3, 415, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 421, 8, 4, 1, 4, 1, 4,
		3, 4, 425, 8, 4, 1, 4, 1, 4, 3, 4, 429, 8, 4, 1, 4, 3, 4, 432, 8, 4, 1,
		4, 1, 4, 3, 4, 436, 8, 4, 1, 4, 3, 4, 439, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 447, 8, 4, 1, 4, 3, 4, 450, 8, 4, 1, 4, 3, 4, 453, 8,
		4, 1, 4, 3, 4, 456, 8, 4, 1, 4, 3, 4, 459, 8, 4, 1, 4, 1, 4, 1, 4, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 490, 8, 8, 1, 8, 1, 8, 3, 8, 494, 8, 8, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 3, 9, 502, 8, 9, 1, 9, 1, 9, 1, 9, 5, 9, 507, 8, 9, 10,
		9, 12, 9, 510, 9, 9, 1, 10, 1, 10, 3, 10, 514, 8, 10, 1, 10, 1, 10, 3,
		10, 518, 8, 10, 1, 10, 1, 10, 3, 10, 522, 8, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 11, 1, 11, 1, 11, 3, 11, 531, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11,
		536, 8, 11, 5, 11, 538, 8, 11, 10, 11, 12, 11, 541, 9, 11, 1, 11, 1, 11,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 3, 14, 562, 8, 14, 1, 14,
		1, 14, 1, 15, 1, 15, 3, 15, 568, 8, 15, 1, 15, 3, 15, 571, 8, 15, 1, 15,
		3, 15, 574, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 580, 8, 15, 1, 15,
		3, 15, 583, 8, 15, 1, 15, 3, 15, 586, 8, 15, 1, 15, 3, 15, 589, 8, 15,
		1, 15, 3, 15, 592, 8, 15, 1, 15, 3, 15, 595, 8, 15, 1, 15, 3, 15, 598,
		8, 15, 1, 15, 3, 15, 601, 8, 15, 1, 15, 3, 15, 604, 8, 15, 1, 15, 3, 15,
		607, 8, 15, 1, 16, 1, 16, 1, 16, 3, 16, 612, 8, 16, 1, 16, 1, 16, 3, 16,
		616, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 5, 18, 625,
		8, 18, 10, 18, 12, 18, 628, 9, 18, 1, 19, 1, 19, 1, 19, 3, 19, 633, 8,
		19, 1, 19, 3, 19, 636, 8, 19, 1, 19, 3, 19, 639, 8, 19, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 5, 21, 650, 8, 21, 10, 21,
		12, 21, 653, 9, 21, 1, 22, 1, 22, 1, 22, 3, 22, 658, 8, 22, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 670, 8,
		24, 1, 25, 1, 25, 1, 26, 1, 26, 3, 26, 676, 8, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 5, 27, 682, 8, 27, 10, 27, 12, 27, 685, 9, 27, 1, 27, 1, 27, 1,
		28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 3, 30, 697, 8, 30,
		1, 31, 1, 31, 3, 31, 701, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 728,
		8, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1,
		39, 3, 39, 740, 8, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 756, 8, 41, 10,
		41, 12, 41, 759, 9, 41, 1, 41, 3, 41, 762, 8, 41, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 772, 8, 42, 10, 42, 12, 42, 775,
		9, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1,
		44, 1, 44, 3, 44, 788, 8, 44, 1, 44, 1, 44, 3, 44, 792, 8, 44, 1, 44, 3,
		44, 795, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 800, 8, 44, 1, 44, 1, 44, 3,
		44, 804, 8, 44, 1, 44, 3, 44, 807, 8, 44, 3, 44, 809, 8, 44, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 5, 45, 816, 8, 45, 10, 45, 12, 45, 819, 9, 45,
		1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 5, 47, 832, 8, 47, 10, 47, 12, 47, 835, 9, 47, 1, 47, 1, 47, 1, 48,
		1, 48, 1, 48, 1, 48, 3, 48, 843, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3,
		48, 849, 8, 48, 1, 49, 1, 49, 3, 49, 853, 8, 49, 1, 49, 1, 49, 1, 50, 1,
		50, 1, 50, 1, 51, 3, 51, 861, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52,
		1, 53, 3, 53, 869, 8, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1,
		54, 5, 54, 878, 8, 54, 10, 54, 12, 54, 881, 9, 54, 1, 55, 1, 55, 3, 55,
		885, 8, 55, 1, 55, 3, 55, 888, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 57, 3, 57, 899, 8, 57, 1, 57, 3, 57, 902, 8, 57,
		1, 57, 3, 57, 905, 8, 57, 1, 57, 3, 57, 908, 8, 57, 1, 57, 3, 57, 911,
		8, 57, 1, 57, 3, 57, 914, 8, 57, 1, 57, 3, 57, 917, 8, 57, 1, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 925, 8, 58, 1, 58, 5, 58, 928, 8, 58,
		10, 58, 12, 58, 931, 9, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 938,
		8, 59, 1, 60, 1, 60, 3, 60, 942, 8, 60, 1, 60, 3, 60, 945, 8, 60, 1, 60,
		3, 60, 948, 8, 60, 1, 60, 3, 60, 951, 8, 60, 1, 60, 3, 60, 954, 8, 60,
		1, 61, 1, 61, 5, 61, 958, 8, 61, 10, 61, 12, 61, 961, 9, 61, 1, 61, 3,
		61, 964, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 972, 8,
		62, 10, 62, 12, 62, 975, 9, 62, 1, 62, 5, 62, 978, 8, 62, 10, 62, 12, 62,
		981, 9, 62, 1, 62, 3, 62, 984, 8, 62, 1, 62, 3, 62, 987, 8, 62, 1, 63,
		1, 63, 1, 63, 3, 63, 992, 8, 63, 1, 64, 1, 64, 3, 64, 996, 8, 64, 1, 65,
		3, 65, 999, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1006, 8, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1012, 8, 65, 1, 66, 1, 66, 1, 66, 3,
		66, 1017, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1024, 8, 66,
		1, 67, 3, 67, 1027, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67,
		1045, 8, 67, 3, 67, 1047, 8, 67, 1, 67, 3, 67, 1050, 8, 67, 1, 68, 1, 68,
		3, 68, 1054, 8, 68, 1, 68, 3, 68, 1057, 8, 68, 1, 68, 3, 68, 1060, 8, 68,
		1, 68, 3, 68, 1063, 8, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1069, 8,
		68, 1, 68, 3, 68, 1072, 8, 68, 3, 68, 1074, 8, 68, 1, 69, 3, 69, 1077,
		8, 69, 1, 69, 1, 69, 5, 69, 1081, 8, 69, 10, 69, 12, 69, 1084, 9, 69, 1,
		70, 1, 70, 1, 70, 3, 70, 1089, 8, 70, 1, 71, 3, 71, 1092, 8, 71, 1, 71,
		1, 71, 1, 71, 3, 71, 1097, 8, 71, 1, 71, 1, 71, 3, 71, 1101, 8, 71, 1,
		72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1110, 8, 72, 1, 73,
		3, 73, 1113, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1118, 8, 73, 1, 73, 3,
		73, 1121, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1126, 8, 73, 1, 73, 1, 73,
		3, 73, 1130, 8, 73, 1, 73, 3, 73, 1133, 8, 73, 1, 73, 3, 73, 1136, 8, 73,
		1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 1143, 8, 74, 10, 74, 12, 74,
		1146, 9, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 1155,
		8, 74, 10, 74, 12, 74, 1158, 9, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75,
		3, 75, 1165, 8, 75, 1, 76, 1, 76, 3, 76, 1169, 8, 76, 1, 77, 1, 77, 3,
		77, 1173, 8, 77, 1, 77, 3, 77, 1176, 8, 77, 1, 78, 1, 78, 3, 78, 1180,
		8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1185, 8, 78, 1, 78, 1, 78, 3, 78, 1189,
		8, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 5, 80, 1202, 8, 80, 10, 80, 12, 80, 1205, 9, 80, 1, 80, 1, 80,
		1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5,
		81, 1219, 8, 81, 10, 81, 12, 81, 1222, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82,
		1, 82, 1, 82, 1, 82, 3, 82, 1231, 8, 82, 1, 83, 1, 83, 3, 83, 1235, 8,
		83, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1241, 8, 84, 1, 85, 3, 85, 1244,
		8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 1250, 8, 86, 1, 87, 1, 87, 1,
		87, 1, 87, 5, 87, 1256, 8, 87, 10, 87, 12, 87, 1259, 9, 87, 1, 87, 1, 87,
		1, 88, 1, 88, 3, 88, 1265, 8, 88, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 3,
		90, 1272, 8, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91,
		1, 91, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 5, 93, 1291,
		8, 93, 10, 93, 12, 93, 1294, 9, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		1300, 8, 93, 3, 93, 1302, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 5, 94, 1312, 8, 94, 10, 94, 12, 94, 1315, 9, 94, 1, 94,
		1, 94, 3, 94, 1319, 8, 94, 1, 95, 1, 95, 3, 95, 1323, 8, 95, 1, 96, 1,
		96, 3, 96, 1327, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 1334,
		8, 97, 10, 97, 12, 97, 1337, 9, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97,
		1, 97, 1, 97, 1, 97, 5, 97, 1347, 8, 97, 10, 97, 12, 97, 1350, 9, 97, 1,
		97, 1, 97, 3, 97, 1354, 8, 97, 1, 98, 1, 98, 3, 98, 1358, 8, 98, 1, 99,
		1, 99, 1, 99, 3, 99, 1363, 8, 99, 1, 99, 5, 99, 1366, 8, 99, 10, 99, 12,
		99, 1369, 9, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 5, 100, 1379, 8, 100, 10, 100, 12, 100, 1382, 9, 100, 1, 100, 1,
		100, 3, 100, 1386, 8, 100, 1, 101, 1, 101, 1, 101, 5, 101, 1391, 8, 101,
		10, 101, 12, 101, 1394, 9, 101, 1, 102, 1, 102, 1, 102, 3, 102, 1399, 8,
		102, 3, 102, 1401, 8, 102, 1, 103, 1, 103, 1, 103, 3, 103, 1406, 8, 103,
		1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105,
		5, 105, 1417, 8, 105, 10, 105, 12, 105, 1420, 9, 105, 1, 106, 1, 106, 1,
		107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 1, 107, 3, 107, 1437, 8, 107, 1, 107, 1, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 5, 107, 1445, 8, 107, 10, 107, 12, 107, 1448, 9,
		107, 1, 108, 3, 108, 1451, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 3, 108, 1459, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1464, 8,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 1469, 8, 108, 1, 108, 1, 108, 1, 108,
		3, 108, 1474, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1479, 8, 108, 1,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 1485, 8, 108, 1, 108, 1, 108, 3, 108,
		1489, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1495, 8, 108, 1,
		108, 1, 108, 3, 108, 1499, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1504,
		8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1509, 8, 108, 1, 108, 1, 108, 1,
		108, 3, 108, 1514, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 1, 109, 3, 109, 1524, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 5, 109, 1545, 8, 109, 10,
		109, 12, 109, 1548, 9, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 1560, 8, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 1, 110, 5, 110, 1567, 8, 110, 10, 110, 12, 110, 1570, 9,
		110, 1, 111, 1, 111, 3, 111, 1574, 8, 111, 1, 112, 1, 112, 4, 112, 1578,
		8, 112, 11, 112, 12, 112, 1579, 1, 112, 3, 112, 1583, 8, 112, 1, 112, 1,
		112, 1, 113, 1, 113, 1, 113, 4, 113, 1590, 8, 113, 11, 113, 12, 113, 1591,
		1, 113, 3, 113, 1595, 8, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1,
		114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 3, 116, 1609, 8, 116,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 1, 117, 3, 117, 1622, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 5, 119, 1636,
		8, 119, 10, 119, 12, 119, 1639, 9, 119, 3, 119, 1641, 8, 119, 1, 119, 1,
		119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1650, 8, 120, 1, 120,
		1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1659, 8, 121, 1,
		121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1668, 8, 122,
		1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124,
		3, 124, 1679, 8, 124, 1, 124, 3, 124, 1682, 8, 124, 1, 124, 1, 124, 1,
		124, 1, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1702, 8, 126,
		1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 3, 127, 1715, 8, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1729,
		8, 128, 1, 128, 3, 128, 1732, 8, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1,
		129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 3, 130, 1746,
		8, 130, 1, 130, 1, 130, 3, 130, 1750, 8, 130, 1, 130, 1, 130, 3, 130, 1754,
		8, 130, 1, 130, 3, 130, 1757, 8, 130, 1, 131, 1, 131, 1, 131, 1, 132, 1,
		132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1,
		133, 1, 133, 1, 133, 1, 133, 3, 133, 1776, 8, 133, 1, 134, 1, 134, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1795, 8, 135, 1, 135, 1,
		135, 3, 135, 1799, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1805,
		8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1811, 8, 135, 1, 135, 1,
		135, 1, 135, 1, 135, 1, 135, 5, 135, 1818, 8, 135, 10, 135, 12, 135, 1821,
		9, 135, 1, 135, 3, 135, 1824, 8, 135, 3, 135, 1826, 8, 135, 1, 136, 1,
		136, 1, 136, 5, 136, 1831, 8, 136, 10, 136, 12, 136, 1834, 9, 136, 1, 137,
		1, 137, 3, 137, 1838, 8, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1843, 8,
		137, 1, 137, 3, 137, 1846, 8, 137, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139,
		3, 139, 1853, 8, 139, 1, 140, 1, 140, 1, 140, 4, 140, 1858, 8, 140, 11,
		140, 12, 140, 1859, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 142, 1,
		142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1,
		145, 5, 145, 1878, 8, 145, 10, 145, 12, 145, 1881, 9, 145, 1, 146, 1, 146,
		1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147,
		1, 147, 1, 147, 3, 147, 1896, 8, 147, 1, 147, 1, 147, 3, 147, 1900, 8,
		147, 3, 147, 1902, 8, 147, 1, 147, 3, 147, 1905, 8, 147, 1, 147, 3, 147,
		1908, 8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1,
		148, 3, 148, 1918, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149,
		1, 149, 3, 149, 1927, 8, 149, 1, 150, 1, 150, 1, 150, 1, 151, 1, 151, 1,
		151, 1, 151, 1, 151, 1, 151, 3, 151, 1938, 8, 151, 1, 152, 1, 152, 1, 152,
		1, 152, 1, 152, 1, 152, 3, 152, 1946, 8, 152, 1, 153, 1, 153, 1, 153, 1,
		153, 3, 153, 1952, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 3, 154, 1961, 8, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1973, 8, 154, 3, 154, 1975,
		8, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1982, 8, 154, 1,
		154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1989, 8, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 3, 154, 1995, 8, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3,
		154, 2001, 8, 154, 3, 154, 2003, 8, 154, 1, 155, 1, 155, 1, 155, 1, 155,
		5, 155, 2009, 8, 155, 10, 155, 12, 155, 2012, 9, 155, 1, 155, 1, 155, 1,
		156, 1, 156, 3, 156, 2018, 8, 156, 1, 156, 3, 156, 2021, 8, 156, 1, 157,
		1, 157, 1, 157, 5, 157, 2026, 8, 157, 10, 157, 12, 157, 2029, 9, 157, 1,
		157, 3, 157, 2032, 8, 157, 1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 2038,
		8, 158, 1, 159, 3, 159, 2041, 8, 159, 1, 159, 1, 159, 1, 159, 5, 159, 2046,
		8, 159, 10, 159, 12, 159, 2049, 9, 159, 1, 159, 3, 159, 2052, 8, 159, 1,
		159, 3, 159, 2055, 8, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 161, 1, 161,
		1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163,
		1, 163, 1, 164, 3, 164, 2074, 8, 164, 1, 164, 1, 164, 1, 164, 1, 164, 3,
		164, 2080, 8, 164, 1, 165, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 3, 166,
		2088, 8, 166, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 1,
		168, 5, 168, 2098, 8, 168, 10, 168, 12, 168, 2101, 9, 168, 1, 169, 1, 169,
		3, 169, 2105, 8, 169, 1, 169, 1, 169, 3, 169, 2109, 8, 169, 1, 170, 1,
		170, 1, 171, 3, 171, 2114, 8, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172,
		1, 173, 1, 173, 1, 173, 5, 173, 2124, 8, 173, 10, 173, 12, 173, 2127, 9,
		173, 1, 174, 1, 174, 1, 174, 5, 174, 2132, 8, 174, 10, 174, 12, 174, 2135,
		9, 174, 1, 175, 1, 175, 1, 175, 5, 175, 2140, 8, 175, 10, 175, 12, 175,
		2143, 9, 175, 1, 176, 1, 176, 1, 176, 3, 176, 2148, 8, 176, 1, 177, 1,
		177, 1, 177, 3, 177, 2153, 8, 177, 1, 178, 3, 178, 2156, 8, 178, 1, 178,
		1, 178, 3, 178, 2160, 8, 178, 1, 178, 1, 178, 3, 178, 2164, 8, 178, 1,
		178, 1, 178, 3, 178, 2168, 8, 178, 1, 178, 1, 178, 3, 178, 2172, 8, 178,
		1, 178, 1, 178, 3, 178, 2176, 8, 178, 1, 178, 1, 178, 3, 178, 2180, 8,
		178, 1, 178, 1, 178, 3, 178, 2184, 8, 178, 1, 178, 1, 178, 3, 178, 2188,
		8, 178, 1, 178, 1, 178, 3, 178, 2192, 8, 178, 1, 178, 3, 178, 2195, 8,
		178, 1, 179, 1, 179, 1, 180, 1, 180, 1, 181, 1, 181, 1, 182, 1, 182, 3,
		182, 2205, 8, 182, 1, 183, 1, 183, 1, 183, 0, 4, 116, 214, 218, 220, 184,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
		108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
		138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
		168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
		198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226,
		228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256,
		258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286,
		288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316,
		318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346,
		348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 0, 41, 2, 0, 21, 21,
		171, 171, 2, 0, 360, 360, 743, 743, 2, 0, 252, 252, 290, 290, 5, 0, 80,
		80, 123, 123, 156, 156, 234, 234, 278, 278, 2, 0, 251, 251, 289, 289, 2,
		0, 250, 250, 261, 261, 2, 0, 750, 750, 753, 753, 2, 0, 82, 82, 116, 116,
		2, 0, 48, 48, 220, 220, 2, 0, 166, 166, 768, 768, 1, 0, 135, 136, 3, 0,
		3, 3, 9, 9, 238, 238, 3, 0, 89, 89, 271, 271, 280, 280, 2, 0, 759, 760,
		764, 764, 2, 0, 74, 74, 761, 763, 2, 0, 759, 760, 771, 771, 2, 0, 25, 25,
		273, 273, 3, 0, 270, 270, 621, 621, 674, 674, 3, 0, 18, 18, 133, 133, 266,
		266, 1, 0, 247, 248, 2, 0, 100, 100, 766, 766, 2, 0, 96, 96, 766, 766,
		1, 0, 187, 188, 2, 0, 113, 113, 212, 212, 1, 0, 774, 785, 2, 0, 157, 157,
		299, 299, 4, 0, 54, 54, 110, 110, 154, 154, 223, 223, 3, 0, 110, 110, 154,
		154, 223, 223, 2, 0, 3, 3, 72, 72, 8, 0, 54, 55, 110, 111, 150, 155, 157,
		158, 162, 163, 223, 224, 292, 293, 299, 300, 6, 0, 54, 54, 110, 110, 154,
		154, 157, 157, 223, 223, 299, 299, 2, 0, 200, 200, 222, 222, 2, 0, 95,
		95, 193, 193, 1, 0, 239, 240, 1, 0, 31, 32, 2, 0, 94, 94, 130, 130, 2,
		0, 14, 14, 67, 67, 1, 0, 752, 753, 1, 0, 746, 747, 2, 0, 89, 89, 271, 271,
		22, 0, 1, 6, 9, 12, 14, 20, 22, 46, 48, 99, 101, 108, 110, 118, 120, 121,
		123, 124, 126, 127, 129, 133, 135, 155, 157, 165, 168, 170, 172, 174, 177,
		177, 179, 179, 181, 182, 185, 214, 216, 226, 229, 294, 296, 730, 2386,
		0, 368, 1, 0, 0, 0, 2, 399, 1, 0, 0, 0, 4, 401, 1, 0, 0, 0, 6, 408, 1,
		0, 0, 0, 8, 416, 1, 0, 0, 0, 10, 463, 1, 0, 0, 0, 12, 470, 1, 0, 0, 0,
		14, 477, 1, 0, 0, 0, 16, 485, 1, 0, 0, 0, 18, 495, 1, 0, 0, 0, 20, 511,
		1, 0, 0, 0, 22, 527, 1, 0, 0, 0, 24, 544, 1, 0, 0, 0, 26, 551, 1, 0, 0,
		0, 28, 558, 1, 0, 0, 0, 30, 565, 1, 0, 0, 0, 32, 608, 1, 0, 0, 0, 34, 617,
		1, 0, 0, 0, 36, 621, 1, 0, 0, 0, 38, 629, 1, 0, 0, 0, 40, 640, 1, 0, 0,
		0, 42, 646, 1, 0, 0, 0, 44, 654, 1, 0, 0, 0, 46, 659, 1, 0, 0, 0, 48, 663,
		1, 0, 0, 0, 50, 671, 1, 0, 0, 0, 52, 675, 1, 0, 0, 0, 54, 677, 1, 0, 0,
		0, 56, 688, 1, 0, 0, 0, 58, 690, 1, 0, 0, 0, 60, 696, 1, 0, 0, 0, 62, 698,
		1, 0, 0, 0, 64, 702, 1, 0, 0, 0, 66, 707, 1, 0, 0, 0, 68, 711, 1, 0, 0,
		0, 70, 727, 1, 0, 0, 0, 72, 729, 1, 0, 0, 0, 74, 732, 1, 0, 0, 0, 76, 735,
		1, 0, 0, 0, 78, 739, 1, 0, 0, 0, 80, 744, 1, 0, 0, 0, 82, 747, 1, 0, 0,
		0, 84, 763, 1, 0, 0, 0, 86, 776, 1, 0, 0, 0, 88, 808, 1, 0, 0, 0, 90, 810,
		1, 0, 0, 0, 92, 822, 1, 0, 0, 0, 94, 826, 1, 0, 0, 0, 96, 848, 1, 0, 0,
		0, 98, 850, 1, 0, 0, 0, 100, 856, 1, 0, 0, 0, 102, 860, 1, 0, 0, 0, 104,
		864, 1, 0, 0, 0, 106, 868, 1, 0, 0, 0, 108, 873, 1, 0, 0, 0, 110, 882,
		1, 0, 0, 0, 112, 893, 1, 0, 0, 0, 114, 898, 1, 0, 0, 0, 116, 918, 1, 0,
		0, 0, 118, 937, 1, 0, 0, 0, 120, 939, 1, 0, 0, 0, 122, 955, 1, 0, 0, 0,
		124, 967, 1, 0, 0, 0, 126, 988, 1, 0, 0, 0, 128, 993, 1, 0, 0, 0, 130,
		1011, 1, 0, 0, 0, 132, 1013, 1, 0, 0, 0, 134, 1049, 1, 0, 0, 0, 136, 1073,
		1, 0, 0, 0, 138, 1076, 1, 0, 0, 0, 140, 1088, 1, 0, 0, 0, 142, 1091, 1,
		0, 0, 0, 144, 1109, 1, 0, 0, 0, 146, 1135, 1, 0, 0, 0, 148, 1137, 1, 0,
		0, 0, 150, 1162, 1, 0, 0, 0, 152, 1168, 1, 0, 0, 0, 154, 1175, 1, 0, 0,
		0, 156, 1177, 1, 0, 0, 0, 158, 1190, 1, 0, 0, 0, 160, 1193, 1, 0, 0, 0,
		162, 1208, 1, 0, 0, 0, 164, 1230, 1, 0, 0, 0, 166, 1232, 1, 0, 0, 0, 168,
		1236, 1, 0, 0, 0, 170, 1243, 1, 0, 0, 0, 172, 1249, 1, 0, 0, 0, 174, 1251,
		1, 0, 0, 0, 176, 1264, 1, 0, 0, 0, 178, 1266, 1, 0, 0, 0, 180, 1268, 1,
		0, 0, 0, 182, 1279, 1, 0, 0, 0, 184, 1282, 1, 0, 0, 0, 186, 1301, 1, 0,
		0, 0, 188, 1318, 1, 0, 0, 0, 190, 1322, 1, 0, 0, 0, 192, 1326, 1, 0, 0,
		0, 194, 1353, 1, 0, 0, 0, 196, 1357, 1, 0, 0, 0, 198, 1359, 1, 0, 0, 0,
		200, 1385, 1, 0, 0, 0, 202, 1387, 1, 0, 0, 0, 204, 1400, 1, 0, 0, 0, 206,
		1405, 1, 0, 0, 0, 208, 1409, 1, 0, 0, 0, 210, 1413, 1, 0, 0, 0, 212, 1421,
		1, 0, 0, 0, 214, 1436, 1, 0, 0, 0, 216, 1513, 1, 0, 0, 0, 218, 1523, 1,
		0, 0, 0, 220, 1559, 1, 0, 0, 0, 222, 1573, 1, 0, 0, 0, 224, 1575, 1, 0,
		0, 0, 226, 1586, 1, 0, 0, 0, 228, 1598, 1, 0, 0, 0, 230, 1603, 1, 0, 0,
		0, 232, 1608, 1, 0, 0, 0, 234, 1621, 1, 0, 0, 0, 236, 1623, 1, 0, 0, 0,
		238, 1630, 1, 0, 0, 0, 240, 1644, 1, 0, 0, 0, 242, 1653, 1, 0, 0, 0, 244,
		1662, 1, 0, 0, 0, 246, 1671, 1, 0, 0, 0, 248, 1675, 1, 0, 0, 0, 250, 1687,
		1, 0, 0, 0, 252, 1694, 1, 0, 0, 0, 254, 1705, 1, 0, 0, 0, 256, 1718, 1,
		0, 0, 0, 258, 1733, 1, 0, 0, 0, 260, 1742, 1, 0, 0, 0, 262, 1758, 1, 0,
		0, 0, 264, 1761, 1, 0, 0, 0, 266, 1775, 1, 0, 0, 0, 268, 1777, 1, 0, 0,
		0, 270, 1825, 1, 0, 0, 0, 272, 1827, 1, 0, 0, 0, 274, 1835, 1, 0, 0, 0,
		276, 1847, 1, 0, 0, 0, 278, 1849, 1, 0, 0, 0, 280, 1857, 1, 0, 0, 0, 282,
		1861, 1, 0, 0, 0, 284, 1866, 1, 0, 0, 0, 286, 1868, 1, 0, 0, 0, 288, 1870,
		1, 0, 0, 0, 290, 1873, 1, 0, 0, 0, 292, 1882, 1, 0, 0, 0, 294, 1907, 1,
		0, 0, 0, 296, 1917, 1, 0, 0, 0, 298, 1926, 1, 0, 0, 0, 300, 1928, 1, 0,
		0, 0, 302, 1937, 1, 0, 0, 0, 304, 1945, 1, 0, 0, 0, 306, 1947, 1, 0, 0,
		0, 308, 2002, 1, 0, 0, 0, 310, 2004, 1, 0, 0, 0, 312, 2015, 1, 0, 0, 0,
		314, 2031, 1, 0, 0, 0, 316, 2037, 1, 0, 0, 0, 318, 2054, 1, 0, 0, 0, 320,
		2056, 1, 0, 0, 0, 322, 2060, 1, 0, 0, 0, 324, 2064, 1, 0, 0, 0, 326, 2068,
		1, 0, 0, 0, 328, 2073, 1, 0, 0, 0, 330, 2081, 1, 0, 0, 0, 332, 2085, 1,
		0, 0, 0, 334, 2091, 1, 0, 0, 0, 336, 2094, 1, 0, 0, 0, 338, 2102, 1, 0,
		0, 0, 340, 2110, 1, 0, 0, 0, 342, 2113, 1, 0, 0, 0, 344, 2117, 1, 0, 0,
		0, 346, 2120, 1, 0, 0, 0, 348, 2128, 1, 0, 0, 0, 350, 2136, 1, 0, 0, 0,
		352, 2147, 1, 0, 0, 0, 354, 2152, 1, 0, 0, 0, 356, 2194, 1, 0, 0, 0, 358,
		2196, 1, 0, 0, 0, 360, 2198, 1, 0, 0, 0, 362, 2200, 1, 0, 0, 0, 364, 2204,
		1, 0, 0, 0, 366, 2206, 1, 0, 0, 0, 368, 373, 3, 2, 1, 0, 369, 370, 5, 767,
		0, 0, 370, 372, 3, 2, 1, 0, 371, 369, 1, 0, 0, 0, 372, 375, 1, 0, 0, 0,
		373, 371, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374, 377, 1, 0, 0, 0, 375,
		373, 1, 0, 0, 0, 376, 378, 5, 767, 0, 0, 377, 376, 1, 0, 0, 0, 377, 378,
		1, 0, 0, 0, 378, 1, 1, 0, 0, 0, 379, 400, 3, 6, 3, 0, 380, 400, 3, 4, 2,
		0, 381, 400, 3, 78, 39, 0, 382, 400, 3, 80, 40, 0, 383, 400, 3, 106, 53,
		0, 384, 400, 3, 30, 15, 0, 385, 400, 3, 32, 16, 0, 386, 400, 3, 86, 43,
		0, 387, 400, 3, 84, 42, 0, 388, 400, 3, 82, 41, 0, 389, 400, 3, 8, 4, 0,
		390, 400, 3, 10, 5, 0, 391, 400, 3, 12, 6, 0, 392, 400, 3, 14, 7, 0, 393,
		400, 3, 16, 8, 0, 394, 400, 3, 18, 9, 0, 395, 400, 3, 20, 10, 0, 396, 400,
		3, 24, 12, 0, 397, 400, 3, 26, 13, 0, 398, 400, 3, 28, 14, 0, 399, 379,
		1, 0, 0, 0, 399, 380, 1, 0, 0, 0, 399, 381, 1, 0, 0, 0, 399, 382, 1, 0,
		0, 0, 399, 383, 1, 0, 0, 0, 399, 384, 1, 0, 0, 0, 399, 385, 1, 0, 0, 0,
		399, 386, 1, 0, 0, 0, 399, 387, 1, 0, 0, 0, 399, 388, 1, 0, 0, 0, 399,
		389, 1, 0, 0, 0, 399, 390, 1, 0, 0, 0, 399, 391, 1, 0, 0, 0, 399, 392,
		1, 0, 0, 0, 399, 393, 1, 0, 0, 0, 399, 394, 1, 0, 0, 0, 399, 395, 1, 0,
		0, 0, 399, 396, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0,
		400, 3, 1, 0, 0, 0, 401, 402, 5, 233, 0, 0, 402, 403, 3, 348, 174, 0, 403,
		406, 5, 774, 0, 0, 404, 407, 3, 352, 176, 0, 405, 407, 3, 356, 178, 0,
		406, 404, 1, 0, 0, 0, 406, 405, 1, 0, 0, 0, 407, 5, 1, 0, 0, 0, 408, 410,
		5, 67, 0, 0, 409, 411, 5, 86, 0, 0, 410, 409, 1, 0, 0, 0, 410, 411, 1,
		0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 414, 3, 348, 174, 0, 413, 415, 3, 94,
		47, 0, 414, 413, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415, 7, 1, 0, 0, 0,
		416, 417, 5, 46, 0, 0, 417, 418, 5, 740, 0, 0, 418, 420, 5, 290, 0, 0,
		419, 421, 3, 98, 49, 0, 420, 419, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421,
		422, 1, 0, 0, 0, 422, 424, 3, 348, 174, 0, 423, 425, 3, 76, 38, 0, 424,
		423, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 428, 1, 0, 0, 0, 426, 427,
		5, 742, 0, 0, 427, 429, 5, 349, 0, 0, 428, 426, 1, 0, 0, 0, 428, 429, 1,
		0, 0, 0, 429, 431, 1, 0, 0, 0, 430, 432, 3, 22, 11, 0, 431, 430, 1, 0,
		0, 0, 431, 432, 1, 0, 0, 0, 432, 435, 1, 0, 0, 0, 433, 434, 5, 743, 0,
		0, 434, 436, 5, 744, 0, 0, 435, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0,
		436, 438, 1, 0, 0, 0, 437, 439, 3, 288, 144, 0, 438, 437, 1, 0, 0, 0, 438,
		439, 1, 0, 0, 0, 439, 446, 1, 0, 0, 0, 440, 441, 5, 185, 0, 0, 441, 442,
		7, 0, 0, 0, 442, 443, 5, 788, 0, 0, 443, 444, 3, 350, 175, 0, 444, 445,
		5, 790, 0, 0, 445, 447, 1, 0, 0, 0, 446, 440, 1, 0, 0, 0, 446, 447, 1,
		0, 0, 0, 447, 449, 1, 0, 0, 0, 448, 450, 3, 328, 164, 0, 449, 448, 1, 0,
		0, 0, 449, 450, 1, 0, 0, 0, 450, 452, 1, 0, 0, 0, 451, 453, 3, 322, 161,
		0, 452, 451, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 455, 1, 0, 0, 0, 454,
		456, 3, 330, 165, 0, 455, 454, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 458,
		1, 0, 0, 0, 457, 459, 3, 72, 36, 0, 458, 457, 1, 0, 0, 0, 458, 459, 1,
		0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 461, 5, 13, 0, 0, 461, 462, 3, 106,
		53, 0, 462, 9, 1, 0, 0, 0, 463, 464, 5, 4, 0, 0, 464, 465, 5, 740, 0, 0,
		465, 466, 5, 290, 0, 0, 466, 467, 3, 348, 174, 0, 467, 468, 5, 745, 0,
		0, 468, 469, 3, 94, 47, 0, 469, 11, 1, 0, 0, 0, 470, 471, 5, 4, 0, 0, 471,
		472, 5, 740, 0, 0, 472, 473, 5, 290, 0, 0, 473, 474, 3, 348, 174, 0, 474,
		475, 5, 233, 0, 0, 475, 476, 3, 76, 38, 0, 476, 13, 1, 0, 0, 0, 477, 478,
		5, 4, 0, 0, 478, 479, 5, 740, 0, 0, 479, 480, 5, 290, 0, 0, 480, 481, 3,
		348, 174, 0, 481, 482, 3, 94, 47, 0, 482, 483, 7, 1, 0, 0, 483, 484, 5,
		739, 0, 0, 484, 15, 1, 0, 0, 0, 485, 486, 5, 75, 0, 0, 486, 487, 5, 740,
		0, 0, 487, 489, 5, 290, 0, 0, 488, 490, 3, 98, 49, 0, 489, 488, 1, 0, 0,
		0, 489, 490, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 493, 3, 348, 174, 0,
		492, 494, 5, 197, 0, 0, 493, 492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494,
		17, 1, 0, 0, 0, 495, 496, 5, 4, 0, 0, 496, 497, 5, 740, 0, 0, 497, 498,
		5, 290, 0, 0, 498, 499, 3, 348, 174, 0, 499, 501, 5, 75, 0, 0, 500, 502,
		3, 98, 49, 0, 501, 500, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 503, 1,
		0, 0, 0, 503, 508, 3, 94, 47, 0, 504, 505, 5, 766, 0, 0, 505, 507, 3, 94,
		47, 0, 506, 504, 1, 0, 0, 0, 507, 510, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0,
		508, 509, 1, 0, 0, 0, 509, 19, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 511, 513,
		5, 46, 0, 0, 512, 514, 3, 100, 50, 0, 513, 512, 1, 0, 0, 0, 513, 514, 1,
		0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 517, 5, 290, 0, 0, 516, 518, 3, 98,
		49, 0, 517, 516, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0,
		519, 521, 3, 348, 174, 0, 520, 522, 3, 22, 11, 0, 521, 520, 1, 0, 0, 0,
		521, 522, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 524, 3, 288, 144, 0, 524,
		525, 5, 13, 0, 0, 525, 526, 3, 106, 53, 0, 526, 21, 1, 0, 0, 0, 527, 528,
		5, 788, 0, 0, 528, 530, 3, 352, 176, 0, 529, 531, 3, 288, 144, 0, 530,
		529, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 539, 1, 0, 0, 0, 532, 533,
		5, 766, 0, 0, 533, 535, 3, 352, 176, 0, 534, 536, 3, 288, 144, 0, 535,
		534, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 538, 1, 0, 0, 0, 537, 532,
		1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 539, 540, 1, 0,
		0, 0, 540, 542, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 542, 543, 5, 790, 0,
		0, 543, 23, 1, 0, 0, 0, 544, 545, 5, 4, 0, 0, 545, 546, 5, 290, 0, 0, 546,
		547, 3, 348, 174, 0, 547, 548, 5, 207, 0, 0, 548, 549, 5, 264, 0, 0, 549,
		550, 3, 348, 174, 0, 550, 25, 1, 0, 0, 0, 551, 552, 5, 4, 0, 0, 552, 553,
		5, 290, 0, 0, 553, 554, 3, 348, 174, 0, 554, 555, 5, 741, 0, 0, 555, 556,
		5, 264, 0, 0, 556, 557, 3, 352, 176, 0, 557, 27, 1, 0, 0, 0, 558, 559,
		5, 75, 0, 0, 559, 561, 5, 290, 0, 0, 560, 562, 3, 98, 49, 0, 561, 560,
		1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 564, 3, 348,
		174, 0, 564, 29, 1, 0, 0, 0, 565, 567, 5, 46, 0, 0, 566, 568, 5, 257, 0,
		0, 567, 566, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569,
		571, 5, 738, 0, 0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573,
		1, 0, 0, 0, 572, 574, 5, 87, 0, 0, 573, 572, 1, 0, 0, 0, 573, 574, 1, 0,
		0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 5, 252, 0, 0, 576, 577, 3, 98, 49,
		0, 577, 579, 3, 348, 174, 0, 578, 580, 3, 34, 17, 0, 579, 578, 1, 0, 0,
		0, 579, 580, 1, 0, 0, 0, 580, 582, 1, 0, 0, 0, 581, 583, 3, 288, 144, 0,
		582, 581, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 585, 1, 0, 0, 0, 584,
		586, 3, 40, 20, 0, 585, 584, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 588,
		1, 0, 0, 0, 587, 589, 3, 46, 23, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1,
		0, 0, 0, 589, 591, 1, 0, 0, 0, 590, 592, 3, 48, 24, 0, 591, 590, 1, 0,
		0, 0, 591, 592, 1, 0, 0, 0, 592, 594, 1, 0, 0, 0, 593, 595, 3, 60, 30,
		0, 594, 593, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595, 597, 1, 0, 0, 0, 596,
		598, 3, 344, 172, 0, 597, 596, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 600,
		1, 0, 0, 0, 599, 601, 3, 72, 36, 0, 600, 599, 1, 0, 0, 0, 600, 601, 1,
		0, 0, 0, 601, 603, 1, 0, 0, 0, 602, 604, 3, 74, 37, 0, 603, 602, 1, 0,
		0, 0, 603, 604, 1, 0, 0, 0, 604, 606, 1, 0, 0, 0, 605, 607, 3, 76, 38,
		0, 606, 605, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607, 31, 1, 0, 0, 0, 608,
		609, 5, 75, 0, 0, 609, 611, 5, 252, 0, 0, 610, 612, 3, 98, 49, 0, 611,
		610, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 615,
		3, 348, 174, 0, 614, 616, 5, 197, 0, 0, 615, 614, 1, 0, 0, 0, 615, 616,
		1, 0, 0, 0, 616, 33, 1, 0, 0, 0, 617, 618, 5, 788, 0, 0, 618, 619, 3, 36,
		18, 0, 619, 620, 5, 790, 0, 0, 620, 35, 1, 0, 0, 0, 621, 626, 3, 38, 19,
		0, 622, 623, 5, 766, 0, 0, 623, 625, 3, 38, 19, 0, 624, 622, 1, 0, 0, 0,
		625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627,
		37, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629, 630, 3, 352, 176, 0, 630, 632,
		3, 270, 135, 0, 631, 633, 3, 102, 51, 0, 632, 631, 1, 0, 0, 0, 632, 633,
		1, 0, 0, 0, 633, 635, 1, 0, 0, 0, 634, 636, 3, 104, 52, 0, 635, 634, 1,
		0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 638, 1, 0, 0, 0, 637, 639, 3, 288,
		144, 0, 638, 637, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 39, 1, 0, 0, 0,
		640, 641, 5, 185, 0, 0, 641, 642, 5, 21, 0, 0, 642, 643, 5, 788, 0, 0,
		643, 644, 3, 42, 21, 0, 644, 645, 5, 790, 0, 0, 645, 41, 1, 0, 0, 0, 646,
		651, 3, 44, 22, 0, 647, 648, 5, 766, 0, 0, 648, 650, 3, 44, 22, 0, 649,
		647, 1, 0, 0, 0, 650, 653, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 651, 652,
		1, 0, 0, 0, 652, 43, 1, 0, 0, 0, 653, 651, 1, 0, 0, 0, 654, 655, 3, 352,
		176, 0, 655, 657, 3, 270, 135, 0, 656, 658, 3, 288, 144, 0, 657, 656, 1,
		0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 45, 1, 0, 0, 0, 659, 660, 3, 328, 164,
		0, 660, 661, 3, 322, 161, 0, 661, 662, 3, 330, 165, 0, 662, 47, 1, 0, 0,
		0, 663, 664, 5, 237, 0, 0, 664, 665, 5, 21, 0, 0, 665, 666, 3, 50, 25,
		0, 666, 667, 5, 171, 0, 0, 667, 669, 3, 52, 26, 0, 668, 670, 3, 58, 29,
		0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 49, 1, 0, 0, 0, 671,
		672, 3, 208, 104, 0, 672, 51, 1, 0, 0, 0, 673, 676, 3, 54, 27, 0, 674,
		676, 3, 56, 28, 0, 675, 673, 1, 0, 0, 0, 675, 674, 1, 0, 0, 0, 676, 53,
		1, 0, 0, 0, 677, 678, 5, 788, 0, 0, 678, 683, 3, 56, 28, 0, 679, 680, 5,
		766, 0, 0, 680, 682, 3, 56, 28, 0, 681, 679, 1, 0, 0, 0, 682, 685, 1, 0,
		0, 0, 683, 681, 1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684, 686, 1, 0, 0, 0,
		685, 683, 1, 0, 0, 0, 686, 687, 5, 790, 0, 0, 687, 55, 1, 0, 0, 0, 688,
		689, 3, 208, 104, 0, 689, 57, 1, 0, 0, 0, 690, 691, 5, 244, 0, 0, 691,
		692, 5, 13, 0, 0, 692, 693, 5, 70, 0, 0, 693, 59, 1, 0, 0, 0, 694, 697,
		3, 62, 31, 0, 695, 697, 3, 64, 32, 0, 696, 694, 1, 0, 0, 0, 696, 695, 1,
		0, 0, 0, 697, 61, 1, 0, 0, 0, 698, 700, 3, 308, 154, 0, 699, 701, 3, 68,
		34, 0, 700, 699, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 63, 1, 0, 0, 0,
		702, 703, 5, 244, 0, 0, 703, 704, 5, 21, 0, 0, 704, 705, 3, 212, 106, 0,
		705, 706, 3, 66, 33, 0, 706, 65, 1, 0, 0, 0, 707, 708, 5, 297, 0, 0, 708,
		709, 5, 231, 0, 0, 709, 710, 3, 310, 155, 0, 710, 67, 1, 0, 0, 0, 711,
		712, 5, 244, 0, 0, 712, 713, 5, 13, 0, 0, 713, 714, 3, 70, 35, 0, 714,
		69, 1, 0, 0, 0, 715, 728, 5, 731, 0, 0, 716, 728, 5, 732, 0, 0, 717, 728,
		5, 733, 0, 0, 718, 728, 5, 734, 0, 0, 719, 728, 5, 735, 0, 0, 720, 728,
		5, 736, 0, 0, 721, 728, 5, 737, 0, 0, 722, 723, 5, 121, 0, 0, 723, 724,
		3, 212, 106, 0, 724, 725, 5, 179, 0, 0, 725, 726, 3, 212, 106, 0, 726,
		728, 1, 0, 0, 0, 727, 715, 1, 0, 0, 0, 727, 716, 1, 0, 0, 0, 727, 717,
		1, 0, 0, 0, 727, 718, 1, 0, 0, 0, 727, 719, 1, 0, 0, 0, 727, 720, 1, 0,
		0, 0, 727, 721, 1, 0, 0, 0, 727, 722, 1, 0, 0, 0, 728, 71, 1, 0, 0, 0,
		729, 730, 5, 256, 0, 0, 730, 731, 3, 310, 155, 0, 731, 73, 1, 0, 0, 0,
		732, 733, 5, 13, 0, 0, 733, 734, 3, 106, 53, 0, 734, 75, 1, 0, 0, 0, 735,
		736, 5, 739, 0, 0, 736, 737, 3, 356, 178, 0, 737, 77, 1, 0, 0, 0, 738,
		740, 3, 108, 54, 0, 739, 738, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 741,
		1, 0, 0, 0, 741, 742, 3, 88, 44, 0, 742, 743, 3, 106, 53, 0, 743, 79, 1,
		0, 0, 0, 744, 745, 3, 88, 44, 0, 745, 746, 3, 90, 45, 0, 746, 81, 1, 0,
		0, 0, 747, 748, 5, 4, 0, 0, 748, 749, 7, 2, 0, 0, 749, 750, 3, 348, 174,
		0, 750, 751, 5, 75, 0, 0, 751, 752, 3, 98, 49, 0, 752, 757, 3, 94, 47,
		0, 753, 754, 5, 766, 0, 0, 754, 756, 3, 94, 47, 0, 755, 753, 1, 0, 0, 0,
		756, 759, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758,
		761, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 760, 762, 5, 197, 0, 0, 761, 760,
		1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 83, 1, 0, 0, 0, 763, 764, 5, 4,
		0, 0, 764, 765, 7, 2, 0, 0, 765, 766, 3, 348, 174, 0, 766, 767, 5, 1, 0,
		0, 767, 768, 3, 98, 49, 0, 768, 773, 3, 94, 47, 0, 769, 770, 5, 766, 0,
		0, 770, 772, 3, 94, 47, 0, 771, 769, 1, 0, 0, 0, 772, 775, 1, 0, 0, 0,
		773, 771, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 85, 1, 0, 0, 0, 775, 773,
		1, 0, 0, 0, 776, 777, 5, 4, 0, 0, 777, 778, 7, 2, 0, 0, 778, 779, 3, 348,
		174, 0, 779, 780, 3, 94, 47, 0, 780, 781, 5, 207, 0, 0, 781, 782, 5, 264,
		0, 0, 782, 783, 3, 94, 47, 0, 783, 87, 1, 0, 0, 0, 784, 785, 5, 122, 0,
		0, 785, 787, 5, 183, 0, 0, 786, 788, 5, 252, 0, 0, 787, 786, 1, 0, 0, 0,
		787, 788, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 791, 3, 348, 174, 0, 790,
		792, 3, 94, 47, 0, 791, 790, 1, 0, 0, 0, 791, 792, 1, 0, 0, 0, 792, 794,
		1, 0, 0, 0, 793, 795, 3, 92, 46, 0, 794, 793, 1, 0, 0, 0, 794, 795, 1,
		0, 0, 0, 795, 809, 1, 0, 0, 0, 796, 797, 5, 122, 0, 0, 797, 799, 5, 125,
		0, 0, 798, 800, 5, 252, 0, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1, 0, 0,
		0, 800, 801, 1, 0, 0, 0, 801, 803, 3, 348, 174, 0, 802, 804, 3, 94, 47,
		0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 806, 1, 0, 0, 0, 805,
		807, 3, 92, 46, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 809,
		1, 0, 0, 0, 808, 784, 1, 0, 0, 0, 808, 796, 1, 0, 0, 0, 809, 89, 1, 0,
		0, 0, 810, 811, 5, 288, 0, 0, 811, 812, 5, 788, 0, 0, 812, 817, 3, 220,
		110, 0, 813, 814, 5, 766, 0, 0, 814, 816, 3, 220, 110, 0, 815, 813, 1,
		0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0, 0,
		0, 818, 820, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820, 821, 5, 790, 0, 0,
		821, 91, 1, 0, 0, 0, 822, 823, 5, 788, 0, 0, 823, 824, 3, 350, 175, 0,
		824, 825, 5, 790, 0, 0, 825, 93, 1, 0, 0, 0, 826, 827, 5, 184, 0, 0, 827,
		828, 5, 788, 0, 0, 828, 833, 3, 96, 48, 0, 829, 830, 5, 766, 0, 0, 830,
		832, 3, 96, 48, 0, 831, 829, 1, 0, 0, 0, 832, 835, 1, 0, 0, 0, 833, 831,
		1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 836, 1, 0, 0, 0, 835, 833, 1, 0,
		0, 0, 836, 837, 5, 790, 0, 0, 837, 95, 1, 0, 0, 0, 838, 842, 3, 352, 176,
		0, 839, 840, 3, 268, 134, 0, 840, 841, 3, 266, 133, 0, 841, 843, 1, 0,
		0, 0, 842, 839, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 849, 1, 0, 0, 0,
		844, 845, 3, 352, 176, 0, 845, 846, 5, 774, 0, 0, 846, 847, 5, 63, 0, 0,
		847, 849, 1, 0, 0, 0, 848, 838, 1, 0, 0, 0, 848, 844, 1, 0, 0, 0, 849,
		97, 1, 0, 0, 0, 850, 852, 5, 112, 0, 0, 851, 853, 5, 166, 0, 0, 852, 851,
		1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 854, 1, 0, 0, 0, 854, 855, 5, 83,
		0, 0, 855, 99, 1, 0, 0, 0, 856, 857, 5, 175, 0, 0, 857, 858, 5, 210, 0,
		0, 858, 101, 1, 0, 0, 0, 859, 861, 5, 166, 0, 0, 860, 859, 1, 0, 0, 0,
		860, 861, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 863, 5, 167, 0, 0, 863,
		103, 1, 0, 0, 0, 864, 865, 5, 63, 0, 0, 865, 866, 3, 212, 106, 0, 866,
		105, 1, 0, 0, 0, 867, 869, 3, 108, 54, 0, 868, 867, 1, 0, 0, 0, 868, 869,
		1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 3, 116, 58, 0, 871, 872, 3,
		114, 57, 0, 872, 107, 1, 0, 0, 0, 873, 874, 5, 297, 0, 0, 874, 879, 3,
		110, 55, 0, 875, 876, 5, 766, 0, 0, 876, 878, 3, 110, 55, 0, 877, 875,
		1, 0, 0, 0, 878, 881, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0, 879, 880, 1, 0,
		0, 0, 880, 109, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0, 882, 884, 3, 352, 176,
		0, 883, 885, 3, 112, 56, 0, 884, 883, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0,
		885, 887, 1, 0, 0, 0, 886, 888, 5, 13, 0, 0, 887, 886, 1, 0, 0, 0, 887,
		888, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 890, 5, 788, 0, 0, 890, 891,
		3, 106, 53, 0, 891, 892, 5, 790, 0, 0, 892, 111, 1, 0, 0, 0, 893, 894,
		5, 788, 0, 0, 894, 895, 3, 350, 175, 0, 895, 896, 5, 790, 0, 0, 896, 113,
		1, 0, 0, 0, 897, 899, 3, 320, 160, 0, 898, 897, 1, 0, 0, 0, 898, 899, 1,
		0, 0, 0, 899, 901, 1, 0, 0, 0, 900, 902, 3, 328, 164, 0, 901, 900, 1, 0,
		0, 0, 901, 902, 1, 0, 0, 0, 902, 904, 1, 0, 0, 0, 903, 905, 3, 324, 162,
		0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906,
		908, 3, 322, 161, 0, 907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 910,
		1, 0, 0, 0, 909, 911, 3, 290, 145, 0, 910, 909, 1, 0, 0, 0, 910, 911, 1,
		0, 0, 0, 911, 913, 1, 0, 0, 0, 912, 914, 3, 332, 166, 0, 913, 912, 1, 0,
		0, 0, 913, 914, 1, 0, 0, 0, 914, 916, 1, 0, 0, 0, 915, 917, 3, 334, 167,
		0, 916, 915, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 115, 1, 0, 0, 0, 918,
		919, 6, 58, -1, 0, 919, 920, 3, 118, 59, 0, 920, 929, 1, 0, 0, 0, 921,
		922, 10, 1, 0, 0, 922, 924, 7, 3, 0, 0, 923, 925, 3, 276, 138, 0, 924,
		923, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 928,
		3, 116, 58, 2, 927, 921, 1, 0, 0, 0, 928, 931, 1, 0, 0, 0, 929, 927, 1,
		0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 117, 1, 0, 0, 0, 931, 929, 1, 0, 0,
		0, 932, 938, 3, 120, 60, 0, 933, 934, 5, 788, 0, 0, 934, 935, 3, 106, 53,
		0, 935, 936, 5, 790, 0, 0, 936, 938, 1, 0, 0, 0, 937, 932, 1, 0, 0, 0,
		937, 933, 1, 0, 0, 0, 938, 119, 1, 0, 0, 0, 939, 941, 3, 122, 61, 0, 940,
		942, 3, 124, 62, 0, 941, 940, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 944,
		1, 0, 0, 0, 943, 945, 3, 182, 91, 0, 944, 943, 1, 0, 0, 0, 944, 945, 1,
		0, 0, 0, 945, 947, 1, 0, 0, 0, 946, 948, 3, 186, 93, 0, 947, 946, 1, 0,
		0, 0, 947, 948, 1, 0, 0, 0, 948, 950, 1, 0, 0, 0, 949, 951, 3, 184, 92,
		0, 950, 949, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 953, 1, 0, 0, 0, 952,
		954, 3, 290, 145, 0, 953, 952, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 121,
		1, 0, 0, 0, 955, 959, 5, 227, 0, 0, 956, 958, 3, 198, 99, 0, 957, 956,
		1, 0, 0, 0, 958, 961, 1, 0, 0, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0,
		0, 0, 960, 963, 1, 0, 0, 0, 961, 959, 1, 0, 0, 0, 962, 964, 3, 276, 138,
		0, 963, 962, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965,
		966, 3, 202, 101, 0, 966, 123, 1, 0, 0, 0, 967, 968, 5, 100, 0, 0, 968,
		973, 3, 138, 69, 0, 969, 970, 5, 766, 0, 0, 970, 972, 3, 138, 69, 0, 971,
		969, 1, 0, 0, 0, 972, 975, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 973, 974,
		1, 0, 0, 0, 974, 979, 1, 0, 0, 0, 975, 973, 1, 0, 0, 0, 976, 978, 3, 180,
		90, 0, 977, 976, 1, 0, 0, 0, 978, 981, 1, 0, 0, 0, 979, 977, 1, 0, 0, 0,
		979, 980, 1, 0, 0, 0, 980, 983, 1, 0, 0, 0, 981, 979, 1, 0, 0, 0, 982,
		984, 3, 148, 74, 0, 983, 982, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 986,
		1, 0, 0, 0, 985, 987, 3, 156, 78, 0, 986, 985, 1, 0, 0, 0, 986, 987, 1,
		0, 0, 0, 987, 125, 1, 0, 0, 0, 988, 989, 5, 288, 0, 0, 989, 991, 3, 210,
		105, 0, 990, 992, 3, 342, 171, 0, 991, 990, 1, 0, 0, 0, 991, 992, 1, 0,
		0, 0, 992, 127, 1, 0, 0, 0, 993, 995, 3, 260, 130, 0, 994, 996, 3, 342,
		171, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 129, 1, 0, 0,
		0, 997, 999, 5, 96, 0, 0, 998, 997, 1, 0, 0, 0, 998, 999, 1, 0, 0, 0, 999,
		1000, 1, 0, 0, 0, 1000, 1001, 7, 4, 0, 0, 1001, 1002, 5, 13, 0, 0, 1002,
		1003, 5, 169, 0, 0, 1003, 1012, 3, 364, 182, 0, 1004, 1006, 5, 96, 0, 0,
		1005, 1004, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0,
		1007, 1008, 7, 5, 0, 0, 1008, 1009, 5, 13, 0, 0, 1009, 1010, 5, 169, 0,
		0, 1010, 1012, 3, 218, 109, 0, 1011, 998, 1, 0, 0, 0, 1011, 1005, 1, 0,
		0, 0, 1012, 131, 1, 0, 0, 0, 1013, 1014, 5, 254, 0, 0, 1014, 1016, 5, 788,
		0, 0, 1015, 1017, 3, 134, 67, 0, 1016, 1015, 1, 0, 0, 0, 1016, 1017, 1,
		0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1023, 5, 790, 0, 0, 1019, 1020,
		5, 209, 0, 0, 1020, 1021, 5, 788, 0, 0, 1021, 1022, 5, 750, 0, 0, 1022,
		1024, 5, 790, 0, 0, 1023, 1019, 1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024,
		133, 1, 0, 0, 0, 1025, 1027, 5, 760, 0, 0, 1026, 1025, 1, 0, 0, 0, 1026,
		1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1029, 7, 6, 0, 0, 1029,
		1050, 5, 189, 0, 0, 1030, 1031, 3, 212, 106, 0, 1031, 1032, 5, 222, 0,
		0, 1032, 1050, 1, 0, 0, 0, 1033, 1034, 5, 19, 0, 0, 1034, 1035, 5, 750,
		0, 0, 1035, 1036, 5, 177, 0, 0, 1036, 1037, 5, 169, 0, 0, 1037, 1046, 5,
		750, 0, 0, 1038, 1044, 5, 171, 0, 0, 1039, 1045, 3, 352, 176, 0, 1040,
		1041, 3, 348, 174, 0, 1041, 1042, 5, 788, 0, 0, 1042, 1043, 5, 790, 0,
		0, 1043, 1045, 1, 0, 0, 0, 1044, 1039, 1, 0, 0, 0, 1044, 1040, 1, 0, 0,
		0, 1045, 1047, 1, 0, 0, 0, 1046, 1038, 1, 0, 0, 0, 1046, 1047, 1, 0, 0,
		0, 1047, 1050, 1, 0, 0, 0, 1048, 1050, 3, 212, 106, 0, 1049, 1026, 1, 0,
		0, 0, 1049, 1030, 1, 0, 0, 0, 1049, 1033, 1, 0, 0, 0, 1049, 1048, 1, 0,
		0, 0, 1050, 135, 1, 0, 0, 0, 1051, 1053, 3, 348, 174, 0, 1052, 1054, 3,
		208, 104, 0, 1053, 1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1056,
		1, 0, 0, 0, 1055, 1057, 3, 130, 65, 0, 1056, 1055, 1, 0, 0, 0, 1056, 1057,
		1, 0, 0, 0, 1057, 1059, 1, 0, 0, 0, 1058, 1060, 3, 132, 66, 0, 1059, 1058,
		1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1062, 1, 0, 0, 0, 1061, 1063,
		3, 342, 171, 0, 1062, 1061, 1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 1074,
		1, 0, 0, 0, 1064, 1065, 5, 788, 0, 0, 1065, 1066, 3, 106, 53, 0, 1066,
		1068, 5, 790, 0, 0, 1067, 1069, 3, 132, 66, 0, 1068, 1067, 1, 0, 0, 0,
		1068, 1069, 1, 0, 0, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1072, 3, 342, 171,
		0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1074, 1, 0, 0,
		0, 1073, 1051, 1, 0, 0, 0, 1073, 1064, 1, 0, 0, 0, 1074, 137, 1, 0, 0,
		0, 1075, 1077, 5, 131, 0, 0, 1076, 1075, 1, 0, 0, 0, 1076, 1077, 1, 0,
		0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1082, 3, 136, 68, 0, 1079, 1081, 3,
		140, 70, 0, 1080, 1079, 1, 0, 0, 0, 1081, 1084, 1, 0, 0, 0, 1082, 1080,
		1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 139, 1, 0, 0, 0, 1084, 1082,
		1, 0, 0, 0, 1085, 1089, 3, 142, 71, 0, 1086, 1089, 3, 148, 74, 0, 1087,
		1089, 3, 156, 78, 0, 1088, 1085, 1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1088,
		1087, 1, 0, 0, 0, 1089, 141, 1, 0, 0, 0, 1090, 1092, 5, 164, 0, 0, 1091,
		1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093,
		1094, 3, 146, 73, 0, 1094, 1096, 5, 128, 0, 0, 1095, 1097, 5, 131, 0, 0,
		1096, 1095, 1, 0, 0, 0, 1096, 1097, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0,
		1098, 1100, 3, 136, 68, 0, 1099, 1101, 3, 144, 72, 0, 1100, 1099, 1, 0,
		0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 143, 1, 0, 0, 0, 1102, 1103, 5, 171,
		0, 0, 1103, 1110, 3, 214, 107, 0, 1104, 1105, 5, 287, 0, 0, 1105, 1106,
		5, 788, 0, 0, 1106, 1107, 3, 350, 175, 0, 1107, 1108, 5, 790, 0, 0, 1108,
		1110, 1, 0, 0, 0, 1109, 1102, 1, 0, 0, 0, 1109, 1104, 1, 0, 0, 0, 1110,
		145, 1, 0, 0, 0, 1111, 1113, 5, 119, 0, 0, 1112, 1111, 1, 0, 0, 0, 1112,
		1113, 1, 0, 0, 0, 1113, 1136, 1, 0, 0, 0, 1114, 1136, 5, 47, 0, 0, 1115,
		1117, 5, 134, 0, 0, 1116, 1118, 5, 178, 0, 0, 1117, 1116, 1, 0, 0, 0, 1117,
		1118, 1, 0, 0, 0, 1118, 1136, 1, 0, 0, 0, 1119, 1121, 5, 134, 0, 0, 1120,
		1119, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1122, 1, 0, 0, 0, 1122,
		1136, 5, 228, 0, 0, 1123, 1125, 5, 215, 0, 0, 1124, 1126, 5, 178, 0, 0,
		1125, 1124, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1136, 1, 0, 0, 0,
		1127, 1129, 5, 101, 0, 0, 1128, 1130, 5, 178, 0, 0, 1129, 1128, 1, 0, 0,
		0, 1129, 1130, 1, 0, 0, 0, 1130, 1136, 1, 0, 0, 0, 1131, 1133, 5, 134,
		0, 0, 1132, 1131, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1134, 1, 0,
		0, 0, 1134, 1136, 5, 8, 0, 0, 1135, 1112, 1, 0, 0, 0, 1135, 1114, 1, 0,
		0, 0, 1135, 1115, 1, 0, 0, 0, 1135, 1120, 1, 0, 0, 0, 1135, 1123, 1, 0,
		0, 0, 1135, 1127, 1, 0, 0, 0, 1135, 1132, 1, 0, 0, 0, 1136, 147, 1, 0,
		0, 0, 1137, 1138, 5, 190, 0, 0, 1138, 1139, 5, 788, 0, 0, 1139, 1144, 3,
		150, 75, 0, 1140, 1141, 5, 766, 0, 0, 1141, 1143, 3, 150, 75, 0, 1142,
		1140, 1, 0, 0, 0, 1143, 1146, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1144,
		1145, 1, 0, 0, 0, 1145, 1147, 1, 0, 0, 0, 1146, 1144, 1, 0, 0, 0, 1147,
		1148, 5, 96, 0, 0, 1148, 1149, 3, 152, 76, 0, 1149, 1150, 5, 115, 0, 0,
		1150, 1151, 5, 788, 0, 0, 1151, 1156, 3, 154, 77, 0, 1152, 1153, 5, 766,
		0, 0, 1153, 1155, 3, 154, 77, 0, 1154, 1152, 1, 0, 0, 0, 1155, 1158, 1,
		0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1159, 1,
		0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1159, 1160, 5, 790, 0, 0, 1160, 1161,
		5, 790, 0, 0, 1161, 149, 1, 0, 0, 0, 1162, 1164, 3, 212, 106, 0, 1163,
		1165, 3, 342, 171, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165,
		151, 1, 0, 0, 0, 1166, 1169, 3, 352, 176, 0, 1167, 1169, 3, 208, 104, 0,
		1168, 1166, 1, 0, 0, 0, 1168, 1167, 1, 0, 0, 0, 1169, 153, 1, 0, 0, 0,
		1170, 1172, 3, 212, 106, 0, 1171, 1173, 3, 342, 171, 0, 1172, 1171, 1,
		0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1176, 1, 0, 0, 0, 1174, 1176, 3,
		208, 104, 0, 1175, 1170, 1, 0, 0, 0, 1175, 1174, 1, 0, 0, 0, 1176, 155,
		1, 0, 0, 0, 1177, 1179, 5, 282, 0, 0, 1178, 1180, 3, 158, 79, 0, 1179,
		1178, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181,
		1184, 5, 788, 0, 0, 1182, 1185, 3, 160, 80, 0, 1183, 1185, 3, 162, 81,
		0, 1184, 1182, 1, 0, 0, 0, 1184, 1183, 1, 0, 0, 0, 1185, 1186, 1, 0, 0,
		0, 1186, 1188, 5, 790, 0, 0, 1187, 1189, 3, 170, 85, 0, 1188, 1187, 1,
		0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 157, 1, 0, 0, 0, 1190, 1191, 7,
		7, 0, 0, 1191, 1192, 5, 168, 0, 0, 1192, 159, 1, 0, 0, 0, 1193, 1194, 3,
		352, 176, 0, 1194, 1195, 5, 96, 0, 0, 1195, 1196, 3, 164, 82, 0, 1196,
		1197, 5, 115, 0, 0, 1197, 1198, 5, 788, 0, 0, 1198, 1203, 3, 166, 83, 0,
		1199, 1200, 5, 766, 0, 0, 1200, 1202, 3, 166, 83, 0, 1201, 1199, 1, 0,
		0, 0, 1202, 1205, 1, 0, 0, 0, 1203, 1201, 1, 0, 0, 0, 1203, 1204, 1, 0,
		0, 0, 1204, 1206, 1, 0, 0, 0, 1205, 1203, 1, 0, 0, 0, 1206, 1207, 5, 790,
		0, 0, 1207, 161, 1, 0, 0, 0, 1208, 1209, 5, 788, 0, 0, 1209, 1210, 3, 350,
		175, 0, 1210, 1211, 5, 790, 0, 0, 1211, 1212, 5, 96, 0, 0, 1212, 1213,
		3, 164, 82, 0, 1213, 1214, 5, 115, 0, 0, 1214, 1215, 5, 788, 0, 0, 1215,
		1220, 3, 168, 84, 0, 1216, 1217, 5, 766, 0, 0, 1217, 1219, 3, 168, 84,
		0, 1218, 1216, 1, 0, 0, 0, 1219, 1222, 1, 0, 0, 0, 1220, 1218, 1, 0, 0,
		0, 1220, 1221, 1, 0, 0, 0, 1221, 1223, 1, 0, 0, 0, 1222, 1220, 1, 0, 0,
		0, 1223, 1224, 5, 790, 0, 0, 1224, 163, 1, 0, 0, 0, 1225, 1231, 3, 352,
		176, 0, 1226, 1227, 5, 788, 0, 0, 1227, 1228, 3, 350, 175, 0, 1228, 1229,
		5, 790, 0, 0, 1229, 1231, 1, 0, 0, 0, 1230, 1225, 1, 0, 0, 0, 1230, 1226,
		1, 0, 0, 0, 1231, 165, 1, 0, 0, 0, 1232, 1234, 3, 178, 89, 0, 1233, 1235,
		3, 170, 85, 0, 1234, 1233, 1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 167,
		1, 0, 0, 0, 1236, 1237, 5, 788, 0, 0, 1237, 1238, 3, 346, 173, 0, 1238,
		1240, 5, 790, 0, 0, 1239, 1241, 3, 170, 85, 0, 1240, 1239, 1, 0, 0, 0,
		1240, 1241, 1, 0, 0, 0, 1241, 169, 1, 0, 0, 0, 1242, 1244, 5, 13, 0, 0,
		1243, 1242, 1, 0, 0, 0, 1243, 1244, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0,
		1245, 1246, 3, 172, 86, 0, 1246, 171, 1, 0, 0, 0, 1247, 1250, 3, 174, 87,
		0, 1248, 1250, 3, 176, 88, 0, 1249, 1247, 1, 0, 0, 0, 1249, 1248, 1, 0,
		0, 0, 1250, 173, 1, 0, 0, 0, 1251, 1252, 5, 788, 0, 0, 1252, 1257, 3, 176,
		88, 0, 1253, 1254, 5, 766, 0, 0, 1254, 1256, 3, 176, 88, 0, 1255, 1253,
		1, 0, 0, 0, 1256, 1259, 1, 0, 0, 0, 1257, 1255, 1, 0, 0, 0, 1257, 1258,
		1, 0, 0, 0, 1258, 1260, 1, 0, 0, 0, 1259, 1257, 1, 0, 0, 0, 1260, 1261,
		5, 790, 0, 0, 1261, 175, 1, 0, 0, 0, 1262, 1265, 3, 358, 179, 0, 1263,
		1265, 3, 352, 176, 0, 1264, 1262, 1, 0, 0, 0, 1264, 1263, 1, 0, 0, 0, 1265,
		177, 1, 0, 0, 0, 1266, 1267, 3, 348, 174, 0, 1267, 179, 1, 0, 0, 0, 1268,
		1269, 5, 131, 0, 0, 1269, 1271, 5, 290, 0, 0, 1270, 1272, 5, 178, 0, 0,
		1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0,
		1273, 1274, 3, 348, 174, 0, 1274, 1275, 3, 208, 104, 0, 1275, 1276, 3,
		352, 176, 0, 1276, 1277, 5, 13, 0, 0, 1277, 1278, 3, 350, 175, 0, 1278,
		181, 1, 0, 0, 0, 1279, 1280, 5, 295, 0, 0, 1280, 1281, 3, 214, 107, 0,
		1281, 183, 1, 0, 0, 0, 1282, 1283, 5, 109, 0, 0, 1283, 1284, 3, 214, 107,
		0, 1284, 185, 1, 0, 0, 0, 1285, 1286, 5, 107, 0, 0, 1286, 1287, 5, 21,
		0, 0, 1287, 1292, 3, 190, 95, 0, 1288, 1289, 5, 766, 0, 0, 1289, 1291,
		3, 190, 95, 0, 1290, 1288, 1, 0, 0, 0, 1291, 1294, 1, 0, 0, 0, 1292, 1290,
		1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1302, 1, 0, 0, 0, 1294, 1292,
		1, 0, 0, 0, 1295, 1296, 5, 107, 0, 0, 1296, 1297, 5, 21, 0, 0, 1297, 1299,
		3, 210, 105, 0, 1298, 1300, 3, 188, 94, 0, 1299, 1298, 1, 0, 0, 0, 1299,
		1300, 1, 0, 0, 0, 1300, 1302, 1, 0, 0, 0, 1301, 1285, 1, 0, 0, 0, 1301,
		1295, 1, 0, 0, 0, 1302, 187, 1, 0, 0, 0, 1303, 1304, 5, 297, 0, 0, 1304,
		1319, 7, 8, 0, 0, 1305, 1306, 5, 108, 0, 0, 1306, 1307, 5, 235, 0, 0, 1307,
		1308, 5, 788, 0, 0, 1308, 1313, 3, 196, 98, 0, 1309, 1310, 5, 766, 0, 0,
		1310, 1312, 3, 196, 98, 0, 1311, 1309, 1, 0, 0, 0, 1312, 1315, 1, 0, 0,
		0, 1313, 1311, 1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 1316, 1, 0, 0,
		0, 1315, 1313, 1, 0, 0, 0, 1316, 1317, 5, 790, 0, 0, 1317, 1319, 1, 0,
		0, 0, 1318, 1303, 1, 0, 0, 0, 1318, 1305, 1, 0, 0, 0, 1319, 189, 1, 0,
		0, 0, 1320, 1323, 3, 194, 97, 0, 1321, 1323, 3, 212, 106, 0, 1322, 1320,
		1, 0, 0, 0, 1322, 1321, 1, 0, 0, 0, 1323, 191, 1, 0, 0, 0, 1324, 1327,
		3, 194, 97, 0, 1325, 1327, 3, 196, 98, 0, 1326, 1324, 1, 0, 0, 0, 1326,
		1325, 1, 0, 0, 0, 1327, 193, 1, 0, 0, 0, 1328, 1329, 7, 8, 0, 0, 1329,
		1330, 5, 788, 0, 0, 1330, 1335, 3, 196, 98, 0, 1331, 1332, 5, 766, 0, 0,
		1332, 1334, 3, 196, 98, 0, 1333, 1331, 1, 0, 0, 0, 1334, 1337, 1, 0, 0,
		0, 1335, 1333, 1, 0, 0, 0, 1335, 1336, 1, 0, 0, 0, 1336, 1338, 1, 0, 0,
		0, 1337, 1335, 1, 0, 0, 0, 1338, 1339, 5, 790, 0, 0, 1339, 1354, 1, 0,
		0, 0, 1340, 1341, 5, 108, 0, 0, 1341, 1342, 5, 235, 0, 0, 1342, 1343, 5,
		788, 0, 0, 1343, 1348, 3, 192, 96, 0, 1344, 1345, 5, 766, 0, 0, 1345, 1347,
		3, 192, 96, 0, 1346, 1344, 1, 0, 0, 0, 1347, 1350, 1, 0, 0, 0, 1348, 1346,
		1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0, 1349, 1351, 1, 0, 0, 0, 1350, 1348,
		1, 0, 0, 0, 1351, 1352, 5, 790, 0, 0, 1352, 1354, 1, 0, 0, 0, 1353, 1328,
		1, 0, 0, 0, 1353, 1340, 1, 0, 0, 0, 1354, 195, 1, 0, 0, 0, 1355, 1358,
		3, 208, 104, 0, 1356, 1358, 3, 212, 106, 0, 1357, 1355, 1, 0, 0, 0, 1357,
		1356, 1, 0, 0, 0, 1358, 197, 1, 0, 0, 0, 1359, 1360, 5, 786, 0, 0, 1360,
		1367, 3, 200, 100, 0, 1361, 1363, 5, 766, 0, 0, 1362, 1361, 1, 0, 0, 0,
		1362, 1363, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1366, 3, 200, 100,
		0, 1365, 1362, 1, 0, 0, 0, 1366, 1369, 1, 0, 0, 0, 1367, 1365, 1, 0, 0,
		0, 1367, 1368, 1, 0, 0, 0, 1368, 1370, 1, 0, 0, 0, 1369, 1367, 1, 0, 0,
		0, 1370, 1371, 5, 787, 0, 0, 1371, 199, 1, 0, 0, 0, 1372, 1386, 3, 352,
		176, 0, 1373, 1374, 3, 352, 176, 0, 1374, 1375, 5, 788, 0, 0, 1375, 1380,
		3, 220, 110, 0, 1376, 1377, 5, 766, 0, 0, 1377, 1379, 3, 220, 110, 0, 1378,
		1376, 1, 0, 0, 0, 1379, 1382, 1, 0, 0, 0, 1380, 1378, 1, 0, 0, 0, 1380,
		1381, 1, 0, 0, 0, 1381, 1383, 1, 0, 0, 0, 1382, 1380, 1, 0, 0, 0, 1383,
		1384, 5, 790, 0, 0, 1384, 1386, 1, 0, 0, 0, 1385, 1372, 1, 0, 0, 0, 1385,
		1373, 1, 0, 0, 0, 1386, 201, 1, 0, 0, 0, 1387, 1392, 3, 204, 102, 0, 1388,
		1389, 5, 766, 0, 0, 1389, 1391, 3, 204, 102, 0, 1390, 1388, 1, 0, 0, 0,
		1391, 1394, 1, 0, 0, 0, 1392, 1390, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0,
		1393, 203, 1, 0, 0, 0, 1394, 1392, 1, 0, 0, 0, 1395, 1401, 3, 206, 103,
		0, 1396, 1398, 3, 212, 106, 0, 1397, 1399, 3, 342, 171, 0, 1398, 1397,
		1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1401, 1, 0, 0, 0, 1400, 1395,
		1, 0, 0, 0, 1400, 1396, 1, 0, 0, 0, 1401, 205, 1, 0, 0, 0, 1402, 1403,
		3, 352, 176, 0, 1403, 1404, 5, 773, 0, 0, 1404, 1406, 1, 0, 0, 0, 1405,
		1402, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407,
		1408, 5, 761, 0, 0, 1408, 207, 1, 0, 0, 0, 1409, 1410, 5, 788, 0, 0, 1410,
		1411, 3, 210, 105, 0, 1411, 1412, 5, 790, 0, 0, 1412, 209, 1, 0, 0, 0,
		1413, 1418, 3, 212, 106, 0, 1414, 1415, 5, 766, 0, 0, 1415, 1417, 3, 212,
		106, 0, 1416, 1414, 1, 0, 0, 0, 1417, 1420, 1, 0, 0, 0, 1418, 1416, 1,
		0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 211, 1, 0, 0, 0, 1420, 1418, 1,
		0, 0, 0, 1421, 1422, 3, 214, 107, 0, 1422, 213, 1, 0, 0, 0, 1423, 1424,
		6, 107, -1, 0, 1424, 1425, 5, 788, 0, 0, 1425, 1426, 3, 214, 107, 0, 1426,
		1427, 5, 790, 0, 0, 1427, 1437, 1, 0, 0, 0, 1428, 1429, 7, 9, 0, 0, 1429,
		1437, 3, 214, 107, 6, 1430, 1431, 5, 83, 0, 0, 1431, 1437, 3, 246, 123,
		0, 1432, 1433, 3, 218, 109, 0, 1433, 1434, 3, 216, 108, 0, 1434, 1437,
		1, 0, 0, 0, 1435, 1437, 3, 218, 109, 0, 1436, 1423, 1, 0, 0, 0, 1436, 1428,
		1, 0, 0, 0, 1436, 1430, 1, 0, 0, 0, 1436, 1432, 1, 0, 0, 0, 1436, 1435,
		1, 0, 0, 0, 1437, 1446, 1, 0, 0, 0, 1438, 1439, 10, 4, 0, 0, 1439, 1440,
		5, 7, 0, 0, 1440, 1445, 3, 214, 107, 5, 1441, 1442, 10, 3, 0, 0, 1442,
		1443, 5, 175, 0, 0, 1443, 1445, 3, 214, 107, 4, 1444, 1438, 1, 0, 0, 0,
		1444, 1441, 1, 0, 0, 0, 1445, 1448, 1, 0, 0, 0, 1446, 1444, 1, 0, 0, 0,
		1446, 1447, 1, 0, 0, 0, 1447, 215, 1, 0, 0, 0, 1448, 1446, 1, 0, 0, 0,
		1449, 1451, 5, 166, 0, 0, 1450, 1449, 1, 0, 0, 0, 1450, 1451, 1, 0, 0,
		0, 1451, 1452, 1, 0, 0, 0, 1452, 1453, 5, 17, 0, 0, 1453, 1454, 3, 218,
		109, 0, 1454, 1455, 5, 7, 0, 0, 1455, 1456, 3, 218, 109, 0, 1456, 1514,
		1, 0, 0, 0, 1457, 1459, 5, 166, 0, 0, 1458, 1457, 1, 0, 0, 0, 1458, 1459,
		1, 0, 0, 0, 1459, 1460, 1, 0, 0, 0, 1460, 1461, 5, 115, 0, 0, 1461, 1514,
		3, 208, 104, 0, 1462, 1464, 5, 166, 0, 0, 1463, 1462, 1, 0, 0, 0, 1463,
		1464, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1466, 5, 115, 0, 0, 1466,
		1514, 3, 246, 123, 0, 1467, 1469, 5, 166, 0, 0, 1468, 1467, 1, 0, 0, 0,
		1468, 1469, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1471, 5, 216, 0,
		0, 1471, 1514, 3, 218, 109, 0, 1472, 1474, 5, 166, 0, 0, 1473, 1472, 1,
		0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1476, 5,
		434, 0, 0, 1476, 1514, 3, 218, 109, 0, 1477, 1479, 5, 166, 0, 0, 1478,
		1477, 1, 0, 0, 0, 1478, 1479, 1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480,
		1481, 7, 10, 0, 0, 1481, 1482, 7, 11, 0, 0, 1482, 1484, 5, 788, 0, 0, 1483,
		1485, 3, 210, 105, 0, 1484, 1483, 1, 0, 0, 0, 1484, 1485, 1, 0, 0, 0, 1485,
		1486, 1, 0, 0, 0, 1486, 1514, 5, 790, 0, 0, 1487, 1489, 5, 166, 0, 0, 1488,
		1487, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490,
		1491, 7, 10, 0, 0, 1491, 1494, 3, 218, 109, 0, 1492, 1493, 5, 78, 0, 0,
		1493, 1495, 3, 358, 179, 0, 1494, 1492, 1, 0, 0, 0, 1494, 1495, 1, 0, 0,
		0, 1495, 1514, 1, 0, 0, 0, 1496, 1498, 5, 126, 0, 0, 1497, 1499, 5, 166,
		0, 0, 1498, 1497, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1500, 1, 0,
		0, 0, 1500, 1514, 5, 167, 0, 0, 1501, 1503, 5, 126, 0, 0, 1502, 1504, 5,
		166, 0, 0, 1503, 1502, 1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1505,
		1, 0, 0, 0, 1505, 1514, 7, 12, 0, 0, 1506, 1508, 5, 126, 0, 0, 1507, 1509,
		5, 166, 0, 0, 1508, 1507, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 1510,
		1, 0, 0, 0, 1510, 1511, 5, 72, 0, 0, 1511, 1512, 5, 100, 0, 0, 1512, 1514,
		3, 218, 109, 0, 1513, 1450, 1, 0, 0, 0, 1513, 1458, 1, 0, 0, 0, 1513, 1463,
		1, 0, 0, 0, 1513, 1468, 1, 0, 0, 0, 1513, 1473, 1, 0, 0, 0, 1513, 1478,
		1, 0, 0, 0, 1513, 1488, 1, 0, 0, 0, 1513, 1496, 1, 0, 0, 0, 1513, 1501,
		1, 0, 0, 0, 1513, 1506, 1, 0, 0, 0, 1514, 217, 1, 0, 0, 0, 1515, 1516,
		6, 109, -1, 0, 1516, 1517, 5, 788, 0, 0, 1517, 1518, 3, 218, 109, 0, 1518,
		1519, 5, 790, 0, 0, 1519, 1524, 1, 0, 0, 0, 1520, 1521, 7, 13, 0, 0, 1521,
		1524, 3, 218, 109, 8, 1522, 1524, 3, 220, 110, 0, 1523, 1515, 1, 0, 0,
		0, 1523, 1520, 1, 0, 0, 0, 1523, 1522, 1, 0, 0, 0, 1524, 1546, 1, 0, 0,
		0, 1525, 1526, 10, 7, 0, 0, 1526, 1527, 7, 14, 0, 0, 1527, 1545, 3, 218,
		109, 8, 1528, 1529, 10, 6, 0, 0, 1529, 1530, 7, 15, 0, 0, 1530, 1545, 3,
		218, 109, 7, 1531, 1532, 10, 5, 0, 0, 1532, 1533, 5, 772, 0, 0, 1533, 1545,
		3, 218, 109, 6, 1534, 1535, 10, 4, 0, 0, 1535, 1536, 5, 769, 0, 0, 1536,
		1545, 3, 218, 109, 5, 1537, 1538, 10, 3, 0, 0, 1538, 1539, 5, 770, 0, 0,
		1539, 1545, 3, 218, 109, 4, 1540, 1541, 10, 2, 0, 0, 1541, 1542, 3, 268,
		134, 0, 1542, 1543, 3, 218, 109, 3, 1543, 1545, 1, 0, 0, 0, 1544, 1525,
		1, 0, 0, 0, 1544, 1528, 1, 0, 0, 0, 1544, 1531, 1, 0, 0, 0, 1544, 1534,
		1, 0, 0, 0, 1544, 1537, 1, 0, 0, 0, 1544, 1540, 1, 0, 0, 0, 1545, 1548,
		1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1546, 1547, 1, 0, 0, 0, 1547, 219,
		1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1549, 1550, 6, 110, -1, 0, 1550, 1560,
		3, 222, 111, 0, 1551, 1560, 3, 232, 116, 0, 1552, 1560, 3, 352, 176, 0,
		1553, 1554, 3, 352, 176, 0, 1554, 1555, 5, 773, 0, 0, 1555, 1556, 3, 352,
		176, 0, 1556, 1560, 1, 0, 0, 0, 1557, 1560, 3, 246, 123, 0, 1558, 1560,
		3, 266, 133, 0, 1559, 1549, 1, 0, 0, 0, 1559, 1551, 1, 0, 0, 0, 1559, 1552,
		1, 0, 0, 0, 1559, 1553, 1, 0, 0, 0, 1559, 1557, 1, 0, 0, 0, 1559, 1558,
		1, 0, 0, 0, 1560, 1568, 1, 0, 0, 0, 1561, 1562, 10, 1, 0, 0, 1562, 1563,
		5, 789, 0, 0, 1563, 1564, 3, 218, 109, 0, 1564, 1565, 5, 791, 0, 0, 1565,
		1567, 1, 0, 0, 0, 1566, 1561, 1, 0, 0, 0, 1567, 1570, 1, 0, 0, 0, 1568,
		1566, 1, 0, 0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 221, 1, 0, 0, 0, 1570,
		1568, 1, 0, 0, 0, 1571, 1574, 3, 224, 112, 0, 1572, 1574, 3, 226, 113,
		0, 1573, 1571, 1, 0, 0, 0, 1573, 1572, 1, 0, 0, 0, 1574, 223, 1, 0, 0,
		0, 1575, 1577, 5, 24, 0, 0, 1576, 1578, 3, 228, 114, 0, 1577, 1576, 1,
		0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 1577, 1, 0, 0, 0, 1579, 1580, 1,
		0, 0, 0, 1580, 1582, 1, 0, 0, 0, 1581, 1583, 3, 230, 115, 0, 1582, 1581,
		1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1585,
		5, 77, 0, 0, 1585, 225, 1, 0, 0, 0, 1586, 1587, 5, 24, 0, 0, 1587, 1589,
		3, 212, 106, 0, 1588, 1590, 3, 228, 114, 0, 1589, 1588, 1, 0, 0, 0, 1590,
		1591, 1, 0, 0, 0, 1591, 1589, 1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592,
		1594, 1, 0, 0, 0, 1593, 1595, 3, 230, 115, 0, 1594, 1593, 1, 0, 0, 0, 1594,
		1595, 1, 0, 0, 0, 1595, 1596, 1, 0, 0, 0, 1596, 1597, 5, 77, 0, 0, 1597,
		227, 1, 0, 0, 0, 1598, 1599, 5, 294, 0, 0, 1599, 1600, 3, 212, 106, 0,
		1600, 1601, 5, 259, 0, 0, 1601, 1602, 3, 212, 106, 0, 1602, 229, 1, 0,
		0, 0, 1603, 1604, 5, 76, 0, 0, 1604, 1605, 3, 212, 106, 0, 1605, 231, 1,
		0, 0, 0, 1606, 1609, 3, 234, 117, 0, 1607, 1609, 3, 260, 130, 0, 1608,
		1606, 1, 0, 0, 0, 1608, 1607, 1, 0, 0, 0, 1609, 233, 1, 0, 0, 0, 1610,
		1622, 3, 236, 118, 0, 1611, 1622, 3, 238, 119, 0, 1612, 1622, 3, 240, 120,
		0, 1613, 1622, 3, 242, 121, 0, 1614, 1622, 3, 244, 122, 0, 1615, 1622,
		3, 248, 124, 0, 1616, 1622, 3, 250, 125, 0, 1617, 1622, 3, 252, 126, 0,
		1618, 1622, 3, 254, 127, 0, 1619, 1622, 3, 256, 128, 0, 1620, 1622, 3,
		258, 129, 0, 1621, 1610, 1, 0, 0, 0, 1621, 1611, 1, 0, 0, 0, 1621, 1612,
		1, 0, 0, 0, 1621, 1613, 1, 0, 0, 0, 1621, 1614, 1, 0, 0, 0, 1621, 1615,
		1, 0, 0, 0, 1621, 1616, 1, 0, 0, 0, 1621, 1617, 1, 0, 0, 0, 1621, 1618,
		1, 0, 0, 0, 1621, 1619, 1, 0, 0, 0, 1621, 1620, 1, 0, 0, 0, 1622, 235,
		1, 0, 0, 0, 1623, 1624, 7, 16, 0, 0, 1624, 1625, 5, 788, 0, 0, 1625, 1626,
		3, 212, 106, 0, 1626, 1627, 5, 13, 0, 0, 1627, 1628, 3, 270, 135, 0, 1628,
		1629, 5, 790, 0, 0, 1629, 237, 1, 0, 0, 0, 1630, 1631, 5, 246, 0, 0, 1631,
		1640, 5, 788, 0, 0, 1632, 1637, 3, 204, 102, 0, 1633, 1634, 5, 766, 0,
		0, 1634, 1636, 3, 204, 102, 0, 1635, 1633, 1, 0, 0, 0, 1636, 1639, 1, 0,
		0, 0, 1637, 1635, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1641, 1, 0,
		0, 0, 1639, 1637, 1, 0, 0, 0, 1640, 1632, 1, 0, 0, 0, 1640, 1641, 1, 0,
		0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 1643, 5, 790, 0, 0, 1643, 239, 1, 0,
		0, 0, 1644, 1645, 5, 94, 0, 0, 1645, 1646, 5, 788, 0, 0, 1646, 1649, 3,
		212, 106, 0, 1647, 1648, 5, 113, 0, 0, 1648, 1650, 5, 168, 0, 0, 1649,
		1647, 1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651,
		1652, 5, 790, 0, 0, 1652, 241, 1, 0, 0, 0, 1653, 1654, 5, 10, 0, 0, 1654,
		1655, 5, 788, 0, 0, 1655, 1658, 3, 212, 106, 0, 1656, 1657, 5, 113, 0,
		0, 1657, 1659, 5, 168, 0, 0, 1658, 1656, 1, 0, 0, 0, 1658, 1659, 1, 0,
		0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1661, 5, 790, 0, 0, 1661, 243, 1, 0,
		0, 0, 1662, 1663, 5, 130, 0, 0, 1663, 1664, 5, 788, 0, 0, 1664, 1667, 3,
		212, 106, 0, 1665, 1666, 5, 113, 0, 0, 1666, 1668, 5, 168, 0, 0, 1667,
		1665, 1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1669, 1, 0, 0, 0, 1669,
		1670, 5, 790, 0, 0, 1670, 245, 1, 0, 0, 0, 1671, 1672, 5, 788, 0, 0, 1672,
		1673, 3, 106, 53, 0, 1673, 1674, 5, 790, 0, 0, 1674, 247, 1, 0, 0, 0, 1675,
		1676, 7, 17, 0, 0, 1676, 1678, 5, 788, 0, 0, 1677, 1679, 7, 18, 0, 0, 1678,
		1677, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1681, 1, 0, 0, 0, 1680,
		1682, 3, 218, 109, 0, 1681, 1680, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682,
		1683, 1, 0, 0, 0, 1683, 1684, 5, 100, 0, 0, 1684, 1685, 3, 218, 109, 0,
		1685, 1686, 5, 790, 0, 0, 1686, 249, 1, 0, 0, 0, 1687, 1688, 5, 88, 0,
		0, 1688, 1689, 5, 788, 0, 0, 1689, 1690, 3, 352, 176, 0, 1690, 1691, 5,
		100, 0, 0, 1691, 1692, 3, 218, 109, 0, 1692, 1693, 5, 790, 0, 0, 1693,
		251, 1, 0, 0, 0, 1694, 1695, 7, 19, 0, 0, 1695, 1696, 5, 788, 0, 0, 1696,
		1697, 3, 218, 109, 0, 1697, 1698, 7, 20, 0, 0, 1698, 1701, 3, 218, 109,
		0, 1699, 1700, 7, 21, 0, 0, 1700, 1702, 3, 218, 109, 0, 1701, 1699, 1,
		0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 1704, 5,
		790, 0, 0, 1704, 253, 1, 0, 0, 0, 1705, 1706, 5, 182, 0, 0, 1706, 1707,
		5, 788, 0, 0, 1707, 1708, 3, 218, 109, 0, 1708, 1709, 5, 191, 0, 0, 1709,
		1710, 3, 218, 109, 0, 1710, 1711, 5, 100, 0, 0, 1711, 1714, 3, 218, 109,
		0, 1712, 1713, 5, 96, 0, 0, 1713, 1715, 3, 218, 109, 0, 1714, 1712, 1,
		0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1717, 5,
		790, 0, 0, 1717, 255, 1, 0, 0, 0, 1718, 1719, 7, 22, 0, 0, 1719, 1720,
		5, 788, 0, 0, 1720, 1721, 3, 218, 109, 0, 1721, 1722, 5, 790, 0, 0, 1722,
		1723, 5, 298, 0, 0, 1723, 1724, 5, 107, 0, 0, 1724, 1725, 5, 788, 0, 0,
		1725, 1726, 3, 320, 160, 0, 1726, 1728, 5, 790, 0, 0, 1727, 1729, 3, 264,
		132, 0, 1728, 1727, 1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1731, 1,
		0, 0, 0, 1730, 1732, 3, 262, 131, 0, 1731, 1730, 1, 0, 0, 0, 1731, 1732,
		1, 0, 0, 0, 1732, 257, 1, 0, 0, 0, 1733, 1734, 5, 711, 0, 0, 1734, 1735,
		5, 788, 0, 0, 1735, 1736, 3, 318, 159, 0, 1736, 1737, 5, 790, 0, 0, 1737,
		1738, 5, 13, 0, 0, 1738, 1739, 5, 788, 0, 0, 1739, 1740, 3, 350, 175, 0,
		1740, 1741, 5, 790, 0, 0, 1741, 259, 1, 0, 0, 0, 1742, 1743, 3, 348, 174,
		0, 1743, 1745, 5, 788, 0, 0, 1744, 1746, 3, 318, 159, 0, 1745, 1744, 1,
		0, 0, 0, 1745, 1746, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1749, 5,
		790, 0, 0, 1748, 1750, 3, 264, 132, 0, 1749, 1748, 1, 0, 0, 0, 1749, 1750,
		1, 0, 0, 0, 1750, 1753, 1, 0, 0, 0, 1751, 1752, 7, 23, 0, 0, 1752, 1754,
		5, 168, 0, 0, 1753, 1751, 1, 0, 0, 0, 1753, 1754, 1, 0, 0, 0, 1754, 1756,
		1, 0, 0, 0, 1755, 1757, 3, 262, 131, 0, 1756, 1755, 1, 0, 0, 0, 1756, 1757,
		1, 0, 0, 0, 1757, 261, 1, 0, 0, 0, 1758, 1759, 5, 180, 0, 0, 1759, 1760,
		3, 294, 147, 0, 1760, 263, 1, 0, 0, 0, 1761, 1762, 5, 92, 0, 0, 1762, 1763,
		5, 788, 0, 0, 1763, 1764, 5, 295, 0, 0, 1764, 1765, 3, 214, 107, 0, 1765,
		1766, 5, 790, 0, 0, 1766, 265, 1, 0, 0, 0, 1767, 1776, 3, 362, 181, 0,
		1768, 1776, 3, 278, 139, 0, 1769, 1776, 3, 356, 178, 0, 1770, 1771, 3,
		352, 176, 0, 1771, 1772, 3, 358, 179, 0, 1772, 1776, 1, 0, 0, 0, 1773,
		1776, 3, 360, 180, 0, 1774, 1776, 3, 358, 179, 0, 1775, 1767, 1, 0, 0,
		0, 1775, 1768, 1, 0, 0, 0, 1775, 1769, 1, 0, 0, 0, 1775, 1770, 1, 0, 0,
		0, 1775, 1773, 1, 0, 0, 0, 1775, 1774, 1, 0, 0, 0, 1776, 267, 1, 0, 0,
		0, 1777, 1778, 7, 24, 0, 0, 1778, 269, 1, 0, 0, 0, 1779, 1780, 5, 12, 0,
		0, 1780, 1781, 5, 781, 0, 0, 1781, 1782, 3, 270, 135, 0, 1782, 1783, 5,
		778, 0, 0, 1783, 1826, 1, 0, 0, 0, 1784, 1785, 5, 147, 0, 0, 1785, 1786,
		5, 781, 0, 0, 1786, 1787, 3, 270, 135, 0, 1787, 1788, 5, 766, 0, 0, 1788,
		1789, 3, 270, 135, 0, 1789, 1790, 5, 778, 0, 0, 1790, 1826, 1, 0, 0, 0,
		1791, 1798, 5, 246, 0, 0, 1792, 1794, 5, 781, 0, 0, 1793, 1795, 3, 272,
		136, 0, 1794, 1793, 1, 0, 0, 0, 1794, 1795, 1, 0, 0, 0, 1795, 1796, 1,
		0, 0, 0, 1796, 1799, 5, 778, 0, 0, 1797, 1799, 5, 776, 0, 0, 1798, 1792,
		1, 0, 0, 0, 1798, 1797, 1, 0, 0, 0, 1799, 1826, 1, 0, 0, 0, 1800, 1801,
		5, 124, 0, 0, 1801, 1804, 7, 25, 0, 0, 1802, 1803, 5, 264, 0, 0, 1803,
		1805, 5, 157, 0, 0, 1804, 1802, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805,
		1826, 1, 0, 0, 0, 1806, 1807, 5, 124, 0, 0, 1807, 1810, 7, 26, 0, 0, 1808,
		1809, 5, 264, 0, 0, 1809, 1811, 7, 27, 0, 0, 1810, 1808, 1, 0, 0, 0, 1810,
		1811, 1, 0, 0, 0, 1811, 1826, 1, 0, 0, 0, 1812, 1823, 3, 352, 176, 0, 1813,
		1814, 5, 788, 0, 0, 1814, 1819, 5, 750, 0, 0, 1815, 1816, 5, 766, 0, 0,
		1816, 1818, 5, 750, 0, 0, 1817, 1815, 1, 0, 0, 0, 1818, 1821, 1, 0, 0,
		0, 1819, 1817, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1822, 1, 0, 0,
		0, 1821, 1819, 1, 0, 0, 0, 1822, 1824, 5, 790, 0, 0, 1823, 1813, 1, 0,
		0, 0, 1823, 1824, 1, 0, 0, 0, 1824, 1826, 1, 0, 0, 0, 1825, 1779, 1, 0,
		0, 0, 1825, 1784, 1, 0, 0, 0, 1825, 1791, 1, 0, 0, 0, 1825, 1800, 1, 0,
		0, 0, 1825, 1806, 1, 0, 0, 0, 1825, 1812, 1, 0, 0, 0, 1826, 271, 1, 0,
		0, 0, 1827, 1832, 3, 274, 137, 0, 1828, 1829, 5, 766, 0, 0, 1829, 1831,
		3, 274, 137, 0, 1830, 1828, 1, 0, 0, 0, 1831, 1834, 1, 0, 0, 0, 1832, 1830,
		1, 0, 0, 0, 1832, 1833, 1, 0, 0, 0, 1833, 273, 1, 0, 0, 0, 1834, 1832,
		1, 0, 0, 0, 1835, 1837, 3, 352, 176, 0, 1836, 1838, 5, 765, 0, 0, 1837,
		1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839,
		1842, 3, 270, 135, 0, 1840, 1841, 5, 166, 0, 0, 1841, 1843, 5, 167, 0,
		0, 1842, 1840, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843, 1845, 1, 0, 0,
		0, 1844, 1846, 3, 288, 144, 0, 1845, 1844, 1, 0, 0, 0, 1845, 1846, 1, 0,
		0, 0, 1846, 275, 1, 0, 0, 0, 1847, 1848, 7, 28, 0, 0, 1848, 277, 1, 0,
		0, 0, 1849, 1852, 5, 124, 0, 0, 1850, 1853, 3, 282, 141, 0, 1851, 1853,
		3, 280, 140, 0, 1852, 1850, 1, 0, 0, 0, 1852, 1851, 1, 0, 0, 0, 1853, 279,
		1, 0, 0, 0, 1854, 1855, 3, 212, 106, 0, 1855, 1856, 3, 284, 142, 0, 1856,
		1858, 1, 0, 0, 0, 1857, 1854, 1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 1859,
		1857, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 281, 1, 0, 0, 0, 1861,
		1862, 3, 212, 106, 0, 1862, 1863, 3, 286, 143, 0, 1863, 1864, 5, 264, 0,
		0, 1864, 1865, 3, 286, 143, 0, 1865, 283, 1, 0, 0, 0, 1866, 1867, 7, 29,
		0, 0, 1867, 285, 1, 0, 0, 0, 1868, 1869, 7, 30, 0, 0, 1869, 287, 1, 0,
		0, 0, 1870, 1871, 5, 38, 0, 0, 1871, 1872, 3, 358, 179, 0, 1872, 289, 1,
		0, 0, 0, 1873, 1874, 5, 296, 0, 0, 1874, 1879, 3, 292, 146, 0, 1875, 1876,
		5, 766, 0, 0, 1876, 1878, 3, 292, 146, 0, 1877, 1875, 1, 0, 0, 0, 1878,
		1881, 1, 0, 0, 0, 1879, 1877, 1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880,
		291, 1, 0, 0, 0, 1881, 1879, 1, 0, 0, 0, 1882, 1883, 3, 352, 176, 0, 1883,
		1884, 5, 13, 0, 0, 1884, 1885, 3, 294, 147, 0, 1885, 293, 1, 0, 0, 0, 1886,
		1908, 3, 352, 176, 0, 1887, 1888, 5, 788, 0, 0, 1888, 1889, 3, 352, 176,
		0, 1889, 1890, 5, 790, 0, 0, 1890, 1908, 1, 0, 0, 0, 1891, 1901, 5, 788,
		0, 0, 1892, 1902, 3, 328, 164, 0, 1893, 1896, 3, 326, 163, 0, 1894, 1896,
		3, 324, 162, 0, 1895, 1893, 1, 0, 0, 0, 1895, 1894, 1, 0, 0, 0, 1895, 1896,
		1, 0, 0, 0, 1896, 1899, 1, 0, 0, 0, 1897, 1900, 3, 320, 160, 0, 1898, 1900,
		3, 322, 161, 0, 1899, 1897, 1, 0, 0, 0, 1899, 1898, 1, 0, 0, 0, 1899, 1900,
		1, 0, 0, 0, 1900, 1902, 1, 0, 0, 0, 1901, 1892, 1, 0, 0, 0, 1901, 1895,
		1, 0, 0, 0, 1902, 1904, 1, 0, 0, 0, 1903, 1905, 3, 296, 148, 0, 1904, 1903,
		1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1908,
		5, 790, 0, 0, 1907, 1886, 1, 0, 0, 0, 1907, 1887, 1, 0, 0, 0, 1907, 1891,
		1, 0, 0, 0, 1908, 295, 1, 0, 0, 0, 1909, 1910, 7, 31, 0, 0, 1910, 1918,
		3, 298, 149, 0, 1911, 1912, 7, 31, 0, 0, 1912, 1913, 5, 17, 0, 0, 1913,
		1914, 3, 298, 149, 0, 1914, 1915, 5, 7, 0, 0, 1915, 1916, 3, 298, 149,
		0, 1916, 1918, 1, 0, 0, 0, 1917, 1909, 1, 0, 0, 0, 1917, 1911, 1, 0, 0,
		0, 1918, 297, 1, 0, 0, 0, 1919, 1920, 5, 276, 0, 0, 1920, 1927, 7, 32,
		0, 0, 1921, 1922, 5, 49, 0, 0, 1922, 1927, 5, 221, 0, 0, 1923, 1924, 3,
		212, 106, 0, 1924, 1925, 7, 32, 0, 0, 1925, 1927, 1, 0, 0, 0, 1926, 1919,
		1, 0, 0, 0, 1926, 1921, 1, 0, 0, 0, 1926, 1923, 1, 0, 0, 0, 1927, 299,
		1, 0, 0, 0, 1928, 1929, 5, 287, 0, 0, 1929, 1930, 3, 348, 174, 0, 1930,
		301, 1, 0, 0, 0, 1931, 1932, 5, 244, 0, 0, 1932, 1933, 5, 13, 0, 0, 1933,
		1938, 3, 304, 152, 0, 1934, 1935, 5, 244, 0, 0, 1935, 1936, 5, 21, 0, 0,
		1936, 1938, 3, 306, 153, 0, 1937, 1931, 1, 0, 0, 0, 1937, 1934, 1, 0, 0,
		0, 1938, 303, 1, 0, 0, 0, 1939, 1940, 5, 121, 0, 0, 1940, 1941, 3, 358,
		179, 0, 1941, 1942, 5, 179, 0, 0, 1942, 1943, 3, 358, 179, 0, 1943, 1946,
		1, 0, 0, 0, 1944, 1946, 3, 352, 176, 0, 1945, 1939, 1, 0, 0, 0, 1945, 1944,
		1, 0, 0, 0, 1946, 305, 1, 0, 0, 0, 1947, 1951, 3, 358, 179, 0, 1948, 1949,
		5, 297, 0, 0, 1949, 1950, 5, 231, 0, 0, 1950, 1952, 3, 310, 155, 0, 1951,
		1948, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 307, 1, 0, 0, 0, 1953,
		1954, 5, 221, 0, 0, 1954, 1955, 5, 98, 0, 0, 1955, 1956, 5, 230, 0, 0,
		1956, 1960, 3, 358, 179, 0, 1957, 1958, 5, 297, 0, 0, 1958, 1959, 5, 231,
		0, 0, 1959, 1961, 3, 310, 155, 0, 1960, 1957, 1, 0, 0, 0, 1960, 1961, 1,
		0, 0, 0, 1961, 2003, 1, 0, 0, 0, 1962, 1963, 5, 221, 0, 0, 1963, 1964,
		5, 98, 0, 0, 1964, 1974, 5, 66, 0, 0, 1965, 1966, 5, 91, 0, 0, 1966, 1967,
		5, 258, 0, 0, 1967, 1968, 5, 21, 0, 0, 1968, 1972, 3, 358, 179, 0, 1969,
		1970, 5, 79, 0, 0, 1970, 1971, 5, 21, 0, 0, 1971, 1973, 3, 358, 179, 0,
		1972, 1969, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973, 1975, 1, 0, 0, 0,
		1974, 1965, 1, 0, 0, 0, 1974, 1975, 1, 0, 0, 0, 1975, 1981, 1, 0, 0, 0,
		1976, 1977, 5, 35, 0, 0, 1977, 1978, 5, 127, 0, 0, 1978, 1979, 5, 258,
		0, 0, 1979, 1980, 5, 21, 0, 0, 1980, 1982, 3, 358, 179, 0, 1981, 1976,
		1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 1988, 1, 0, 0, 0, 1983, 1984,
		5, 147, 0, 0, 1984, 1985, 5, 129, 0, 0, 1985, 1986, 5, 258, 0, 0, 1986,
		1987, 5, 21, 0, 0, 1987, 1989, 3, 358, 179, 0, 1988, 1983, 1, 0, 0, 0,
		1988, 1989, 1, 0, 0, 0, 1989, 1994, 1, 0, 0, 0, 1990, 1991, 5, 138, 0,
		0, 1991, 1992, 5, 258, 0, 0, 1992, 1993, 5, 21, 0, 0, 1993, 1995, 3, 358,
		179, 0, 1994, 1990, 1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995, 2000, 1,
		0, 0, 0, 1996, 1997, 5, 167, 0, 0, 1997, 1998, 5, 64, 0, 0, 1998, 1999,
		5, 13, 0, 0, 1999, 2001, 3, 358, 179, 0, 2000, 1996, 1, 0, 0, 0, 2000,
		2001, 1, 0, 0, 0, 2001, 2003, 1, 0, 0, 0, 2002, 1953, 1, 0, 0, 0, 2002,
		1962, 1, 0, 0, 0, 2003, 309, 1, 0, 0, 0, 2004, 2005, 5, 788, 0, 0, 2005,
		2010, 3, 312, 156, 0, 2006, 2007, 5, 766, 0, 0, 2007, 2009, 3, 312, 156,
		0, 2008, 2006, 1, 0, 0, 0, 2009, 2012, 1, 0, 0, 0, 2010, 2008, 1, 0, 0,
		0, 2010, 2011, 1, 0, 0, 0, 2011, 2013, 1, 0, 0, 0, 2012, 2010, 1, 0, 0,
		0, 2013, 2014, 5, 790, 0, 0, 2014, 311, 1, 0, 0, 0, 2015, 2020, 3, 314,
		157, 0, 2016, 2018, 5, 774, 0, 0, 2017, 2016, 1, 0, 0, 0, 2017, 2018, 1,
		0, 0, 0, 2018, 2019, 1, 0, 0, 0, 2019, 2021, 3, 316, 158, 0, 2020, 2017,
		1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 313, 1, 0, 0, 0, 2022, 2027,
		3, 352, 176, 0, 2023, 2024, 5, 773, 0, 0, 2024, 2026, 3, 352, 176, 0, 2025,
		2023, 1, 0, 0, 0, 2026, 2029, 1, 0, 0, 0, 2027, 2025, 1, 0, 0, 0, 2027,
		2028, 1, 0, 0, 0, 2028, 2032, 1, 0, 0, 0, 2029, 2027, 1, 0, 0, 0, 2030,
		2032, 3, 358, 179, 0, 2031, 2022, 1, 0, 0, 0, 2031, 2030, 1, 0, 0, 0, 2032,
		315, 1, 0, 0, 0, 2033, 2038, 5, 750, 0, 0, 2034, 2038, 5, 753, 0, 0, 2035,
		2038, 3, 360, 180, 0, 2036, 2038, 3, 358, 179, 0, 2037, 2033, 1, 0, 0,
		0, 2037, 2034, 1, 0, 0, 0, 2037, 2035, 1, 0, 0, 0, 2037, 2036, 1, 0, 0,
		0, 2038, 317, 1, 0, 0, 0, 2039, 2041, 3, 276, 138, 0, 2040, 2039, 1, 0,
		0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 2042, 1, 0, 0, 0, 2042, 2047, 3, 212,
		106, 0, 2043, 2044, 5, 766, 0, 0, 2044, 2046, 3, 212, 106, 0, 2045, 2043,
		1, 0, 0, 0, 2046, 2049, 1, 0, 0, 0, 2047, 2045, 1, 0, 0, 0, 2047, 2048,
		1, 0, 0, 0, 2048, 2055, 1, 0, 0, 0, 2049, 2047, 1, 0, 0, 0, 2050, 2052,
		3, 276, 138, 0, 2051, 2050, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2053,
		1, 0, 0, 0, 2053, 2055, 5, 761, 0, 0, 2054, 2040, 1, 0, 0, 0, 2054, 2051,
		1, 0, 0, 0, 2055, 319, 1, 0, 0, 0, 2056, 2057, 5, 176, 0, 0, 2057, 2058,
		5, 21, 0, 0, 2058, 2059, 3, 336, 168, 0, 2059, 321, 1, 0, 0, 0, 2060, 2061,
		7, 33, 0, 0, 2061, 2062, 5, 21, 0, 0, 2062, 2063, 3, 336, 168, 0, 2063,
		323, 1, 0, 0, 0, 2064, 2065, 5, 73, 0, 0, 2065, 2066, 5, 21, 0, 0, 2066,
		2067, 3, 210, 105, 0, 2067, 325, 1, 0, 0, 0, 2068, 2069, 5, 184, 0, 0,
		2069, 2070, 5, 21, 0, 0, 2070, 2071, 3, 210, 105, 0, 2071, 327, 1, 0, 0,
		0, 2072, 2074, 5, 200, 0, 0, 2073, 2072, 1, 0, 0, 0, 2073, 2074, 1, 0,
		0, 0, 2074, 2075, 1, 0, 0, 0, 2075, 2076, 7, 34, 0, 0, 2076, 2077, 5, 21,
		0, 0, 2077, 2079, 3, 210, 105, 0, 2078, 2080, 3, 340, 170, 0, 2079, 2078,
		1, 0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 329, 1, 0, 0, 0, 2081, 2082,
		5, 125, 0, 0, 2082, 2083, 3, 356, 178, 0, 2083, 2084, 5, 20, 0, 0, 2084,
		331, 1, 0, 0, 0, 2085, 2087, 5, 137, 0, 0, 2086, 2088, 5, 3, 0, 0, 2087,
		2086, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088, 2089, 1, 0, 0, 0, 2089,
		2090, 3, 212, 106, 0, 2090, 333, 1, 0, 0, 0, 2091, 2092, 5, 170, 0, 0,
		2092, 2093, 3, 212, 106, 0, 2093, 335, 1, 0, 0, 0, 2094, 2099, 3, 338,
		169, 0, 2095, 2096, 5, 766, 0, 0, 2096, 2098, 3, 338, 169, 0, 2097, 2095,
		1, 0, 0, 0, 2098, 2101, 1, 0, 0, 0, 2099, 2097, 1, 0, 0, 0, 2099, 2100,
		1, 0, 0, 0, 2100, 337, 1, 0, 0, 0, 2101, 2099, 1, 0, 0, 0, 2102, 2104,
		3, 212, 106, 0, 2103, 2105, 3, 340, 170, 0, 2104, 2103, 1, 0, 0, 0, 2104,
		2105, 1, 0, 0, 0, 2105, 2108, 1, 0, 0, 0, 2106, 2107, 5, 168, 0, 0, 2107,
		2109, 7, 35, 0, 0, 2108, 2106, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109,
		339, 1, 0, 0, 0, 2110, 2111, 7, 36, 0, 0, 2111, 341, 1, 0, 0, 0, 2112,
		2114, 5, 13, 0, 0, 2113, 2112, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114,
		2115, 1, 0, 0, 0, 2115, 2116, 3, 352, 176, 0, 2116, 343, 1, 0, 0, 0, 2117,
		2118, 5, 142, 0, 0, 2118, 2119, 3, 358, 179, 0, 2119, 345, 1, 0, 0, 0,
		2120, 2125, 3, 348, 174, 0, 2121, 2122, 5, 766, 0, 0, 2122, 2124, 3, 348,
		174, 0, 2123, 2121, 1, 0, 0, 0, 2124, 2127, 1, 0, 0, 0, 2125, 2123, 1,
		0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126, 347, 1, 0, 0, 0, 2127, 2125, 1,
		0, 0, 0, 2128, 2133, 3, 352, 176, 0, 2129, 2130, 5, 773, 0, 0, 2130, 2132,
		3, 352, 176, 0, 2131, 2129, 1, 0, 0, 0, 2132, 2135, 1, 0, 0, 0, 2133, 2131,
		1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0, 2134, 349, 1, 0, 0, 0, 2135, 2133,
		1, 0, 0, 0, 2136, 2141, 3, 352, 176, 0, 2137, 2138, 5, 766, 0, 0, 2138,
		2140, 3, 352, 176, 0, 2139, 2137, 1, 0, 0, 0, 2140, 2143, 1, 0, 0, 0, 2141,
		2139, 1, 0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 351, 1, 0, 0, 0, 2143,
		2141, 1, 0, 0, 0, 2144, 2148, 5, 757, 0, 0, 2145, 2148, 3, 354, 177, 0,
		2146, 2148, 3, 366, 183, 0, 2147, 2144, 1, 0, 0, 0, 2147, 2145, 1, 0, 0,
		0, 2147, 2146, 1, 0, 0, 0, 2148, 353, 1, 0, 0, 0, 2149, 2153, 5, 758, 0,
		0, 2150, 2151, 4, 177, 10, 0, 2151, 2153, 5, 747, 0, 0, 2152, 2149, 1,
		0, 0, 0, 2152, 2150, 1, 0, 0, 0, 2153, 355, 1, 0, 0, 0, 2154, 2156, 5,
		760, 0, 0, 2155, 2154, 1, 0, 0, 0, 2155, 2156, 1, 0, 0, 0, 2156, 2157,
		1, 0, 0, 0, 2157, 2195, 5, 752, 0, 0, 2158, 2160, 5, 760, 0, 0, 2159, 2158,
		1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160, 2161, 1, 0, 0, 0, 2161, 2195,
		5, 753, 0, 0, 2162, 2164, 5, 760, 0, 0, 2163, 2162, 1, 0, 0, 0, 2163, 2164,
		1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2195, 7, 37, 0, 0, 2166, 2168,
		5, 760, 0, 0, 2167, 2166, 1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168, 2169,
		1, 0, 0, 0, 2169, 2195, 5, 750, 0, 0, 2170, 2172, 5, 760, 0, 0, 2171, 2170,
		1, 0, 0, 0, 2171, 2172, 1, 0, 0, 0, 2172, 2173, 1, 0, 0, 0, 2173, 2195,
		5, 748, 0, 0, 2174, 2176, 5, 760, 0, 0, 2175, 2174, 1, 0, 0, 0, 2175, 2176,
		1, 0, 0, 0, 2176, 2177, 1, 0, 0, 0, 2177, 2195, 5, 749, 0, 0, 2178, 2180,
		5, 760, 0, 0, 2179, 2178, 1, 0, 0, 0, 2179, 2180, 1, 0, 0, 0, 2180, 2181,
		1, 0, 0, 0, 2181, 2195, 5, 751, 0, 0, 2182, 2184, 5, 760, 0, 0, 2183, 2182,
		1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2185, 1, 0, 0, 0, 2185, 2195,
		5, 755, 0, 0, 2186, 2188, 5, 760, 0, 0, 2187, 2186, 1, 0, 0, 0, 2187, 2188,
		1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2195, 5, 754, 0, 0, 2190, 2192,
		5, 760, 0, 0, 2191, 2190, 1, 0, 0, 0, 2191, 2192, 1, 0, 0, 0, 2192, 2193,
		1, 0, 0, 0, 2193, 2195, 5, 756, 0, 0, 2194, 2155, 1, 0, 0, 0, 2194, 2159,
		1, 0, 0, 0, 2194, 2163, 1, 0, 0, 0, 2194, 2167, 1, 0, 0, 0, 2194, 2171,
		1, 0, 0, 0, 2194, 2175, 1, 0, 0, 0, 2194, 2179, 1, 0, 0, 0, 2194, 2183,
		1, 0, 0, 0, 2194, 2187, 1, 0, 0, 0, 2194, 2191, 1, 0, 0, 0, 2195, 357,
		1, 0, 0, 0, 2196, 2197, 7, 38, 0, 0, 2197, 359, 1, 0, 0, 0, 2198, 2199,
		7, 39, 0, 0, 2199, 361, 1, 0, 0, 0, 2200, 2201, 5, 167, 0, 0, 2201, 363,
		1, 0, 0, 0, 2202, 2205, 5, 750, 0, 0, 2203, 2205, 3, 358, 179, 0, 2204,
		2202, 1, 0, 0, 0, 2204, 2203, 1, 0, 0, 0, 2205, 365, 1, 0, 0, 0, 2206,
		2207, 7, 40, 0, 0, 2207, 367, 1, 0, 0, 0, 278, 373, 377, 399, 406, 410,
		414, 420, 424, 428, 431, 435, 438, 446, 449, 452, 455, 458, 489, 493, 501,
		508, 513, 517, 521, 530, 535, 539, 561, 567, 570, 573, 579, 582, 585, 588,
		591, 594, 597, 600, 603, 606, 611, 615, 626, 632, 635, 638, 651, 657, 669,
		675, 683, 696, 700, 727, 739, 757, 761, 773, 787, 791, 794, 799, 803, 806,
		808, 817, 833, 842, 848, 852, 860, 868, 879, 884, 887, 898, 901, 904, 907,
		910, 913, 916, 924, 929, 937, 941, 944, 947, 950, 953, 959, 963, 973, 979,
		983, 986, 991, 995, 998, 1005, 1011, 1016, 1023, 1026, 1044, 1046, 1049,
		1053, 1056, 1059, 1062, 1068, 1071, 1073, 1076, 1082, 1088, 1091, 1096,
		1100, 1109, 1112, 1117, 1120, 1125, 1129, 1132, 1135, 1144, 1156, 1164,
		1168, 1172, 1175, 1179, 1184, 1188, 1203, 1220, 1230, 1234, 1240, 1243,
		1249, 1257, 1264, 1271, 1292, 1299, 1301, 1313, 1318, 1322, 1326, 1335,
		1348, 1353, 1357, 1362, 1367, 1380, 1385, 1392, 1398, 1400, 1405, 1418,
		1436, 1444, 1446, 1450, 1458, 1463, 1468, 1473, 1478, 1484, 1488, 1494,
		1498, 1503, 1508, 1513, 1523, 1544, 1546, 1559, 1568, 1573, 1579, 1582,
		1591, 1594, 1608, 1621, 1637, 1640, 1649, 1658, 1667, 1678, 1681, 1701,
		1714, 1728, 1731, 1745, 1749, 1753, 1756, 1775, 1794, 1798, 1804, 1810,
		1819, 1823, 1825, 1832, 1837, 1842, 1845, 1852, 1859, 1879, 1895, 1899,
		1901, 1904, 1907, 1917, 1926, 1937, 1945, 1951, 1960, 1972, 1974, 1981,
		1988, 1994, 2000, 2002, 2010, 2017, 2020, 2027, 2031, 2037, 2040, 2047,
		2051, 2054, 2073, 2079, 2087, 2099, 2104, 2108, 2113, 2125, 2133, 2141,
		2147, 2152, 2155, 2159, 2163, 2167, 2171, 2175, 2179, 2183, 2187, 2191,
		2194, 2204,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// UniversalParserInit initializes any static state used to implement UniversalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewUniversalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func UniversalParserInit() {
	staticData := &UniversalParserParserStaticData
	staticData.once.Do(universalparserParserInit)
}

// NewUniversalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewUniversalParser(input antlr.TokenStream) *UniversalParser {
	UniversalParserInit()
	this := new(UniversalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &UniversalParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "UniversalParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

// DoubleQuotedIdentifierEnable := false;

// UniversalParser tokens.
const (
	DoubleQuotedIdentifierEnable           = false
	UniversalParserEOF                     = antlr.TokenEOF
	UniversalParserT_ADD                   = 1
	UniversalParserT_AFTER                 = 2
	UniversalParserT_ALL                   = 3
	UniversalParserT_ALTER                 = 4
	UniversalParserT_ALWAYS                = 5
	UniversalParserT_ANALYZE               = 6
	UniversalParserT_AND                   = 7
	UniversalParserT_ANTI                  = 8
	UniversalParserT_ANY                   = 9
	UniversalParserT_ANY_VALUE             = 10
	UniversalParserT_ARCHIVE               = 11
	UniversalParserT_ARRAY                 = 12
	UniversalParserT_AS                    = 13
	UniversalParserT_ASC                   = 14
	UniversalParserT_AT                    = 15
	UniversalParserT_AUTHORIZATION         = 16
	UniversalParserT_BETWEEN               = 17
	UniversalParserT_BOTH                  = 18
	UniversalParserT_BUCKET                = 19
	UniversalParserT_BUCKETS               = 20
	UniversalParserT_BY                    = 21
	UniversalParserT_CACHE                 = 22
	UniversalParserT_CASCADE               = 23
	UniversalParserT_CASE                  = 24
	UniversalParserT_CAST                  = 25
	UniversalParserT_CATALOG               = 26
	UniversalParserT_CATALOGS              = 27
	UniversalParserT_CHANGE                = 28
	UniversalParserT_CHECK                 = 29
	UniversalParserT_CLEAR                 = 30
	UniversalParserT_CLUSTER               = 31
	UniversalParserT_CLUSTERED             = 32
	UniversalParserT_CODEGEN               = 33
	UniversalParserT_COLLATE               = 34
	UniversalParserT_COLLECTION            = 35
	UniversalParserT_COLUMN                = 36
	UniversalParserT_COLUMNS               = 37
	UniversalParserT_COMMENT               = 38
	UniversalParserT_COMMIT                = 39
	UniversalParserT_COMPACT               = 40
	UniversalParserT_COMPACTIONS           = 41
	UniversalParserT_COMPUTE               = 42
	UniversalParserT_CONCATENATE           = 43
	UniversalParserT_CONSTRAINT            = 44
	UniversalParserT_COST                  = 45
	UniversalParserT_CREATE                = 46
	UniversalParserT_CROSS                 = 47
	UniversalParserT_CUBE                  = 48
	UniversalParserT_CURRENT               = 49
	UniversalParserT_CURRENT_DATE          = 50
	UniversalParserT_CURRENT_TIME          = 51
	UniversalParserT_CURRENT_TIMESTAMP     = 52
	UniversalParserT_CURRENT_USER          = 53
	UniversalParserT_DAY                   = 54
	UniversalParserT_DAYS                  = 55
	UniversalParserT_DAYOFYEAR             = 56
	UniversalParserT_DATA                  = 57
	UniversalParserT_DATABASE              = 58
	UniversalParserT_DATABASES             = 59
	UniversalParserT_DATEADD               = 60
	UniversalParserT_DATEDIFF              = 61
	UniversalParserT_DBPROPERTIES          = 62
	UniversalParserT_DEFAULT               = 63
	UniversalParserT_DEFINED               = 64
	UniversalParserT_DELETE                = 65
	UniversalParserT_DELIMITED             = 66
	UniversalParserT_DESC                  = 67
	UniversalParserT_DESCRIBE              = 68
	UniversalParserT_DFS                   = 69
	UniversalParserT_DIRECTORIES           = 70
	UniversalParserT_DIRECTORY             = 71
	UniversalParserT_DISTINCT              = 72
	UniversalParserT_DISTRIBUTE            = 73
	UniversalParserT_DIV                   = 74
	UniversalParserT_DROP                  = 75
	UniversalParserT_ELSE                  = 76
	UniversalParserT_END                   = 77
	UniversalParserT_ESCAPE                = 78
	UniversalParserT_ESCAPED               = 79
	UniversalParserT_EXCEPT                = 80
	UniversalParserT_EXCHANGE              = 81
	UniversalParserT_EXCLUDE               = 82
	UniversalParserT_EXISTS                = 83
	UniversalParserT_EXPLAIN               = 84
	UniversalParserT_EXPORT                = 85
	UniversalParserT_EXTENDED              = 86
	UniversalParserT_EXTERNAL              = 87
	UniversalParserT_EXTRACT               = 88
	UniversalParserT_FALSE                 = 89
	UniversalParserT_FETCH                 = 90
	UniversalParserT_FIELDS                = 91
	UniversalParserT_FILTER                = 92
	UniversalParserT_FILEFORMAT            = 93
	UniversalParserT_FIRST                 = 94
	UniversalParserT_FOLLOWING             = 95
	UniversalParserT_FOR                   = 96
	UniversalParserT_FOREIGN               = 97
	UniversalParserT_FORMAT                = 98
	UniversalParserT_FORMATTED             = 99
	UniversalParserT_FROM                  = 100
	UniversalParserT_FULL                  = 101
	UniversalParserT_FUNCTION              = 102
	UniversalParserT_FUNCTIONS             = 103
	UniversalParserT_GENERATED             = 104
	UniversalParserT_GLOBAL                = 105
	UniversalParserT_GRANT                 = 106
	UniversalParserT_GROUP                 = 107
	UniversalParserT_GROUPING              = 108
	UniversalParserT_HAVING                = 109
	UniversalParserT_HOUR                  = 110
	UniversalParserT_HOURS                 = 111
	UniversalParserT_IF                    = 112
	UniversalParserT_IGNORE                = 113
	UniversalParserT_IMPORT                = 114
	UniversalParserT_IN                    = 115
	UniversalParserT_INCLUDE               = 116
	UniversalParserT_INDEX                 = 117
	UniversalParserT_INDEXES               = 118
	UniversalParserT_INNER                 = 119
	UniversalParserT_INPATH                = 120
	UniversalParserT_INPUTFORMAT           = 121
	UniversalParserT_INSERT                = 122
	UniversalParserT_INTERSECT             = 123
	UniversalParserT_INTERVAL              = 124
	UniversalParserT_INTO                  = 125
	UniversalParserT_IS                    = 126
	UniversalParserT_ITEMS                 = 127
	UniversalParserT_JOIN                  = 128
	UniversalParserT_KEYS                  = 129
	UniversalParserT_LAST                  = 130
	UniversalParserT_LATERAL               = 131
	UniversalParserT_LAZY                  = 132
	UniversalParserT_LEADING               = 133
	UniversalParserT_LEFT                  = 134
	UniversalParserT_LIKE                  = 135
	UniversalParserT_ILIKE                 = 136
	UniversalParserT_LIMIT                 = 137
	UniversalParserT_LINES                 = 138
	UniversalParserT_LIST                  = 139
	UniversalParserT_LOAD                  = 140
	UniversalParserT_LOCAL                 = 141
	UniversalParserT_LOCATION              = 142
	UniversalParserT_LOCK                  = 143
	UniversalParserT_LOCKS                 = 144
	UniversalParserT_LOGICAL               = 145
	UniversalParserT_MACRO                 = 146
	UniversalParserT_MAP                   = 147
	UniversalParserT_MATCHED               = 148
	UniversalParserT_MERGE                 = 149
	UniversalParserT_MICROSECOND           = 150
	UniversalParserT_MICROSECONDS          = 151
	UniversalParserT_MILLISECOND           = 152
	UniversalParserT_MILLISECONDS          = 153
	UniversalParserT_MINUTE                = 154
	UniversalParserT_MINUTES               = 155
	UniversalParserT_MINUS                 = 156
	UniversalParserT_MONTH                 = 157
	UniversalParserT_MONTHS                = 158
	UniversalParserT_MSCK                  = 159
	UniversalParserT_NAMESPACE             = 160
	UniversalParserT_NAMESPACES            = 161
	UniversalParserT_NANOSECOND            = 162
	UniversalParserT_NANOSECONDS           = 163
	UniversalParserT_NATURAL               = 164
	UniversalParserT_NO                    = 165
	UniversalParserT_NOT                   = 166
	UniversalParserT_NULL                  = 167
	UniversalParserT_NULLS                 = 168
	UniversalParserT_OF                    = 169
	UniversalParserT_OFFSET                = 170
	UniversalParserT_ON                    = 171
	UniversalParserT_ONLY                  = 172
	UniversalParserT_OPTION                = 173
	UniversalParserT_OPTIONS               = 174
	UniversalParserT_OR                    = 175
	UniversalParserT_ORDER                 = 176
	UniversalParserT_OUT                   = 177
	UniversalParserT_OUTER                 = 178
	UniversalParserT_OUTPUTFORMAT          = 179
	UniversalParserT_OVER                  = 180
	UniversalParserT_OVERLAPS              = 181
	UniversalParserT_OVERLAY               = 182
	UniversalParserT_OVERWRITE             = 183
	UniversalParserT_PARTITION             = 184
	UniversalParserT_PARTITIONED           = 185
	UniversalParserT_PARTITIONS            = 186
	UniversalParserT_PERCENTILE_CONT       = 187
	UniversalParserT_PERCENTILE_DISC       = 188
	UniversalParserT_PERCENTLIT            = 189
	UniversalParserT_PIVOT                 = 190
	UniversalParserT_PLACING               = 191
	UniversalParserT_POSITION              = 192
	UniversalParserT_PRECEDING             = 193
	UniversalParserT_PRIMARY               = 194
	UniversalParserT_PRINCIPALS            = 195
	UniversalParserT_PROPERTIES            = 196
	UniversalParserT_PURGE                 = 197
	UniversalParserT_QUARTER               = 198
	UniversalParserT_QUERY                 = 199
	UniversalParserT_RANGE                 = 200
	UniversalParserT_RECORDREADER          = 201
	UniversalParserT_RECORDWRITER          = 202
	UniversalParserT_RECOVER               = 203
	UniversalParserT_REDUCE                = 204
	UniversalParserT_REFERENCES            = 205
	UniversalParserT_REFRESH               = 206
	UniversalParserT_RENAME                = 207
	UniversalParserT_REPAIR                = 208
	UniversalParserT_REPEATABLE            = 209
	UniversalParserT_REPLACE               = 210
	UniversalParserT_RESET                 = 211
	UniversalParserT_RESPECT               = 212
	UniversalParserT_RESTRICT              = 213
	UniversalParserT_REVOKE                = 214
	UniversalParserT_RIGHT                 = 215
	UniversalParserT_RLIKE                 = 216
	UniversalParserT_ROLE                  = 217
	UniversalParserT_ROLES                 = 218
	UniversalParserT_ROLLBACK              = 219
	UniversalParserT_ROLLUP                = 220
	UniversalParserT_ROW                   = 221
	UniversalParserT_ROWS                  = 222
	UniversalParserT_SECOND                = 223
	UniversalParserT_SECONDS               = 224
	UniversalParserT_SCHEMA                = 225
	UniversalParserT_SCHEMAS               = 226
	UniversalParserT_SELECT                = 227
	UniversalParserT_SEMI                  = 228
	UniversalParserT_SEPARATED             = 229
	UniversalParserT_SERDE                 = 230
	UniversalParserT_SERDEPROPERTIES       = 231
	UniversalParserT_SESSION_USER          = 232
	UniversalParserT_SET                   = 233
	UniversalParserT_SETMINUS              = 234
	UniversalParserT_SETS                  = 235
	UniversalParserT_SHOW                  = 236
	UniversalParserT_SKEWED                = 237
	UniversalParserT_SOME                  = 238
	UniversalParserT_SORT                  = 239
	UniversalParserT_SORTED                = 240
	UniversalParserT_SOURCE                = 241
	UniversalParserT_START                 = 242
	UniversalParserT_STATISTICS            = 243
	UniversalParserT_STORED                = 244
	UniversalParserT_STRATIFY              = 245
	UniversalParserT_STRUCT                = 246
	UniversalParserT_SUBSTR                = 247
	UniversalParserT_SUBSTRING             = 248
	UniversalParserT_SYNC                  = 249
	UniversalParserT_SYSTEM_TIME           = 250
	UniversalParserT_SYSTEM_VERSION        = 251
	UniversalParserT_TABLE                 = 252
	UniversalParserT_TABLES                = 253
	UniversalParserT_TABLESAMPLE           = 254
	UniversalParserT_TARGET                = 255
	UniversalParserT_TBLPROPERTIES         = 256
	UniversalParserT_TEMPORARY             = 257
	UniversalParserT_TERMINATED            = 258
	UniversalParserT_THEN                  = 259
	UniversalParserT_TIME                  = 260
	UniversalParserT_TIMESTAMP             = 261
	UniversalParserT_TIMESTAMPADD          = 262
	UniversalParserT_TIMESTAMPDIFF         = 263
	UniversalParserT_TO                    = 264
	UniversalParserT_TOUCH                 = 265
	UniversalParserT_TRAILING              = 266
	UniversalParserT_TRANSACTION           = 267
	UniversalParserT_TRANSACTIONS          = 268
	UniversalParserT_TRANSFORM             = 269
	UniversalParserT_TRIM                  = 270
	UniversalParserT_TRUE                  = 271
	UniversalParserT_TRUNCATE              = 272
	UniversalParserT_TRY_CAST              = 273
	UniversalParserT_TYPE                  = 274
	UniversalParserT_UNARCHIVE             = 275
	UniversalParserT_UNBOUNDED             = 276
	UniversalParserT_UNCACHE               = 277
	UniversalParserT_UNION                 = 278
	UniversalParserT_UNIQUE                = 279
	UniversalParserT_UNKNOWN               = 280
	UniversalParserT_UNLOCK                = 281
	UniversalParserT_UNPIVOT               = 282
	UniversalParserT_UNSET                 = 283
	UniversalParserT_UPDATE                = 284
	UniversalParserT_USE                   = 285
	UniversalParserT_USER                  = 286
	UniversalParserT_USING                 = 287
	UniversalParserT_VALUES                = 288
	UniversalParserT_VERSION               = 289
	UniversalParserT_VIEW                  = 290
	UniversalParserT_VIEWS                 = 291
	UniversalParserT_WEEK                  = 292
	UniversalParserT_WEEKS                 = 293
	UniversalParserT_WHEN                  = 294
	UniversalParserT_WHERE                 = 295
	UniversalParserT_WINDOW                = 296
	UniversalParserT_WITH                  = 297
	UniversalParserT_WITHIN                = 298
	UniversalParserT_YEAR                  = 299
	UniversalParserT_YEARS                 = 300
	UniversalParserT_ZONE                  = 301
	UniversalParserT_ACTION                = 302
	UniversalParserT_ADD2                  = 303
	UniversalParserT_ALLOCATE              = 304
	UniversalParserT_ANSI_NULLS            = 305
	UniversalParserT_ANSI_PADDING          = 306
	UniversalParserT_ASSOCIATE             = 307
	UniversalParserT_AUTO_INCREMENT        = 308
	UniversalParserT_AVG                   = 309
	UniversalParserT_BATCHSIZE             = 310
	UniversalParserT_BEGIN                 = 311
	UniversalParserT_BIGINT                = 312
	UniversalParserT_BINARY_DOUBLE         = 313
	UniversalParserT_BINARY_FLOAT          = 314
	UniversalParserT_BINARY_INTEGER        = 315
	UniversalParserT_BIT                   = 316
	UniversalParserT_BODY                  = 317
	UniversalParserT_BREAK                 = 318
	UniversalParserT_BULK                  = 319
	UniversalParserT_BYTE                  = 320
	UniversalParserT_CALL                  = 321
	UniversalParserT_CALLER                = 322
	UniversalParserT_CASESPECIFIC          = 323
	UniversalParserT_CHAR                  = 324
	UniversalParserT_CHARACTER             = 325
	UniversalParserT_CHARSET               = 326
	UniversalParserT_CLIENT                = 327
	UniversalParserT_CLOSE                 = 328
	UniversalParserT_CMP                   = 329
	UniversalParserT_COLLECT               = 330
	UniversalParserT_CONSTANT              = 331
	UniversalParserT_COMPRESS              = 332
	UniversalParserT_CONCAT                = 333
	UniversalParserT_CONDITION             = 334
	UniversalParserT_CONTINUE              = 335
	UniversalParserT_COPY                  = 336
	UniversalParserT_COUNT                 = 337
	UniversalParserT_COUNT_BIG             = 338
	UniversalParserT_CREATION              = 339
	UniversalParserT_CREATOR               = 340
	UniversalParserT_CS                    = 341
	UniversalParserT_CURRENT_SCHEMA        = 342
	UniversalParserT_CURSOR                = 343
	UniversalParserT_DATE                  = 344
	UniversalParserT_DATETIME              = 345
	UniversalParserT_DEC                   = 346
	UniversalParserT_DECIMAL               = 347
	UniversalParserT_DECLARE               = 348
	UniversalParserT_DEFERRED              = 349
	UniversalParserT_DEFINER               = 350
	UniversalParserT_DEFINITION            = 351
	UniversalParserT_DELIMITER             = 352
	UniversalParserT_DIAGNOSTICS           = 353
	UniversalParserT_DIR                   = 354
	UniversalParserT_DO                    = 355
	UniversalParserT_DOUBLE                = 356
	UniversalParserT_DYNAMIC               = 357
	UniversalParserT_ELSEIF                = 358
	UniversalParserT_ELSIF                 = 359
	UniversalParserT_ENABLE                = 360
	UniversalParserT_ENGINE                = 361
	UniversalParserT_EXEC                  = 362
	UniversalParserT_EXECUTE               = 363
	UniversalParserT_EXCEPTION             = 364
	UniversalParserT_EXCLUSIVE             = 365
	UniversalParserT_EXIT                  = 366
	UniversalParserT_FALLBACK              = 367
	UniversalParserT_FILE                  = 368
	UniversalParserT_FILES                 = 369
	UniversalParserT_FLOAT                 = 370
	UniversalParserT_FOUND                 = 371
	UniversalParserT_GET                   = 372
	UniversalParserT_GO                    = 373
	UniversalParserT_HANDLER               = 374
	UniversalParserT_HASH                  = 375
	UniversalParserT_HDFS                  = 376
	UniversalParserT_HIVE                  = 377
	UniversalParserT_HOST                  = 378
	UniversalParserT_IDENTITY              = 379
	UniversalParserT_IMMEDIATE             = 380
	UniversalParserT_INITRANS              = 381
	UniversalParserT_INOUT                 = 382
	UniversalParserT_INT                   = 383
	UniversalParserT_INT2                  = 384
	UniversalParserT_INT4                  = 385
	UniversalParserT_INT8                  = 386
	UniversalParserT_INTEGER               = 387
	UniversalParserT_INVOKER               = 388
	UniversalParserT_ISOPEN                = 389
	UniversalParserT_KEEP                  = 390
	UniversalParserT_KEY                   = 391
	UniversalParserT_LANGUAGE              = 392
	UniversalParserT_LEAVE                 = 393
	UniversalParserT_LOCATOR               = 394
	UniversalParserT_LOCATORS              = 395
	UniversalParserT_LOG                   = 396
	UniversalParserT_LOGGED                = 397
	UniversalParserT_LOGGING               = 398
	UniversalParserT_LOOP                  = 399
	UniversalParserT_MAX                   = 400
	UniversalParserT_MAXTRANS              = 401
	UniversalParserT_MESSAGE_TEXT          = 402
	UniversalParserT_MIN                   = 403
	UniversalParserT_MULTISET              = 404
	UniversalParserT_NCHAR                 = 405
	UniversalParserT_NEW                   = 406
	UniversalParserT_NVARCHAR              = 407
	UniversalParserT_NOCOUNT               = 408
	UniversalParserT_NOCOMPRESS            = 409
	UniversalParserT_NOLOGGING             = 410
	UniversalParserT_NONE                  = 411
	UniversalParserT_NOTFOUND              = 412
	UniversalParserT_NUMERIC               = 413
	UniversalParserT_NUMBER                = 414
	UniversalParserT_OBJECT                = 415
	UniversalParserT_OFF                   = 416
	UniversalParserT_OPEN                  = 417
	UniversalParserT_OWNER                 = 418
	UniversalParserT_PACKAGE               = 419
	UniversalParserT_PCTFREE               = 420
	UniversalParserT_PCTUSED               = 421
	UniversalParserT_PLS_INTEGER           = 422
	UniversalParserT_PRECISION             = 423
	UniversalParserT_PRESERVE              = 424
	UniversalParserT_PRINT                 = 425
	UniversalParserT_PROC                  = 426
	UniversalParserT_PROCEDURE             = 427
	UniversalParserT_QUALIFY               = 428
	UniversalParserT_QUERY_BAND            = 429
	UniversalParserT_QUIT                  = 430
	UniversalParserT_QUOTED_IDENTIFIER     = 431
	UniversalParserT_RAISE                 = 432
	UniversalParserT_REAL                  = 433
	UniversalParserT_REGEXP                = 434
	UniversalParserT_RESIGNAL              = 435
	UniversalParserT_RESULT                = 436
	UniversalParserT_RESULT_SET_LOCATOR    = 437
	UniversalParserT_RETURN                = 438
	UniversalParserT_RETURNS               = 439
	UniversalParserT_REVERSE               = 440
	UniversalParserT_ROWTYPE               = 441
	UniversalParserT_ROW_COUNT             = 442
	UniversalParserT_RR                    = 443
	UniversalParserT_RS                    = 444
	UniversalParserT_PWD                   = 445
	UniversalParserT_SECURITY              = 446
	UniversalParserT_SEGMENT               = 447
	UniversalParserT_SEL                   = 448
	UniversalParserT_SESSION               = 449
	UniversalParserT_SESSIONS              = 450
	UniversalParserT_SHARE                 = 451
	UniversalParserT_SIGNAL                = 452
	UniversalParserT_SIMPLE_DOUBLE         = 453
	UniversalParserT_SIMPLE_FLOAT          = 454
	UniversalParserT_SIMPLE_INTEGER        = 455
	UniversalParserT_SMALLDATETIME         = 456
	UniversalParserT_SMALLINT              = 457
	UniversalParserT_SQL                   = 458
	UniversalParserT_SQLEXCEPTION          = 459
	UniversalParserT_SQLINSERT             = 460
	UniversalParserT_SQLSTATE              = 461
	UniversalParserT_SQLWARNING            = 462
	UniversalParserT_STATS                 = 463
	UniversalParserT_STEP                  = 464
	UniversalParserT_STORAGE               = 465
	UniversalParserT_STRING                = 466
	UniversalParserT_SUBDIR                = 467
	UniversalParserT_SUM                   = 468
	UniversalParserT_SUMMARY               = 469
	UniversalParserT_SYS_REFCURSOR         = 470
	UniversalParserT_TABLESPACE            = 471
	UniversalParserT_TEXTIMAGE_ON          = 472
	UniversalParserT_TINYINT               = 473
	UniversalParserT_TITLE                 = 474
	UniversalParserT_TOP                   = 475
	UniversalParserT_UR                    = 476
	UniversalParserT_VALUE                 = 477
	UniversalParserT_VAR                   = 478
	UniversalParserT_VARCHAR               = 479
	UniversalParserT_VARCHAR2              = 480
	UniversalParserT_VARYING               = 481
	UniversalParserT_VOLATILE              = 482
	UniversalParserT_WHILE                 = 483
	UniversalParserT_WITHOUT               = 484
	UniversalParserT_WORK                  = 485
	UniversalParserT_XACT_ABORT            = 486
	UniversalParserT_XML                   = 487
	UniversalParserT_YES                   = 488
	UniversalParserT_ACTIVITY_COUNT        = 489
	UniversalParserT_CUME_DIST             = 490
	UniversalParserT_DENSE_RANK            = 491
	UniversalParserT_FIRST_VALUE           = 492
	UniversalParserT_LAG                   = 493
	UniversalParserT_LAST_VALUE            = 494
	UniversalParserT_LEAD                  = 495
	UniversalParserT_MAX_PART_STRING       = 496
	UniversalParserT_MIN_PART_STRING       = 497
	UniversalParserT_MAX_PART_INT          = 498
	UniversalParserT_MIN_PART_INT          = 499
	UniversalParserT_MAX_PART_DATE         = 500
	UniversalParserT_MIN_PART_DATE         = 501
	UniversalParserT_PART_COUNT            = 502
	UniversalParserT_PART_LOC              = 503
	UniversalParserT_RANK                  = 504
	UniversalParserT_ROW_NUMBER            = 505
	UniversalParserT_STDEV                 = 506
	UniversalParserT_SYSDATE               = 507
	UniversalParserT_VARIANCE              = 508
	UniversalParserT_ABS                   = 509
	UniversalParserT_ACOS                  = 510
	UniversalParserT_ADD_MONTHS            = 511
	UniversalParserT_ALL_MATCH             = 512
	UniversalParserT_ANY_MATCH             = 513
	UniversalParserT_ATAN2                 = 514
	UniversalParserT_APPROX_DISTINCT       = 515
	UniversalParserT_ARG_MAX               = 516
	UniversalParserT_ARG_MIN               = 517
	UniversalParserT_ARRAY_CONTAINS        = 518
	UniversalParserT_ARRAY_DISTINCT        = 519
	UniversalParserT_ARRAY_EXCEPT          = 520
	UniversalParserT_ARRAY_INTERSECT       = 521
	UniversalParserT_ARRAY_JOIN            = 522
	UniversalParserT_ARRAY_MAX             = 523
	UniversalParserT_ARRAY_MIN             = 524
	UniversalParserT_ARRAY_NORMALIZE       = 525
	UniversalParserT_ARRAY_POSITION        = 526
	UniversalParserT_ARRAY_REDUCE          = 527
	UniversalParserT_ARRAY_REMOVE          = 528
	UniversalParserT_ARRAY_REPEAT          = 529
	UniversalParserT_ARRAY_SORT            = 530
	UniversalParserT_ARRAY_UNION           = 531
	UniversalParserT_ARRAYS_OVERLAP        = 532
	UniversalParserT_ARRAYS_ZIP            = 533
	UniversalParserT_ASCII                 = 534
	UniversalParserT_ASIN                  = 535
	UniversalParserT_ATAN                  = 536
	UniversalParserT_BASE64                = 537
	UniversalParserT_BIN                   = 538
	UniversalParserT_BITWISE_AND_AGG       = 539
	UniversalParserT_BITWISE_OR_AGG        = 540
	UniversalParserT_CBRT                  = 541
	UniversalParserT_CEIL                  = 542
	UniversalParserT_CHAR_MATCHCOUNT       = 543
	UniversalParserT_CHR                   = 544
	UniversalParserT_CLUSTER_SAMPLE        = 545
	UniversalParserT_COALESCE              = 546
	UniversalParserT_COLLECT_LIST          = 547
	UniversalParserT_COLLECT_SET           = 548
	UniversalParserT_COMBINATIONS          = 549
	UniversalParserT_CONCAT_WS             = 550
	UniversalParserT_CONV                  = 551
	UniversalParserT_CORR                  = 552
	UniversalParserT_COS                   = 553
	UniversalParserT_COSH                  = 554
	UniversalParserT_COT                   = 555
	UniversalParserT_COUNT_IF              = 556
	UniversalParserT_COVAR_POP             = 557
	UniversalParserT_COVAR_SAMP            = 558
	UniversalParserT_CRC32                 = 559
	UniversalParserT_CURRENT_TIMEZONE      = 560
	UniversalParserT_DATE_ADD              = 561
	UniversalParserT_DATE_FORMAT           = 562
	UniversalParserT_DATE_SUB              = 563
	UniversalParserT_DATEPART              = 564
	UniversalParserT_DATETRUNC             = 565
	UniversalParserT_DAYOFMONTH            = 566
	UniversalParserT_DAYOFWEEK             = 567
	UniversalParserT_DECODE                = 568
	UniversalParserT_DECOMPRESS            = 569
	UniversalParserT_DEGREES               = 570
	UniversalParserT_E                     = 571
	UniversalParserT_ENCODE                = 572
	UniversalParserT_EXP                   = 573
	UniversalParserT_EXPLODE               = 574
	UniversalParserT_FACTORIAL             = 575
	UniversalParserT_FIELD                 = 576
	UniversalParserT_FIND_IN_SET           = 577
	UniversalParserT_FLATTEN               = 578
	UniversalParserT_FLOOR                 = 579
	UniversalParserT_FORMAT_NUMBER         = 580
	UniversalParserT_FROM_JSON             = 581
	UniversalParserT_FROM_UNIXTIME         = 582
	UniversalParserT_FROM_UTC_TIMESTAMP    = 583
	UniversalParserT_GET_IDCARD_AGE        = 584
	UniversalParserT_GET_IDCARD_BIRTHDAY   = 585
	UniversalParserT_GET_IDCARD_SEX        = 586
	UniversalParserT_GET_JSON_OBJECT       = 587
	UniversalParserT_GET_USER_ID           = 588
	UniversalParserT_GETDATE               = 589
	UniversalParserT_GREATEST              = 590
	UniversalParserT_HEX                   = 591
	UniversalParserT_HISTOGRAM             = 592
	UniversalParserT_INLINE                = 593
	UniversalParserT_INITCAP               = 594
	UniversalParserT_INSTR                 = 595
	UniversalParserT_IS_ENCODING           = 596
	UniversalParserT_ISDATE                = 597
	UniversalParserT_ISNAN                 = 598
	UniversalParserT_JSON_OBJECT           = 599
	UniversalParserT_JSON_ARRAY            = 600
	UniversalParserT_JSON_EXTRACT          = 601
	UniversalParserT_JSON_EXISTS           = 602
	UniversalParserT_JSON_PRETTY           = 603
	UniversalParserT_JSON_TYPE             = 604
	UniversalParserT_JSON_FORMAT           = 605
	UniversalParserT_JSON_PARSE            = 606
	UniversalParserT_JSON_VALID            = 607
	UniversalParserT_JSON_TUPLE            = 608
	UniversalParserT_KEYVALUE              = 609
	UniversalParserT_KEYVALUE_TUPLE        = 610
	UniversalParserT_LAST_DAY              = 611
	UniversalParserT_LASTDAY               = 612
	UniversalParserT_LEAST                 = 613
	UniversalParserT_LENGTH                = 614
	UniversalParserT_LENGTHB               = 615
	UniversalParserT_LN                    = 616
	UniversalParserT_LOCATE                = 617
	UniversalParserT_LOG10                 = 618
	UniversalParserT_LOG2                  = 619
	UniversalParserT_LPAD                  = 620
	UniversalParserT_LTRIM                 = 621
	UniversalParserT_MAP_AGG               = 622
	UniversalParserT_MAP_CONCAT            = 623
	UniversalParserT_MAP_ENTRIES           = 624
	UniversalParserT_MAP_FILTER            = 625
	UniversalParserT_MAP_FROM_ARRAYS       = 626
	UniversalParserT_MAP_FROM_ENTRIES      = 627
	UniversalParserT_MAP_KEYS              = 628
	UniversalParserT_MAP_UNION             = 629
	UniversalParserT_MAP_UNION_SUM         = 630
	UniversalParserT_MAP_VALUES            = 631
	UniversalParserT_MAP_ZIP_WITH          = 632
	UniversalParserT_MASK_HASH             = 633
	UniversalParserT_MAX_BY                = 634
	UniversalParserT_MAX_PT                = 635
	UniversalParserT_MD5                   = 636
	UniversalParserT_MEDIAN                = 637
	UniversalParserT_MIN_BY                = 638
	UniversalParserT_MONTHS_BETWEEN        = 639
	UniversalParserT_MULTIMAP_AGG          = 640
	UniversalParserT_MULTIMAP_FROM_ENTRIES = 641
	UniversalParserT_NAMED_STRUCT          = 642
	UniversalParserT_NEGATIVE              = 643
	UniversalParserT_NEXT_DAY              = 644
	UniversalParserT_NGRAMS                = 645
	UniversalParserT_NOW                   = 646
	UniversalParserT_NTILE                 = 647
	UniversalParserT_NTH_VALUE             = 648
	UniversalParserT_NULLIF                = 649
	UniversalParserT_NUMERIC_HISTOGRAM     = 650
	UniversalParserT_NVL                   = 651
	UniversalParserT_ORDINAL               = 652
	UniversalParserT_PARSE_URL             = 653
	UniversalParserT_PARSE_URL_TUPLE       = 654
	UniversalParserT_PARTITION_EXISTS      = 655
	UniversalParserT_PERCENT_RANK          = 656
	UniversalParserT_PERCENTILE            = 657
	UniversalParserT_PERCENTILE_APPROX     = 658
	UniversalParserT_PI                    = 659
	UniversalParserT_POSEXPLODE            = 660
	UniversalParserT_POSITIVE              = 661
	UniversalParserT_POW                   = 662
	UniversalParserT_RADIANS               = 663
	UniversalParserT_RAND                  = 664
	UniversalParserT_REGEXP_COUNT          = 665
	UniversalParserT_REGEXP_EXTRACT        = 666
	UniversalParserT_REGEXP_EXTRACT_ALL    = 667
	UniversalParserT_REGEXP_INSTR          = 668
	UniversalParserT_REGEXP_REPLACE        = 669
	UniversalParserT_REGEXP_SUBSTR         = 670
	UniversalParserT_REPEAT                = 671
	UniversalParserT_ROUND                 = 672
	UniversalParserT_RPAD                  = 673
	UniversalParserT_RTRIM                 = 674
	UniversalParserT_SAMPLE                = 675
	UniversalParserT_SEQUENCE              = 676
	UniversalParserT_SHA                   = 677
	UniversalParserT_SHA1                  = 678
	UniversalParserT_SHA2                  = 679
	UniversalParserT_SHIFTLEFT             = 680
	UniversalParserT_SHIFTRIGHT            = 681
	UniversalParserT_SHIFTRIGHTUNSIGNED    = 682
	UniversalParserT_SHUFFLE               = 683
	UniversalParserT_SIGN                  = 684
	UniversalParserT_SIN                   = 685
	UniversalParserT_SINH                  = 686
	UniversalParserT_SIZE                  = 687
	UniversalParserT_SLICE                 = 688
	UniversalParserT_SORT_ARRAY            = 689
	UniversalParserT_SOUNDEX               = 690
	UniversalParserT_SPACE                 = 691
	UniversalParserT_SPLIT                 = 692
	UniversalParserT_SPLIT_PART            = 693
	UniversalParserT_SQRT                  = 694
	UniversalParserT_STACK                 = 695
	UniversalParserT_STDDEV                = 696
	UniversalParserT_STDDEV_SAMP           = 697
	UniversalParserT_STR_TO_MAP            = 698
	UniversalParserT_SUBSTRING_INDEX       = 699
	UniversalParserT_SYM_DECRYPT           = 700
	UniversalParserT_SYM_ENCRYPT           = 701
	UniversalParserT_TABLE_EXISTS          = 702
	UniversalParserT_TAN                   = 703
	UniversalParserT_TANH                  = 704
	UniversalParserT_TO_CHAR               = 705
	UniversalParserT_TO_DATE               = 706
	UniversalParserT_TO_JSON               = 707
	UniversalParserT_TO_MILLIS             = 708
	UniversalParserT_TOLOWER               = 709
	UniversalParserT_TOUPPER               = 710
	UniversalParserT_TRANS_ARRAY           = 711
	UniversalParserT_TRANS_COLS            = 712
	UniversalParserT_TRANSFORM_KEYS        = 713
	UniversalParserT_TRANSFORM_VALUES      = 714
	UniversalParserT_TRANSLATE             = 715
	UniversalParserT_TRUNC                 = 716
	UniversalParserT_UNBASE64              = 717
	UniversalParserT_UNHEX                 = 718
	UniversalParserT_UNIQUE_ID             = 719
	UniversalParserT_UNIX_TIMESTAMP        = 720
	UniversalParserT_URL_DECODE            = 721
	UniversalParserT_URL_ENCODE            = 722
	UniversalParserT_UUID                  = 723
	UniversalParserT_VAR_SAMP              = 724
	UniversalParserT_VAR_POP               = 725
	UniversalParserT_WEEKDAY               = 726
	UniversalParserT_WEEKOFYEAR            = 727
	UniversalParserT_WIDTH_BUCKET          = 728
	UniversalParserT_WM_CONCAT             = 729
	UniversalParserT_ZIP_WITH              = 730
	UniversalParserT_SEQUENCEFILE          = 731
	UniversalParserT_TEXTFILE              = 732
	UniversalParserT_RCFILE                = 733
	UniversalParserT_ORC                   = 734
	UniversalParserT_PARQUET               = 735
	UniversalParserT_AVRO                  = 736
	UniversalParserT_JSONFILE              = 737
	UniversalParserT_TRANSACTIONAL         = 738
	UniversalParserT_LIFECYCLE             = 739
	UniversalParserT_MATERIALIZED          = 740
	UniversalParserT_CHANGEOWNER           = 741
	UniversalParserT_BUILD                 = 742
	UniversalParserT_DISABLE               = 743
	UniversalParserT_REWRITE               = 744
	UniversalParserT_REBUILD               = 745
	UniversalParserSINGLE_QUOTED_STRING    = 746
	UniversalParserDOUBLE_QUOTED_STRING    = 747
	UniversalParserBIGINT_VALUE            = 748
	UniversalParserSMALLINT_VALUE          = 749
	UniversalParserINTEGER_VALUE           = 750
	UniversalParserTINYINT_VALUE           = 751
	UniversalParserEXPONENT_VALUE          = 752
	UniversalParserDECIMAL_VALUE           = 753
	UniversalParserFLOAT_VALUE             = 754
	UniversalParserDOUBLE_VALUE            = 755
	UniversalParserBIGDECIMAL_VALUE        = 756
	UniversalParserIDENTIFIER              = 757
	UniversalParserBACKQUOTED_IDENTIFIER   = 758
	UniversalParserK_ADD                   = 759
	UniversalParserK_MINUS                 = 760
	UniversalParserK_MULTIPLY              = 761
	UniversalParserK_DIVIDE                = 762
	UniversalParserK_PERCENT               = 763
	UniversalParserK_TILDE                 = 764
	UniversalParserK_COLON                 = 765
	UniversalParserK_COMMA                 = 766
	UniversalParserK_SEMICOLON             = 767
	UniversalParserK_EXCLAMATION           = 768
	UniversalParserK_HAT                   = 769
	UniversalParserK_PIPE                  = 770
	UniversalParserK_CONCAT_PIPE           = 771
	UniversalParserK_AMPERSAND             = 772
	UniversalParserK_DOT                   = 773
	UniversalParserK_EQ                    = 774
	UniversalParserK_EQ2                   = 775
	UniversalParserK_NEQ                   = 776
	UniversalParserK_NEQJ                  = 777
	UniversalParserK_GT                    = 778
	UniversalParserK_GTE                   = 779
	UniversalParserK_GTEJ                  = 780
	UniversalParserK_LT                    = 781
	UniversalParserK_LTE                   = 782
	UniversalParserK_LTEJ                  = 783
	UniversalParserK_NSEQ                  = 784
	UniversalParserK_ARROW                 = 785
	UniversalParserK_HINT_START            = 786
	UniversalParserK_HINT_END              = 787
	UniversalParserK_OPEN_PAREN            = 788
	UniversalParserK_OPEN_BRACKET          = 789
	UniversalParserK_CLOSE_PAREN           = 790
	UniversalParserK_CLOSE_BRACKET         = 791
	UniversalParserMULTI_LINE_COMMENT      = 792
	UniversalParserLINE_COMMENT            = 793
	UniversalParserWHITE_SPACE             = 794
	UniversalParserUNMATCH                 = 795
)

// UniversalParser rules.
const (
	UniversalParserRULE_statements                               = 0
	UniversalParserRULE_statement                                = 1
	UniversalParserRULE_setStatement                             = 2
	UniversalParserRULE_viewTableAndView                         = 3
	UniversalParserRULE_createMaterializedViewStatement          = 4
	UniversalParserRULE_updateMaterializedViewStatement          = 5
	UniversalParserRULE_setMaterializedViewLifecycleStatement    = 6
	UniversalParserRULE_updateMaterializedViewLifecycleStatement = 7
	UniversalParserRULE_dropMaterializedViewStatement            = 8
	UniversalParserRULE_dropMaterializedViewPartitionStatement   = 9
	UniversalParserRULE_createViewStatement                      = 10
	UniversalParserRULE_viewColumns                              = 11
	UniversalParserRULE_renameViewStatement                      = 12
	UniversalParserRULE_changeViewStatement                      = 13
	UniversalParserRULE_dropViewStatement                        = 14
	UniversalParserRULE_createTableStatement                     = 15
	UniversalParserRULE_dropTableStatement                       = 16
	UniversalParserRULE_createTableBodyspec                      = 17
	UniversalParserRULE_createTableItems                         = 18
	UniversalParserRULE_createTableItem                          = 19
	UniversalParserRULE_tablePartitionSpec                       = 20
	UniversalParserRULE_partitionItems                           = 21
	UniversalParserRULE_partitionItem                            = 22
	UniversalParserRULE_sortSpec                                 = 23
	UniversalParserRULE_skewedBySpec                             = 24
	UniversalParserRULE_skewedByColumns                          = 25
	UniversalParserRULE_skewedByValues                           = 26
	UniversalParserRULE_multiSkewedValue                         = 27
	UniversalParserRULE_simpleValue                              = 28
	UniversalParserRULE_storageDirectories                       = 29
	UniversalParserRULE_formatSpec                               = 30
	UniversalParserRULE_tableRowFormat                           = 31
	UniversalParserRULE_storedBy                                 = 32
	UniversalParserRULE_serdeProperties                          = 33
	UniversalParserRULE_storedSpec                               = 34
	UniversalParserRULE_formatType                               = 35
	UniversalParserRULE_propertiesSpec                           = 36
	UniversalParserRULE_tableSelectSpec                          = 37
	UniversalParserRULE_lifecycleSpec                            = 38
	UniversalParserRULE_insertQueryStatement                     = 39
	UniversalParserRULE_insertValueStatement                     = 40
	UniversalParserRULE_dropTablePartitions                      = 41
	UniversalParserRULE_addTablePartitions                       = 42
	UniversalParserRULE_renameTablePartitions                    = 43
	UniversalParserRULE_insertInto                               = 44
	UniversalParserRULE_insertValues                             = 45
	UniversalParserRULE_insertTableColumns                       = 46
	UniversalParserRULE_partitionSpec                            = 47
	UniversalParserRULE_partitionVal                             = 48
	UniversalParserRULE_ifOption                                 = 49
	UniversalParserRULE_replaceOption                            = 50
	UniversalParserRULE_nullOption                               = 51
	UniversalParserRULE_defaultOption                            = 52
	UniversalParserRULE_query                                    = 53
	UniversalParserRULE_cte                                      = 54
	UniversalParserRULE_namedQuery                               = 55
	UniversalParserRULE_columnAliases                            = 56
	UniversalParserRULE_queryOrganization                        = 57
	UniversalParserRULE_queryTerm                                = 58
	UniversalParserRULE_queryPrimary                             = 59
	UniversalParserRULE_querySpecification                       = 60
	UniversalParserRULE_selectClause                             = 61
	UniversalParserRULE_fromClause                               = 62
	UniversalParserRULE_inlineTable                              = 63
	UniversalParserRULE_functionTable                            = 64
	UniversalParserRULE_temporalClause                           = 65
	UniversalParserRULE_sample                                   = 66
	UniversalParserRULE_sampleMethod                             = 67
	UniversalParserRULE_relationPrimary                          = 68
	UniversalParserRULE_relation                                 = 69
	UniversalParserRULE_relationExtension                        = 70
	UniversalParserRULE_joinRelation                             = 71
	UniversalParserRULE_joinCondtion                             = 72
	UniversalParserRULE_joinType                                 = 73
	UniversalParserRULE_pivotClause                              = 74
	UniversalParserRULE_pivotAggregateItem                       = 75
	UniversalParserRULE_pivotColumn                              = 76
	UniversalParserRULE_pivotValue                               = 77
	UniversalParserRULE_unpivotClause                            = 78
	UniversalParserRULE_unpivotOption                            = 79
	UniversalParserRULE_unpivotSingleValueColumn                 = 80
	UniversalParserRULE_unpivotMultiValueColumn                  = 81
	UniversalParserRULE_unpivotNameColumn                        = 82
	UniversalParserRULE_unpivotColumnItem                        = 83
	UniversalParserRULE_unpivotMultiColumnItem                   = 84
	UniversalParserRULE_unpivotColumnAlias                       = 85
	UniversalParserRULE_unpivotColumnAliasOption                 = 86
	UniversalParserRULE_unpivotColumnAliasValueList              = 87
	UniversalParserRULE_unpivotColumnAliasValue                  = 88
	UniversalParserRULE_unpivotColumn                            = 89
	UniversalParserRULE_lateralView                              = 90
	UniversalParserRULE_whereClause                              = 91
	UniversalParserRULE_havingClause                             = 92
	UniversalParserRULE_aggregationClause                        = 93
	UniversalParserRULE_groupOption                              = 94
	UniversalParserRULE_groupByClause                            = 95
	UniversalParserRULE_groupingElement                          = 96
	UniversalParserRULE_groupingAnalytics                        = 97
	UniversalParserRULE_groupingSet                              = 98
	UniversalParserRULE_hint                                     = 99
	UniversalParserRULE_hintStatement                            = 100
	UniversalParserRULE_namedExpressionSeq                       = 101
	UniversalParserRULE_namedExpression                          = 102
	UniversalParserRULE_allQueryColumns                          = 103
	UniversalParserRULE_expressionSeqs                           = 104
	UniversalParserRULE_expressionSeq                            = 105
	UniversalParserRULE_expression                               = 106
	UniversalParserRULE_booleanExpression                        = 107
	UniversalParserRULE_predicate                                = 108
	UniversalParserRULE_valueExpression                          = 109
	UniversalParserRULE_defaultExpression                        = 110
	UniversalParserRULE_caseExpress                              = 111
	UniversalParserRULE_searchedCase                             = 112
	UniversalParserRULE_simpleCase                               = 113
	UniversalParserRULE_whenClause                               = 114
	UniversalParserRULE_elseClause                               = 115
	UniversalParserRULE_function                                 = 116
	UniversalParserRULE_specFunction                             = 117
	UniversalParserRULE_castFunction                             = 118
	UniversalParserRULE_structFunction                           = 119
	UniversalParserRULE_firstFunction                            = 120
	UniversalParserRULE_anyValueFunction                         = 121
	UniversalParserRULE_lastFunction                             = 122
	UniversalParserRULE_subQueryExpress                          = 123
	UniversalParserRULE_trimFunction                             = 124
	UniversalParserRULE_extractFunction                          = 125
	UniversalParserRULE_substringFunction                        = 126
	UniversalParserRULE_overlayFunction                          = 127
	UniversalParserRULE_percentileFunction                       = 128
	UniversalParserRULE_transArrayFunction                       = 129
	UniversalParserRULE_standardFunction                         = 130
	UniversalParserRULE_overSpec                                 = 131
	UniversalParserRULE_filterSpec                               = 132
	UniversalParserRULE_constant                                 = 133
	UniversalParserRULE_compareOperator                          = 134
	UniversalParserRULE_dataType                                 = 135
	UniversalParserRULE_complexColTypeList                       = 136
	UniversalParserRULE_complexColType                           = 137
	UniversalParserRULE_setQuantifier                            = 138
	UniversalParserRULE_interval                                 = 139
	UniversalParserRULE_multiUnitsInterval                       = 140
	UniversalParserRULE_unitToUnitInterval                       = 141
	UniversalParserRULE_multiUnits                               = 142
	UniversalParserRULE_unitToUnit                               = 143
	UniversalParserRULE_commentSpec                              = 144
	UniversalParserRULE_windowClause                             = 145
	UniversalParserRULE_namedWindow                              = 146
	UniversalParserRULE_windowSpec                               = 147
	UniversalParserRULE_windowFrame                              = 148
	UniversalParserRULE_frameBound                               = 149
	UniversalParserRULE_tableProvider                            = 150
	UniversalParserRULE_createFileFormat                         = 151
	UniversalParserRULE_fileFormat                               = 152
	UniversalParserRULE_storageHandler                           = 153
	UniversalParserRULE_rowFormat                                = 154
	UniversalParserRULE_propertyList                             = 155
	UniversalParserRULE_property                                 = 156
	UniversalParserRULE_propertyKey                              = 157
	UniversalParserRULE_propertyValue                            = 158
	UniversalParserRULE_arguments                                = 159
	UniversalParserRULE_orderBy                                  = 160
	UniversalParserRULE_sortBy                                   = 161
	UniversalParserRULE_distributeBy                             = 162
	UniversalParserRULE_partitionBy                              = 163
	UniversalParserRULE_clusterBy                                = 164
	UniversalParserRULE_bucketsOption                            = 165
	UniversalParserRULE_limitItem                                = 166
	UniversalParserRULE_offsetItem                               = 167
	UniversalParserRULE_sortItems                                = 168
	UniversalParserRULE_sortItem                                 = 169
	UniversalParserRULE_sortType                                 = 170
	UniversalParserRULE_aliasSpec                                = 171
	UniversalParserRULE_locationSpec                             = 172
	UniversalParserRULE_multiIdentifierSeq                       = 173
	UniversalParserRULE_multiIdentifier                          = 174
	UniversalParserRULE_identifierSeq                            = 175
	UniversalParserRULE_identifier                               = 176
	UniversalParserRULE_quotedIdentifier                         = 177
	UniversalParserRULE_number                                   = 178
	UniversalParserRULE_string                                   = 179
	UniversalParserRULE_boolean                                  = 180
	UniversalParserRULE_null                                     = 181
	UniversalParserRULE_version                                  = 182
	UniversalParserRULE_noReservedKeywords                       = 183
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllK_SEMICOLON() []antlr.TerminalNode
	K_SEMICOLON(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllK_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_SEMICOLON)
}

func (s *StatementsContext) K_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_SEMICOLON, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *UniversalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, UniversalParserRULE_statements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Statement()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(369)
				p.Match(UniversalParserK_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(370)
				p.Statement()
			}

		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserK_SEMICOLON {
		{
			p.SetState(376)
			p.Match(UniversalParserK_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ViewTableAndView() IViewTableAndViewContext
	SetStatement() ISetStatementContext
	InsertQueryStatement() IInsertQueryStatementContext
	InsertValueStatement() IInsertValueStatementContext
	Query() IQueryContext
	CreateTableStatement() ICreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	RenameTablePartitions() IRenameTablePartitionsContext
	AddTablePartitions() IAddTablePartitionsContext
	DropTablePartitions() IDropTablePartitionsContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	UpdateMaterializedViewStatement() IUpdateMaterializedViewStatementContext
	SetMaterializedViewLifecycleStatement() ISetMaterializedViewLifecycleStatementContext
	UpdateMaterializedViewLifecycleStatement() IUpdateMaterializedViewLifecycleStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	DropMaterializedViewPartitionStatement() IDropMaterializedViewPartitionStatementContext
	CreateViewStatement() ICreateViewStatementContext
	RenameViewStatement() IRenameViewStatementContext
	ChangeViewStatement() IChangeViewStatementContext
	DropViewStatement() IDropViewStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) ViewTableAndView() IViewTableAndViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewTableAndViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewTableAndViewContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) InsertQueryStatement() IInsertQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertQueryStatementContext)
}

func (s *StatementContext) InsertValueStatement() IInsertValueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValueStatementContext)
}

func (s *StatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *StatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *StatementContext) RenameTablePartitions() IRenameTablePartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTablePartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTablePartitionsContext)
}

func (s *StatementContext) AddTablePartitions() IAddTablePartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddTablePartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddTablePartitionsContext)
}

func (s *StatementContext) DropTablePartitions() IDropTablePartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTablePartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTablePartitionsContext)
}

func (s *StatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *StatementContext) UpdateMaterializedViewStatement() IUpdateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateMaterializedViewStatementContext)
}

func (s *StatementContext) SetMaterializedViewLifecycleStatement() ISetMaterializedViewLifecycleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetMaterializedViewLifecycleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetMaterializedViewLifecycleStatementContext)
}

func (s *StatementContext) UpdateMaterializedViewLifecycleStatement() IUpdateMaterializedViewLifecycleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateMaterializedViewLifecycleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateMaterializedViewLifecycleStatementContext)
}

func (s *StatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *StatementContext) DropMaterializedViewPartitionStatement() IDropMaterializedViewPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewPartitionStatementContext)
}

func (s *StatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *StatementContext) RenameViewStatement() IRenameViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameViewStatementContext)
}

func (s *StatementContext) ChangeViewStatement() IChangeViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeViewStatementContext)
}

func (s *StatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *UniversalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, UniversalParserRULE_statement)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(379)
			p.ViewTableAndView()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(380)
			p.SetStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(381)
			p.InsertQueryStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(382)
			p.InsertValueStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(383)
			p.Query()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(384)
			p.CreateTableStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(385)
			p.DropTableStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(386)
			p.RenameTablePartitions()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(387)
			p.AddTablePartitions()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(388)
			p.DropTablePartitions()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(389)
			p.CreateMaterializedViewStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(390)
			p.UpdateMaterializedViewStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(391)
			p.SetMaterializedViewLifecycleStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(392)
			p.UpdateMaterializedViewLifecycleStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(393)
			p.DropMaterializedViewStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(394)
			p.DropMaterializedViewPartitionStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(395)
			p.CreateViewStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(396)
			p.RenameViewStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(397)
			p.ChangeViewStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(398)
			p.DropViewStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SET() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	K_EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	Number() INumberContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) T_SET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SET, 0)
}

func (s *SetStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *SetStatementContext) K_EQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EQ, 0)
}

func (s *SetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetStatementContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (p *UniversalParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, UniversalParserRULE_setStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Match(UniversalParserT_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(402)
		p.MultiIdentifier()
	}
	{
		p.SetState(403)
		p.Match(UniversalParserK_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(404)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(405)
			p.Number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewTableAndViewContext is an interface to support dynamic dispatch.
type IViewTableAndViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IMultiIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IMultiIdentifierContext)

	// Getter signatures
	T_DESC() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	T_EXTENDED() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext

	// IsViewTableAndViewContext differentiates from other interfaces.
	IsViewTableAndViewContext()
}

type ViewTableAndViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IMultiIdentifierContext
}

func NewEmptyViewTableAndViewContext() *ViewTableAndViewContext {
	var p = new(ViewTableAndViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_viewTableAndView
	return p
}

func InitEmptyViewTableAndViewContext(p *ViewTableAndViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_viewTableAndView
}

func (*ViewTableAndViewContext) IsViewTableAndViewContext() {}

func NewViewTableAndViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewTableAndViewContext {
	var p = new(ViewTableAndViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_viewTableAndView

	return p
}

func (s *ViewTableAndViewContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewTableAndViewContext) GetName() IMultiIdentifierContext { return s.name }

func (s *ViewTableAndViewContext) SetName(v IMultiIdentifierContext) { s.name = v }

func (s *ViewTableAndViewContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DESC, 0)
}

func (s *ViewTableAndViewContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *ViewTableAndViewContext) T_EXTENDED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTENDED, 0)
}

func (s *ViewTableAndViewContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ViewTableAndViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewTableAndViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewTableAndViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterViewTableAndView(s)
	}
}

func (s *ViewTableAndViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitViewTableAndView(s)
	}
}

func (p *UniversalParser) ViewTableAndView() (localctx IViewTableAndViewContext) {
	localctx = NewViewTableAndViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, UniversalParserRULE_viewTableAndView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		p.Match(UniversalParserT_DESC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(409)
			p.Match(UniversalParserT_EXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(412)

		var _x = p.MultiIdentifier()

		localctx.(*ViewTableAndViewContext).name = _x
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PARTITION {
		{
			p.SetState(413)
			p.PartitionSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Query() IQueryContext
	MultiIdentifier() IMultiIdentifierContext
	IfOption() IIfOptionContext
	LifecycleSpec() ILifecycleSpecContext
	T_BUILD() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	ViewColumns() IViewColumnsContext
	T_DISABLE() antlr.TerminalNode
	T_REWRITE() antlr.TerminalNode
	CommentSpec() ICommentSpecContext
	T_PARTITIONED() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode
	ClusterBy() IClusterByContext
	SortBy() ISortByContext
	BucketsOption() IBucketsOptionContext
	PropertiesSpec() IPropertiesSpecContext
	T_ON() antlr.TerminalNode
	T_BY() antlr.TerminalNode

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetViewName() IMultiIdentifierContext {
	return s.viewName
}

func (s *CreateMaterializedViewStatementContext) SetViewName(v IMultiIdentifierContext) {
	s.viewName = v
}

func (s *CreateMaterializedViewStatementContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *CreateMaterializedViewStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMaterializedViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *CreateMaterializedViewStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *CreateMaterializedViewStatementContext) LifecycleSpec() ILifecycleSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILifecycleSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILifecycleSpecContext)
}

func (s *CreateMaterializedViewStatementContext) T_BUILD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BUILD, 0)
}

func (s *CreateMaterializedViewStatementContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFERRED, 0)
}

func (s *CreateMaterializedViewStatementContext) ViewColumns() IViewColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewColumnsContext)
}

func (s *CreateMaterializedViewStatementContext) T_DISABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISABLE, 0)
}

func (s *CreateMaterializedViewStatementContext) T_REWRITE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REWRITE, 0)
}

func (s *CreateMaterializedViewStatementContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateMaterializedViewStatementContext) T_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITIONED, 0)
}

func (s *CreateMaterializedViewStatementContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *CreateMaterializedViewStatementContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *CreateMaterializedViewStatementContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *CreateMaterializedViewStatementContext) ClusterBy() IClusterByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByContext)
}

func (s *CreateMaterializedViewStatementContext) SortBy() ISortByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByContext)
}

func (s *CreateMaterializedViewStatementContext) BucketsOption() IBucketsOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketsOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketsOptionContext)
}

func (s *CreateMaterializedViewStatementContext) PropertiesSpec() IPropertiesSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesSpecContext)
}

func (s *CreateMaterializedViewStatementContext) T_ON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ON, 0)
}

func (s *CreateMaterializedViewStatementContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (p *UniversalParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, UniversalParserRULE_createMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(UniversalParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(417)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(419)
			p.IfOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(422)

		var _x = p.MultiIdentifier()

		localctx.(*CreateMaterializedViewStatementContext).viewName = _x
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_LIFECYCLE {
		{
			p.SetState(423)
			p.LifecycleSpec()
		}

	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_BUILD {
		{
			p.SetState(426)
			p.Match(UniversalParserT_BUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Match(UniversalParserT_DEFERRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserK_OPEN_PAREN {
		{
			p.SetState(430)
			p.ViewColumns()
		}

	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_DISABLE {
		{
			p.SetState(433)
			p.Match(UniversalParserT_DISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(434)
			p.Match(UniversalParserT_REWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(437)
			p.CommentSpec()
		}

	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PARTITIONED {
		{
			p.SetState(440)
			p.Match(UniversalParserT_PARTITIONED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_BY || _la == UniversalParserT_ON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(442)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(443)
			p.IdentifierSeq()
		}
		{
			p.SetState(444)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_CLUSTER || _la == UniversalParserT_CLUSTERED || _la == UniversalParserT_RANGE {
		{
			p.SetState(448)
			p.ClusterBy()
		}

	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_SORT || _la == UniversalParserT_SORTED {
		{
			p.SetState(451)
			p.SortBy()
		}

	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_INTO {
		{
			p.SetState(454)
			p.BucketsOption()
		}

	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_TBLPROPERTIES {
		{
			p.SetState(457)
			p.PropertiesSpec()
		}

	}
	{
		p.SetState(460)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(461)
		p.Query()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IUpdateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_REBUILD() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	MultiIdentifier() IMultiIdentifierContext

	// IsUpdateMaterializedViewStatementContext differentiates from other interfaces.
	IsUpdateMaterializedViewStatementContext()
}

type UpdateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyUpdateMaterializedViewStatementContext() *UpdateMaterializedViewStatementContext {
	var p = new(UpdateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewStatement
	return p
}

func InitEmptyUpdateMaterializedViewStatementContext(p *UpdateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewStatement
}

func (*UpdateMaterializedViewStatementContext) IsUpdateMaterializedViewStatementContext() {}

func NewUpdateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateMaterializedViewStatementContext {
	var p = new(UpdateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewStatement

	return p
}

func (s *UpdateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateMaterializedViewStatementContext) GetViewName() IMultiIdentifierContext {
	return s.viewName
}

func (s *UpdateMaterializedViewStatementContext) SetViewName(v IMultiIdentifierContext) {
	s.viewName = v
}

func (s *UpdateMaterializedViewStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *UpdateMaterializedViewStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *UpdateMaterializedViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *UpdateMaterializedViewStatementContext) T_REBUILD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REBUILD, 0)
}

func (s *UpdateMaterializedViewStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *UpdateMaterializedViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *UpdateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUpdateMaterializedViewStatement(s)
	}
}

func (s *UpdateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUpdateMaterializedViewStatement(s)
	}
}

func (p *UniversalParser) UpdateMaterializedViewStatement() (localctx IUpdateMaterializedViewStatementContext) {
	localctx = NewUpdateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, UniversalParserRULE_updateMaterializedViewStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(464)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(466)

		var _x = p.MultiIdentifier()

		localctx.(*UpdateMaterializedViewStatementContext).viewName = _x
	}
	{
		p.SetState(467)
		p.Match(UniversalParserT_REBUILD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)
		p.PartitionSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetMaterializedViewLifecycleStatementContext is an interface to support dynamic dispatch.
type ISetMaterializedViewLifecycleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	LifecycleSpec() ILifecycleSpecContext
	MultiIdentifier() IMultiIdentifierContext

	// IsSetMaterializedViewLifecycleStatementContext differentiates from other interfaces.
	IsSetMaterializedViewLifecycleStatementContext()
}

type SetMaterializedViewLifecycleStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptySetMaterializedViewLifecycleStatementContext() *SetMaterializedViewLifecycleStatementContext {
	var p = new(SetMaterializedViewLifecycleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setMaterializedViewLifecycleStatement
	return p
}

func InitEmptySetMaterializedViewLifecycleStatementContext(p *SetMaterializedViewLifecycleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setMaterializedViewLifecycleStatement
}

func (*SetMaterializedViewLifecycleStatementContext) IsSetMaterializedViewLifecycleStatementContext() {
}

func NewSetMaterializedViewLifecycleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetMaterializedViewLifecycleStatementContext {
	var p = new(SetMaterializedViewLifecycleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_setMaterializedViewLifecycleStatement

	return p
}

func (s *SetMaterializedViewLifecycleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetMaterializedViewLifecycleStatementContext) GetViewName() IMultiIdentifierContext {
	return s.viewName
}

func (s *SetMaterializedViewLifecycleStatementContext) SetViewName(v IMultiIdentifierContext) {
	s.viewName = v
}

func (s *SetMaterializedViewLifecycleStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *SetMaterializedViewLifecycleStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *SetMaterializedViewLifecycleStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *SetMaterializedViewLifecycleStatementContext) T_SET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SET, 0)
}

func (s *SetMaterializedViewLifecycleStatementContext) LifecycleSpec() ILifecycleSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILifecycleSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILifecycleSpecContext)
}

func (s *SetMaterializedViewLifecycleStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *SetMaterializedViewLifecycleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetMaterializedViewLifecycleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetMaterializedViewLifecycleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSetMaterializedViewLifecycleStatement(s)
	}
}

func (s *SetMaterializedViewLifecycleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSetMaterializedViewLifecycleStatement(s)
	}
}

func (p *UniversalParser) SetMaterializedViewLifecycleStatement() (localctx ISetMaterializedViewLifecycleStatementContext) {
	localctx = NewSetMaterializedViewLifecycleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, UniversalParserRULE_setMaterializedViewLifecycleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(473)

		var _x = p.MultiIdentifier()

		localctx.(*SetMaterializedViewLifecycleStatementContext).viewName = _x
	}
	{
		p.SetState(474)
		p.Match(UniversalParserT_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.LifecycleSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateMaterializedViewLifecycleStatementContext is an interface to support dynamic dispatch.
type IUpdateMaterializedViewLifecycleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	T_LIFECYCLE() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	T_ENABLE() antlr.TerminalNode
	T_DISABLE() antlr.TerminalNode

	// IsUpdateMaterializedViewLifecycleStatementContext differentiates from other interfaces.
	IsUpdateMaterializedViewLifecycleStatementContext()
}

type UpdateMaterializedViewLifecycleStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyUpdateMaterializedViewLifecycleStatementContext() *UpdateMaterializedViewLifecycleStatementContext {
	var p = new(UpdateMaterializedViewLifecycleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewLifecycleStatement
	return p
}

func InitEmptyUpdateMaterializedViewLifecycleStatementContext(p *UpdateMaterializedViewLifecycleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewLifecycleStatement
}

func (*UpdateMaterializedViewLifecycleStatementContext) IsUpdateMaterializedViewLifecycleStatementContext() {
}

func NewUpdateMaterializedViewLifecycleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateMaterializedViewLifecycleStatementContext {
	var p = new(UpdateMaterializedViewLifecycleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_updateMaterializedViewLifecycleStatement

	return p
}

func (s *UpdateMaterializedViewLifecycleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateMaterializedViewLifecycleStatementContext) GetViewName() IMultiIdentifierContext {
	return s.viewName
}

func (s *UpdateMaterializedViewLifecycleStatementContext) SetViewName(v IMultiIdentifierContext) {
	s.viewName = v
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_LIFECYCLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIFECYCLE, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ENABLE, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) T_DISABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISABLE, 0)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateMaterializedViewLifecycleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateMaterializedViewLifecycleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUpdateMaterializedViewLifecycleStatement(s)
	}
}

func (s *UpdateMaterializedViewLifecycleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUpdateMaterializedViewLifecycleStatement(s)
	}
}

func (p *UniversalParser) UpdateMaterializedViewLifecycleStatement() (localctx IUpdateMaterializedViewLifecycleStatementContext) {
	localctx = NewUpdateMaterializedViewLifecycleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, UniversalParserRULE_updateMaterializedViewLifecycleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(478)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(479)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(480)

		var _x = p.MultiIdentifier()

		localctx.(*UpdateMaterializedViewLifecycleStatementContext).viewName = _x
	}
	{
		p.SetState(481)
		p.PartitionSpec()
	}
	{
		p.SetState(482)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_ENABLE || _la == UniversalParserT_DISABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(483)
		p.Match(UniversalParserT_LIFECYCLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultiIdentifierContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultiIdentifierContext)

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	IfOption() IIfOptionContext
	T_PURGE() antlr.TerminalNode

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	tableName IMultiIdentifierContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetTableName() IMultiIdentifierContext {
	return s.tableName
}

func (s *DropMaterializedViewStatementContext) SetTableName(v IMultiIdentifierContext) {
	s.tableName = v
}

func (s *DropMaterializedViewStatementContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *DropMaterializedViewStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *DropMaterializedViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *DropMaterializedViewStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *DropMaterializedViewStatementContext) T_PURGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PURGE, 0)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (p *UniversalParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, UniversalParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(UniversalParserT_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(486)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(487)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(488)
			p.IfOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(491)

		var _x = p.MultiIdentifier()

		localctx.(*DropMaterializedViewStatementContext).tableName = _x
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PURGE {
		{
			p.SetState(492)
			p.Match(UniversalParserT_PURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewPartitionStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_MATERIALIZED() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_DROP() antlr.TerminalNode
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext
	MultiIdentifier() IMultiIdentifierContext
	IfOption() IIfOptionContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsDropMaterializedViewPartitionStatementContext differentiates from other interfaces.
	IsDropMaterializedViewPartitionStatementContext()
}

type DropMaterializedViewPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyDropMaterializedViewPartitionStatementContext() *DropMaterializedViewPartitionStatementContext {
	var p = new(DropMaterializedViewPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewPartitionStatement
	return p
}

func InitEmptyDropMaterializedViewPartitionStatementContext(p *DropMaterializedViewPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewPartitionStatement
}

func (*DropMaterializedViewPartitionStatementContext) IsDropMaterializedViewPartitionStatementContext() {
}

func NewDropMaterializedViewPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewPartitionStatementContext {
	var p = new(DropMaterializedViewPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dropMaterializedViewPartitionStatement

	return p
}

func (s *DropMaterializedViewPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewPartitionStatementContext) GetViewName() IMultiIdentifierContext {
	return s.viewName
}

func (s *DropMaterializedViewPartitionStatementContext) SetViewName(v IMultiIdentifierContext) {
	s.viewName = v
}

func (s *DropMaterializedViewPartitionStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *DropMaterializedViewPartitionStatementContext) T_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATERIALIZED, 0)
}

func (s *DropMaterializedViewPartitionStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *DropMaterializedViewPartitionStatementContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *DropMaterializedViewPartitionStatementContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *DropMaterializedViewPartitionStatementContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropMaterializedViewPartitionStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *DropMaterializedViewPartitionStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *DropMaterializedViewPartitionStatementContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *DropMaterializedViewPartitionStatementContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *DropMaterializedViewPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDropMaterializedViewPartitionStatement(s)
	}
}

func (s *DropMaterializedViewPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDropMaterializedViewPartitionStatement(s)
	}
}

func (p *UniversalParser) DropMaterializedViewPartitionStatement() (localctx IDropMaterializedViewPartitionStatementContext) {
	localctx = NewDropMaterializedViewPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, UniversalParserRULE_dropMaterializedViewPartitionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(496)
		p.Match(UniversalParserT_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(497)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(498)

		var _x = p.MultiIdentifier()

		localctx.(*DropMaterializedViewPartitionStatementContext).viewName = _x
	}
	{
		p.SetState(499)
		p.Match(UniversalParserT_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_IF {
		{
			p.SetState(500)
			p.IfOption()
		}

	}
	{
		p.SetState(503)
		p.PartitionSpec()
	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(504)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)
			p.PartitionSpec()
		}

		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	CommentSpec() ICommentSpecContext
	T_AS() antlr.TerminalNode
	Query() IQueryContext
	MultiIdentifier() IMultiIdentifierContext
	ReplaceOption() IReplaceOptionContext
	IfOption() IIfOptionContext
	ViewColumns() IViewColumnsContext

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) GetViewName() IMultiIdentifierContext { return s.viewName }

func (s *CreateViewStatementContext) SetViewName(v IMultiIdentifierContext) { s.viewName = v }

func (s *CreateViewStatementContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATE, 0)
}

func (s *CreateViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *CreateViewStatementContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateViewStatementContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *CreateViewStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *CreateViewStatementContext) ReplaceOption() IReplaceOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceOptionContext)
}

func (s *CreateViewStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *CreateViewStatementContext) ViewColumns() IViewColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewColumnsContext)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (p *UniversalParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, UniversalParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(UniversalParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_OR {
		{
			p.SetState(512)
			p.ReplaceOption()
		}

	}
	{
		p.SetState(515)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(516)
			p.IfOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(519)

		var _x = p.MultiIdentifier()

		localctx.(*CreateViewStatementContext).viewName = _x
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserK_OPEN_PAREN {
		{
			p.SetState(520)
			p.ViewColumns()
		}

	}
	{
		p.SetState(523)
		p.CommentSpec()
	}
	{
		p.SetState(524)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Query()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewColumnsContext is an interface to support dynamic dispatch.
type IViewColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetViewColumnCollection returns the viewColumnCollection rule context list.
	GetViewColumnCollection() []IIdentifierContext

	// SetViewColumnCollection sets the viewColumnCollection rule context list.
	SetViewColumnCollection([]IIdentifierContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCommentSpec() []ICommentSpecContext
	CommentSpec(i int) ICommentSpecContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsViewColumnsContext differentiates from other interfaces.
	IsViewColumnsContext()
}

type ViewColumnsContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_identifier          IIdentifierContext
	viewColumnCollection []IIdentifierContext
}

func NewEmptyViewColumnsContext() *ViewColumnsContext {
	var p = new(ViewColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_viewColumns
	return p
}

func InitEmptyViewColumnsContext(p *ViewColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_viewColumns
}

func (*ViewColumnsContext) IsViewColumnsContext() {}

func NewViewColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewColumnsContext {
	var p = new(ViewColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_viewColumns

	return p
}

func (s *ViewColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewColumnsContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *ViewColumnsContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *ViewColumnsContext) GetViewColumnCollection() []IIdentifierContext {
	return s.viewColumnCollection
}

func (s *ViewColumnsContext) SetViewColumnCollection(v []IIdentifierContext) {
	s.viewColumnCollection = v
}

func (s *ViewColumnsContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *ViewColumnsContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *ViewColumnsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ViewColumnsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ViewColumnsContext) AllCommentSpec() []ICommentSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentSpecContext); ok {
			len++
		}
	}

	tst := make([]ICommentSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentSpecContext); ok {
			tst[i] = t.(ICommentSpecContext)
			i++
		}
	}

	return tst
}

func (s *ViewColumnsContext) CommentSpec(i int) ICommentSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ViewColumnsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *ViewColumnsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *ViewColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterViewColumns(s)
	}
}

func (s *ViewColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitViewColumns(s)
	}
}

func (p *UniversalParser) ViewColumns() (localctx IViewColumnsContext) {
	localctx = NewViewColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, UniversalParserRULE_viewColumns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)

		var _x = p.Identifier()

		localctx.(*ViewColumnsContext)._identifier = _x
	}
	localctx.(*ViewColumnsContext).viewColumnCollection = append(localctx.(*ViewColumnsContext).viewColumnCollection, localctx.(*ViewColumnsContext)._identifier)
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(529)
			p.CommentSpec()
		}

	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(532)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)

			var _x = p.Identifier()

			localctx.(*ViewColumnsContext)._identifier = _x
		}
		localctx.(*ViewColumnsContext).viewColumnCollection = append(localctx.(*ViewColumnsContext).viewColumnCollection, localctx.(*ViewColumnsContext)._identifier)
		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_COMMENT {
			{
				p.SetState(534)
				p.CommentSpec()
			}

		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(542)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameViewStatementContext is an interface to support dynamic dispatch.
type IRenameViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetView_name returns the view_name rule contexts.
	GetView_name() IMultiIdentifierContext

	// GetNew_view_name returns the new_view_name rule contexts.
	GetNew_view_name() IMultiIdentifierContext

	// SetView_name sets the view_name rule contexts.
	SetView_name(IMultiIdentifierContext)

	// SetNew_view_name sets the new_view_name rule contexts.
	SetNew_view_name(IMultiIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_RENAME() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	AllMultiIdentifier() []IMultiIdentifierContext
	MultiIdentifier(i int) IMultiIdentifierContext

	// IsRenameViewStatementContext differentiates from other interfaces.
	IsRenameViewStatementContext()
}

type RenameViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	view_name     IMultiIdentifierContext
	new_view_name IMultiIdentifierContext
}

func NewEmptyRenameViewStatementContext() *RenameViewStatementContext {
	var p = new(RenameViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_renameViewStatement
	return p
}

func InitEmptyRenameViewStatementContext(p *RenameViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_renameViewStatement
}

func (*RenameViewStatementContext) IsRenameViewStatementContext() {}

func NewRenameViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameViewStatementContext {
	var p = new(RenameViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_renameViewStatement

	return p
}

func (s *RenameViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameViewStatementContext) GetView_name() IMultiIdentifierContext { return s.view_name }

func (s *RenameViewStatementContext) GetNew_view_name() IMultiIdentifierContext {
	return s.new_view_name
}

func (s *RenameViewStatementContext) SetView_name(v IMultiIdentifierContext) { s.view_name = v }

func (s *RenameViewStatementContext) SetNew_view_name(v IMultiIdentifierContext) { s.new_view_name = v }

func (s *RenameViewStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *RenameViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *RenameViewStatementContext) T_RENAME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RENAME, 0)
}

func (s *RenameViewStatementContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *RenameViewStatementContext) AllMultiIdentifier() []IMultiIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultiIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiIdentifierContext); ok {
			tst[i] = t.(IMultiIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameViewStatementContext) MultiIdentifier(i int) IMultiIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *RenameViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRenameViewStatement(s)
	}
}

func (s *RenameViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRenameViewStatement(s)
	}
}

func (p *UniversalParser) RenameViewStatement() (localctx IRenameViewStatementContext) {
	localctx = NewRenameViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, UniversalParserRULE_renameViewStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(545)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(546)

		var _x = p.MultiIdentifier()

		localctx.(*RenameViewStatementContext).view_name = _x
	}
	{
		p.SetState(547)
		p.Match(UniversalParserT_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(548)
		p.Match(UniversalParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(549)

		var _x = p.MultiIdentifier()

		localctx.(*RenameViewStatementContext).new_view_name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeViewStatementContext is an interface to support dynamic dispatch.
type IChangeViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetView_name returns the view_name rule contexts.
	GetView_name() IMultiIdentifierContext

	// GetNew_owner returns the new_owner rule contexts.
	GetNew_owner() IIdentifierContext

	// SetView_name sets the view_name rule contexts.
	SetView_name(IMultiIdentifierContext)

	// SetNew_owner sets the new_owner rule contexts.
	SetNew_owner(IIdentifierContext)

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_CHANGEOWNER() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	Identifier() IIdentifierContext

	// IsChangeViewStatementContext differentiates from other interfaces.
	IsChangeViewStatementContext()
}

type ChangeViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	view_name IMultiIdentifierContext
	new_owner IIdentifierContext
}

func NewEmptyChangeViewStatementContext() *ChangeViewStatementContext {
	var p = new(ChangeViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_changeViewStatement
	return p
}

func InitEmptyChangeViewStatementContext(p *ChangeViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_changeViewStatement
}

func (*ChangeViewStatementContext) IsChangeViewStatementContext() {}

func NewChangeViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeViewStatementContext {
	var p = new(ChangeViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_changeViewStatement

	return p
}

func (s *ChangeViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeViewStatementContext) GetView_name() IMultiIdentifierContext { return s.view_name }

func (s *ChangeViewStatementContext) GetNew_owner() IIdentifierContext { return s.new_owner }

func (s *ChangeViewStatementContext) SetView_name(v IMultiIdentifierContext) { s.view_name = v }

func (s *ChangeViewStatementContext) SetNew_owner(v IIdentifierContext) { s.new_owner = v }

func (s *ChangeViewStatementContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *ChangeViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *ChangeViewStatementContext) T_CHANGEOWNER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHANGEOWNER, 0)
}

func (s *ChangeViewStatementContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *ChangeViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *ChangeViewStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ChangeViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterChangeViewStatement(s)
	}
}

func (s *ChangeViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitChangeViewStatement(s)
	}
}

func (p *UniversalParser) ChangeViewStatement() (localctx IChangeViewStatementContext) {
	localctx = NewChangeViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, UniversalParserRULE_changeViewStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(552)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)

		var _x = p.MultiIdentifier()

		localctx.(*ChangeViewStatementContext).view_name = _x
	}
	{
		p.SetState(554)
		p.Match(UniversalParserT_CHANGEOWNER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(555)
		p.Match(UniversalParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(556)

		var _x = p.Identifier()

		localctx.(*ChangeViewStatementContext).new_owner = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetViewName returns the viewName rule contexts.
	GetViewName() IMultiIdentifierContext

	// SetViewName sets the viewName rule contexts.
	SetViewName(IMultiIdentifierContext)

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	IfOption() IIfOptionContext

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	viewName IMultiIdentifierContext
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) GetViewName() IMultiIdentifierContext { return s.viewName }

func (s *DropViewStatementContext) SetViewName(v IMultiIdentifierContext) { s.viewName = v }

func (s *DropViewStatementContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *DropViewStatementContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *DropViewStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *DropViewStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (p *UniversalParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, UniversalParserRULE_dropViewStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Match(UniversalParserT_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(559)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(560)
			p.IfOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(563)

		var _x = p.MultiIdentifier()

		localctx.(*DropViewStatementContext).viewName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTempKeyWord returns the tempKeyWord token.
	GetTempKeyWord() antlr.Token

	// GetTransKeyWord returns the transKeyWord token.
	GetTransKeyWord() antlr.Token

	// GetExternalKeyWord returns the externalKeyWord token.
	GetExternalKeyWord() antlr.Token

	// SetTempKeyWord sets the tempKeyWord token.
	SetTempKeyWord(antlr.Token)

	// SetTransKeyWord sets the transKeyWord token.
	SetTransKeyWord(antlr.Token)

	// SetExternalKeyWord sets the externalKeyWord token.
	SetExternalKeyWord(antlr.Token)

	// GetExistsOption returns the existsOption rule contexts.
	GetExistsOption() IIfOptionContext

	// GetTable returns the table rule contexts.
	GetTable() IMultiIdentifierContext

	// GetBodyOption returns the bodyOption rule contexts.
	GetBodyOption() ICreateTableBodyspecContext

	// GetCommentOption returns the commentOption rule contexts.
	GetCommentOption() ICommentSpecContext

	// GetPartitionOption returns the partitionOption rule contexts.
	GetPartitionOption() ITablePartitionSpecContext

	// GetSortOption returns the sortOption rule contexts.
	GetSortOption() ISortSpecContext

	// GetSkewedOption returns the skewedOption rule contexts.
	GetSkewedOption() ISkewedBySpecContext

	// GetFormatOption returns the formatOption rule contexts.
	GetFormatOption() IFormatSpecContext

	// GetLocationOption returns the locationOption rule contexts.
	GetLocationOption() ILocationSpecContext

	// GetPropertiesOption returns the propertiesOption rule contexts.
	GetPropertiesOption() IPropertiesSpecContext

	// GetTableAsOption returns the tableAsOption rule contexts.
	GetTableAsOption() ITableSelectSpecContext

	// GetTableLifecycleOption returns the tableLifecycleOption rule contexts.
	GetTableLifecycleOption() ILifecycleSpecContext

	// SetExistsOption sets the existsOption rule contexts.
	SetExistsOption(IIfOptionContext)

	// SetTable sets the table rule contexts.
	SetTable(IMultiIdentifierContext)

	// SetBodyOption sets the bodyOption rule contexts.
	SetBodyOption(ICreateTableBodyspecContext)

	// SetCommentOption sets the commentOption rule contexts.
	SetCommentOption(ICommentSpecContext)

	// SetPartitionOption sets the partitionOption rule contexts.
	SetPartitionOption(ITablePartitionSpecContext)

	// SetSortOption sets the sortOption rule contexts.
	SetSortOption(ISortSpecContext)

	// SetSkewedOption sets the skewedOption rule contexts.
	SetSkewedOption(ISkewedBySpecContext)

	// SetFormatOption sets the formatOption rule contexts.
	SetFormatOption(IFormatSpecContext)

	// SetLocationOption sets the locationOption rule contexts.
	SetLocationOption(ILocationSpecContext)

	// SetPropertiesOption sets the propertiesOption rule contexts.
	SetPropertiesOption(IPropertiesSpecContext)

	// SetTableAsOption sets the tableAsOption rule contexts.
	SetTableAsOption(ITableSelectSpecContext)

	// SetTableLifecycleOption sets the tableLifecycleOption rule contexts.
	SetTableLifecycleOption(ILifecycleSpecContext)

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	IfOption() IIfOptionContext
	MultiIdentifier() IMultiIdentifierContext
	T_TEMPORARY() antlr.TerminalNode
	T_TRANSACTIONAL() antlr.TerminalNode
	T_EXTERNAL() antlr.TerminalNode
	CreateTableBodyspec() ICreateTableBodyspecContext
	CommentSpec() ICommentSpecContext
	TablePartitionSpec() ITablePartitionSpecContext
	SortSpec() ISortSpecContext
	SkewedBySpec() ISkewedBySpecContext
	FormatSpec() IFormatSpecContext
	LocationSpec() ILocationSpecContext
	PropertiesSpec() IPropertiesSpecContext
	TableSelectSpec() ITableSelectSpecContext
	LifecycleSpec() ILifecycleSpecContext

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	tempKeyWord          antlr.Token
	transKeyWord         antlr.Token
	externalKeyWord      antlr.Token
	existsOption         IIfOptionContext
	table                IMultiIdentifierContext
	bodyOption           ICreateTableBodyspecContext
	commentOption        ICommentSpecContext
	partitionOption      ITablePartitionSpecContext
	sortOption           ISortSpecContext
	skewedOption         ISkewedBySpecContext
	formatOption         IFormatSpecContext
	locationOption       ILocationSpecContext
	propertiesOption     IPropertiesSpecContext
	tableAsOption        ITableSelectSpecContext
	tableLifecycleOption ILifecycleSpecContext
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) GetTempKeyWord() antlr.Token { return s.tempKeyWord }

func (s *CreateTableStatementContext) GetTransKeyWord() antlr.Token { return s.transKeyWord }

func (s *CreateTableStatementContext) GetExternalKeyWord() antlr.Token { return s.externalKeyWord }

func (s *CreateTableStatementContext) SetTempKeyWord(v antlr.Token) { s.tempKeyWord = v }

func (s *CreateTableStatementContext) SetTransKeyWord(v antlr.Token) { s.transKeyWord = v }

func (s *CreateTableStatementContext) SetExternalKeyWord(v antlr.Token) { s.externalKeyWord = v }

func (s *CreateTableStatementContext) GetExistsOption() IIfOptionContext { return s.existsOption }

func (s *CreateTableStatementContext) GetTable() IMultiIdentifierContext { return s.table }

func (s *CreateTableStatementContext) GetBodyOption() ICreateTableBodyspecContext {
	return s.bodyOption
}

func (s *CreateTableStatementContext) GetCommentOption() ICommentSpecContext { return s.commentOption }

func (s *CreateTableStatementContext) GetPartitionOption() ITablePartitionSpecContext {
	return s.partitionOption
}

func (s *CreateTableStatementContext) GetSortOption() ISortSpecContext { return s.sortOption }

func (s *CreateTableStatementContext) GetSkewedOption() ISkewedBySpecContext { return s.skewedOption }

func (s *CreateTableStatementContext) GetFormatOption() IFormatSpecContext { return s.formatOption }

func (s *CreateTableStatementContext) GetLocationOption() ILocationSpecContext {
	return s.locationOption
}

func (s *CreateTableStatementContext) GetPropertiesOption() IPropertiesSpecContext {
	return s.propertiesOption
}

func (s *CreateTableStatementContext) GetTableAsOption() ITableSelectSpecContext {
	return s.tableAsOption
}

func (s *CreateTableStatementContext) GetTableLifecycleOption() ILifecycleSpecContext {
	return s.tableLifecycleOption
}

func (s *CreateTableStatementContext) SetExistsOption(v IIfOptionContext) { s.existsOption = v }

func (s *CreateTableStatementContext) SetTable(v IMultiIdentifierContext) { s.table = v }

func (s *CreateTableStatementContext) SetBodyOption(v ICreateTableBodyspecContext) { s.bodyOption = v }

func (s *CreateTableStatementContext) SetCommentOption(v ICommentSpecContext) { s.commentOption = v }

func (s *CreateTableStatementContext) SetPartitionOption(v ITablePartitionSpecContext) {
	s.partitionOption = v
}

func (s *CreateTableStatementContext) SetSortOption(v ISortSpecContext) { s.sortOption = v }

func (s *CreateTableStatementContext) SetSkewedOption(v ISkewedBySpecContext) { s.skewedOption = v }

func (s *CreateTableStatementContext) SetFormatOption(v IFormatSpecContext) { s.formatOption = v }

func (s *CreateTableStatementContext) SetLocationOption(v ILocationSpecContext) { s.locationOption = v }

func (s *CreateTableStatementContext) SetPropertiesOption(v IPropertiesSpecContext) {
	s.propertiesOption = v
}

func (s *CreateTableStatementContext) SetTableAsOption(v ITableSelectSpecContext) {
	s.tableAsOption = v
}

func (s *CreateTableStatementContext) SetTableLifecycleOption(v ILifecycleSpecContext) {
	s.tableLifecycleOption = v
}

func (s *CreateTableStatementContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATE, 0)
}

func (s *CreateTableStatementContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *CreateTableStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *CreateTableStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *CreateTableStatementContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TEMPORARY, 0)
}

func (s *CreateTableStatementContext) T_TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSACTIONAL, 0)
}

func (s *CreateTableStatementContext) T_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTERNAL, 0)
}

func (s *CreateTableStatementContext) CreateTableBodyspec() ICreateTableBodyspecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableBodyspecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableBodyspecContext)
}

func (s *CreateTableStatementContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateTableStatementContext) TablePartitionSpec() ITablePartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePartitionSpecContext)
}

func (s *CreateTableStatementContext) SortSpec() ISortSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortSpecContext)
}

func (s *CreateTableStatementContext) SkewedBySpec() ISkewedBySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedBySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedBySpecContext)
}

func (s *CreateTableStatementContext) FormatSpec() IFormatSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatSpecContext)
}

func (s *CreateTableStatementContext) LocationSpec() ILocationSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationSpecContext)
}

func (s *CreateTableStatementContext) PropertiesSpec() IPropertiesSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesSpecContext)
}

func (s *CreateTableStatementContext) TableSelectSpec() ITableSelectSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSelectSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSelectSpecContext)
}

func (s *CreateTableStatementContext) LifecycleSpec() ILifecycleSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILifecycleSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILifecycleSpecContext)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (p *UniversalParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, UniversalParserRULE_createTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Match(UniversalParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_TEMPORARY {
		{
			p.SetState(566)

			var _m = p.Match(UniversalParserT_TEMPORARY)

			localctx.(*CreateTableStatementContext).tempKeyWord = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_TRANSACTIONAL {
		{
			p.SetState(569)

			var _m = p.Match(UniversalParserT_TRANSACTIONAL)

			localctx.(*CreateTableStatementContext).transKeyWord = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_EXTERNAL {
		{
			p.SetState(572)

			var _m = p.Match(UniversalParserT_EXTERNAL)

			localctx.(*CreateTableStatementContext).externalKeyWord = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(575)
		p.Match(UniversalParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(576)

		var _x = p.IfOption()

		localctx.(*CreateTableStatementContext).existsOption = _x
	}
	{
		p.SetState(577)

		var _x = p.MultiIdentifier()

		localctx.(*CreateTableStatementContext).table = _x
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserK_OPEN_PAREN {
		{
			p.SetState(578)

			var _x = p.CreateTableBodyspec()

			localctx.(*CreateTableStatementContext).bodyOption = _x
		}

	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(581)

			var _x = p.CommentSpec()

			localctx.(*CreateTableStatementContext).commentOption = _x
		}

	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PARTITIONED {
		{
			p.SetState(584)

			var _x = p.TablePartitionSpec()

			localctx.(*CreateTableStatementContext).partitionOption = _x
		}

	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_CLUSTER || _la == UniversalParserT_CLUSTERED || _la == UniversalParserT_RANGE {
		{
			p.SetState(587)

			var _x = p.SortSpec()

			localctx.(*CreateTableStatementContext).sortOption = _x
		}

	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_SKEWED {
		{
			p.SetState(590)

			var _x = p.SkewedBySpec()

			localctx.(*CreateTableStatementContext).skewedOption = _x
		}

	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ROW || _la == UniversalParserT_STORED {
		{
			p.SetState(593)

			var _x = p.FormatSpec()

			localctx.(*CreateTableStatementContext).formatOption = _x
		}

	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_LOCATION {
		{
			p.SetState(596)

			var _x = p.LocationSpec()

			localctx.(*CreateTableStatementContext).locationOption = _x
		}

	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_TBLPROPERTIES {
		{
			p.SetState(599)

			var _x = p.PropertiesSpec()

			localctx.(*CreateTableStatementContext).propertiesOption = _x
		}

	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_AS {
		{
			p.SetState(602)

			var _x = p.TableSelectSpec()

			localctx.(*CreateTableStatementContext).tableAsOption = _x
		}

	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_LIFECYCLE {
		{
			p.SetState(605)

			var _x = p.LifecycleSpec()

			localctx.(*CreateTableStatementContext).tableLifecycleOption = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultiIdentifierContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultiIdentifierContext)

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	IfOption() IIfOptionContext
	T_PURGE() antlr.TerminalNode

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	tableName IMultiIdentifierContext
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) GetTableName() IMultiIdentifierContext { return s.tableName }

func (s *DropTableStatementContext) SetTableName(v IMultiIdentifierContext) { s.tableName = v }

func (s *DropTableStatementContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *DropTableStatementContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *DropTableStatementContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *DropTableStatementContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *DropTableStatementContext) T_PURGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PURGE, 0)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (p *UniversalParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, UniversalParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(UniversalParserT_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(609)
		p.Match(UniversalParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(610)
			p.IfOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(613)

		var _x = p.MultiIdentifier()

		localctx.(*DropTableStatementContext).tableName = _x
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PURGE {
		{
			p.SetState(614)
			p.Match(UniversalParserT_PURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableBodyspecContext is an interface to support dynamic dispatch.
type ICreateTableBodyspecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	CreateTableItems() ICreateTableItemsContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsCreateTableBodyspecContext differentiates from other interfaces.
	IsCreateTableBodyspecContext()
}

type CreateTableBodyspecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableBodyspecContext() *CreateTableBodyspecContext {
	var p = new(CreateTableBodyspecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableBodyspec
	return p
}

func InitEmptyCreateTableBodyspecContext(p *CreateTableBodyspecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableBodyspec
}

func (*CreateTableBodyspecContext) IsCreateTableBodyspecContext() {}

func NewCreateTableBodyspecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableBodyspecContext {
	var p = new(CreateTableBodyspecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createTableBodyspec

	return p
}

func (s *CreateTableBodyspecContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableBodyspecContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *CreateTableBodyspecContext) CreateTableItems() ICreateTableItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableItemsContext)
}

func (s *CreateTableBodyspecContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *CreateTableBodyspecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableBodyspecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableBodyspecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateTableBodyspec(s)
	}
}

func (s *CreateTableBodyspecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateTableBodyspec(s)
	}
}

func (p *UniversalParser) CreateTableBodyspec() (localctx ICreateTableBodyspecContext) {
	localctx = NewCreateTableBodyspecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, UniversalParserRULE_createTableBodyspec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(618)
		p.CreateTableItems()
	}
	{
		p.SetState(619)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableItemsContext is an interface to support dynamic dispatch.
type ICreateTableItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_createTableItem returns the _createTableItem rule contexts.
	Get_createTableItem() ICreateTableItemContext

	// Set_createTableItem sets the _createTableItem rule contexts.
	Set_createTableItem(ICreateTableItemContext)

	// GetColumnItemCollection returns the columnItemCollection rule context list.
	GetColumnItemCollection() []ICreateTableItemContext

	// SetColumnItemCollection sets the columnItemCollection rule context list.
	SetColumnItemCollection([]ICreateTableItemContext)

	// Getter signatures
	AllCreateTableItem() []ICreateTableItemContext
	CreateTableItem(i int) ICreateTableItemContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsCreateTableItemsContext differentiates from other interfaces.
	IsCreateTableItemsContext()
}

type CreateTableItemsContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_createTableItem     ICreateTableItemContext
	columnItemCollection []ICreateTableItemContext
}

func NewEmptyCreateTableItemsContext() *CreateTableItemsContext {
	var p = new(CreateTableItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableItems
	return p
}

func InitEmptyCreateTableItemsContext(p *CreateTableItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableItems
}

func (*CreateTableItemsContext) IsCreateTableItemsContext() {}

func NewCreateTableItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableItemsContext {
	var p = new(CreateTableItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createTableItems

	return p
}

func (s *CreateTableItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableItemsContext) Get_createTableItem() ICreateTableItemContext {
	return s._createTableItem
}

func (s *CreateTableItemsContext) Set_createTableItem(v ICreateTableItemContext) {
	s._createTableItem = v
}

func (s *CreateTableItemsContext) GetColumnItemCollection() []ICreateTableItemContext {
	return s.columnItemCollection
}

func (s *CreateTableItemsContext) SetColumnItemCollection(v []ICreateTableItemContext) {
	s.columnItemCollection = v
}

func (s *CreateTableItemsContext) AllCreateTableItem() []ICreateTableItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableItemContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableItemContext); ok {
			tst[i] = t.(ICreateTableItemContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableItemsContext) CreateTableItem(i int) ICreateTableItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableItemContext)
}

func (s *CreateTableItemsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *CreateTableItemsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *CreateTableItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateTableItems(s)
	}
}

func (s *CreateTableItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateTableItems(s)
	}
}

func (p *UniversalParser) CreateTableItems() (localctx ICreateTableItemsContext) {
	localctx = NewCreateTableItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, UniversalParserRULE_createTableItems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)

		var _x = p.CreateTableItem()

		localctx.(*CreateTableItemsContext)._createTableItem = _x
	}
	localctx.(*CreateTableItemsContext).columnItemCollection = append(localctx.(*CreateTableItemsContext).columnItemCollection, localctx.(*CreateTableItemsContext)._createTableItem)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(622)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)

			var _x = p.CreateTableItem()

			localctx.(*CreateTableItemsContext)._createTableItem = _x
		}
		localctx.(*CreateTableItemsContext).columnItemCollection = append(localctx.(*CreateTableItemsContext).columnItemCollection, localctx.(*CreateTableItemsContext)._createTableItem)

		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableItemContext is an interface to support dynamic dispatch.
type ICreateTableItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// GetColumnType returns the columnType rule contexts.
	GetColumnType() IDataTypeContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// SetColumnType sets the columnType rule contexts.
	SetColumnType(IDataTypeContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	NullOption() INullOptionContext
	DefaultOption() IDefaultOptionContext
	CommentSpec() ICommentSpecContext

	// IsCreateTableItemContext differentiates from other interfaces.
	IsCreateTableItemContext()
}

type CreateTableItemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName IIdentifierContext
	columnType IDataTypeContext
}

func NewEmptyCreateTableItemContext() *CreateTableItemContext {
	var p = new(CreateTableItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableItem
	return p
}

func InitEmptyCreateTableItemContext(p *CreateTableItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createTableItem
}

func (*CreateTableItemContext) IsCreateTableItemContext() {}

func NewCreateTableItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableItemContext {
	var p = new(CreateTableItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createTableItem

	return p
}

func (s *CreateTableItemContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableItemContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *CreateTableItemContext) GetColumnType() IDataTypeContext { return s.columnType }

func (s *CreateTableItemContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *CreateTableItemContext) SetColumnType(v IDataTypeContext) { s.columnType = v }

func (s *CreateTableItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableItemContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateTableItemContext) NullOption() INullOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullOptionContext)
}

func (s *CreateTableItemContext) DefaultOption() IDefaultOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultOptionContext)
}

func (s *CreateTableItemContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateTableItem(s)
	}
}

func (s *CreateTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateTableItem(s)
	}
}

func (p *UniversalParser) CreateTableItem() (localctx ICreateTableItemContext) {
	localctx = NewCreateTableItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, UniversalParserRULE_createTableItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)

		var _x = p.Identifier()

		localctx.(*CreateTableItemContext).columnName = _x
	}
	{
		p.SetState(630)

		var _x = p.DataType()

		localctx.(*CreateTableItemContext).columnType = _x
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NOT || _la == UniversalParserT_NULL {
		{
			p.SetState(631)
			p.NullOption()
		}

	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_DEFAULT {
		{
			p.SetState(634)
			p.DefaultOption()
		}

	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(637)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePartitionSpecContext is an interface to support dynamic dispatch.
type ITablePartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITIONED() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	PartitionItems() IPartitionItemsContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsTablePartitionSpecContext differentiates from other interfaces.
	IsTablePartitionSpecContext()
}

type TablePartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePartitionSpecContext() *TablePartitionSpecContext {
	var p = new(TablePartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tablePartitionSpec
	return p
}

func InitEmptyTablePartitionSpecContext(p *TablePartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tablePartitionSpec
}

func (*TablePartitionSpecContext) IsTablePartitionSpecContext() {}

func NewTablePartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePartitionSpecContext {
	var p = new(TablePartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_tablePartitionSpec

	return p
}

func (s *TablePartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePartitionSpecContext) T_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITIONED, 0)
}

func (s *TablePartitionSpecContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *TablePartitionSpecContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *TablePartitionSpecContext) PartitionItems() IPartitionItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionItemsContext)
}

func (s *TablePartitionSpecContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *TablePartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTablePartitionSpec(s)
	}
}

func (s *TablePartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTablePartitionSpec(s)
	}
}

func (p *UniversalParser) TablePartitionSpec() (localctx ITablePartitionSpecContext) {
	localctx = NewTablePartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, UniversalParserRULE_tablePartitionSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(UniversalParserT_PARTITIONED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(642)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.PartitionItems()
	}
	{
		p.SetState(644)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionItemsContext is an interface to support dynamic dispatch.
type IPartitionItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionItem() []IPartitionItemContext
	PartitionItem(i int) IPartitionItemContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsPartitionItemsContext differentiates from other interfaces.
	IsPartitionItemsContext()
}

type PartitionItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionItemsContext() *PartitionItemsContext {
	var p = new(PartitionItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionItems
	return p
}

func InitEmptyPartitionItemsContext(p *PartitionItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionItems
}

func (*PartitionItemsContext) IsPartitionItemsContext() {}

func NewPartitionItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionItemsContext {
	var p = new(PartitionItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_partitionItems

	return p
}

func (s *PartitionItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionItemsContext) AllPartitionItem() []IPartitionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionItemContext); ok {
			len++
		}
	}

	tst := make([]IPartitionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionItemContext); ok {
			tst[i] = t.(IPartitionItemContext)
			i++
		}
	}

	return tst
}

func (s *PartitionItemsContext) PartitionItem(i int) IPartitionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionItemContext)
}

func (s *PartitionItemsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *PartitionItemsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *PartitionItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPartitionItems(s)
	}
}

func (s *PartitionItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPartitionItems(s)
	}
}

func (p *UniversalParser) PartitionItems() (localctx IPartitionItemsContext) {
	localctx = NewPartitionItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, UniversalParserRULE_partitionItems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.PartitionItem()
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(647)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(648)
			p.PartitionItem()
		}

		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionItemContext is an interface to support dynamic dispatch.
type IPartitionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// GetTableColumnType returns the tableColumnType rule contexts.
	GetTableColumnType() IDataTypeContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// SetTableColumnType sets the tableColumnType rule contexts.
	SetTableColumnType(IDataTypeContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext

	// IsPartitionItemContext differentiates from other interfaces.
	IsPartitionItemContext()
}

type PartitionItemContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	columnName      IIdentifierContext
	tableColumnType IDataTypeContext
}

func NewEmptyPartitionItemContext() *PartitionItemContext {
	var p = new(PartitionItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionItem
	return p
}

func InitEmptyPartitionItemContext(p *PartitionItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionItem
}

func (*PartitionItemContext) IsPartitionItemContext() {}

func NewPartitionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionItemContext {
	var p = new(PartitionItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_partitionItem

	return p
}

func (s *PartitionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionItemContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *PartitionItemContext) GetTableColumnType() IDataTypeContext { return s.tableColumnType }

func (s *PartitionItemContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *PartitionItemContext) SetTableColumnType(v IDataTypeContext) { s.tableColumnType = v }

func (s *PartitionItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionItemContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *PartitionItemContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *PartitionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPartitionItem(s)
	}
}

func (s *PartitionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPartitionItem(s)
	}
}

func (p *UniversalParser) PartitionItem() (localctx IPartitionItemContext) {
	localctx = NewPartitionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, UniversalParserRULE_partitionItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)

		var _x = p.Identifier()

		localctx.(*PartitionItemContext).columnName = _x
	}
	{
		p.SetState(655)

		var _x = p.DataType()

		localctx.(*PartitionItemContext).tableColumnType = _x
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(656)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortSpecContext is an interface to support dynamic dispatch.
type ISortSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClusterBy() IClusterByContext
	SortBy() ISortByContext
	BucketsOption() IBucketsOptionContext

	// IsSortSpecContext differentiates from other interfaces.
	IsSortSpecContext()
}

type SortSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortSpecContext() *SortSpecContext {
	var p = new(SortSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortSpec
	return p
}

func InitEmptySortSpecContext(p *SortSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortSpec
}

func (*SortSpecContext) IsSortSpecContext() {}

func NewSortSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortSpecContext {
	var p = new(SortSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sortSpec

	return p
}

func (s *SortSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SortSpecContext) ClusterBy() IClusterByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByContext)
}

func (s *SortSpecContext) SortBy() ISortByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByContext)
}

func (s *SortSpecContext) BucketsOption() IBucketsOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBucketsOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBucketsOptionContext)
}

func (s *SortSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSortSpec(s)
	}
}

func (s *SortSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSortSpec(s)
	}
}

func (p *UniversalParser) SortSpec() (localctx ISortSpecContext) {
	localctx = NewSortSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, UniversalParserRULE_sortSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.ClusterBy()
	}
	{
		p.SetState(660)
		p.SortBy()
	}
	{
		p.SetState(661)
		p.BucketsOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkewedBySpecContext is an interface to support dynamic dispatch.
type ISkewedBySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SKEWED() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	SkewedByColumns() ISkewedByColumnsContext
	T_ON() antlr.TerminalNode
	SkewedByValues() ISkewedByValuesContext
	StorageDirectories() IStorageDirectoriesContext

	// IsSkewedBySpecContext differentiates from other interfaces.
	IsSkewedBySpecContext()
}

type SkewedBySpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedBySpecContext() *SkewedBySpecContext {
	var p = new(SkewedBySpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedBySpec
	return p
}

func InitEmptySkewedBySpecContext(p *SkewedBySpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedBySpec
}

func (*SkewedBySpecContext) IsSkewedBySpecContext() {}

func NewSkewedBySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedBySpecContext {
	var p = new(SkewedBySpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_skewedBySpec

	return p
}

func (s *SkewedBySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedBySpecContext) T_SKEWED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SKEWED, 0)
}

func (s *SkewedBySpecContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *SkewedBySpecContext) SkewedByColumns() ISkewedByColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedByColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedByColumnsContext)
}

func (s *SkewedBySpecContext) T_ON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ON, 0)
}

func (s *SkewedBySpecContext) SkewedByValues() ISkewedByValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkewedByValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkewedByValuesContext)
}

func (s *SkewedBySpecContext) StorageDirectories() IStorageDirectoriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageDirectoriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageDirectoriesContext)
}

func (s *SkewedBySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedBySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkewedBySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSkewedBySpec(s)
	}
}

func (s *SkewedBySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSkewedBySpec(s)
	}
}

func (p *UniversalParser) SkewedBySpec() (localctx ISkewedBySpecContext) {
	localctx = NewSkewedBySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, UniversalParserRULE_skewedBySpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(UniversalParserT_SKEWED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(664)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(665)
		p.SkewedByColumns()
	}
	{
		p.SetState(666)
		p.Match(UniversalParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)
		p.SkewedByValues()
	}
	p.SetState(669)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(668)
			p.StorageDirectories()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkewedByColumnsContext is an interface to support dynamic dispatch.
type ISkewedByColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSeqs() IExpressionSeqsContext

	// IsSkewedByColumnsContext differentiates from other interfaces.
	IsSkewedByColumnsContext()
}

type SkewedByColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedByColumnsContext() *SkewedByColumnsContext {
	var p = new(SkewedByColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedByColumns
	return p
}

func InitEmptySkewedByColumnsContext(p *SkewedByColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedByColumns
}

func (*SkewedByColumnsContext) IsSkewedByColumnsContext() {}

func NewSkewedByColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedByColumnsContext {
	var p = new(SkewedByColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_skewedByColumns

	return p
}

func (s *SkewedByColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedByColumnsContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *SkewedByColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedByColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkewedByColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSkewedByColumns(s)
	}
}

func (s *SkewedByColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSkewedByColumns(s)
	}
}

func (p *UniversalParser) SkewedByColumns() (localctx ISkewedByColumnsContext) {
	localctx = NewSkewedByColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, UniversalParserRULE_skewedByColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.ExpressionSeqs()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkewedByValuesContext is an interface to support dynamic dispatch.
type ISkewedByValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiSkewedValue() IMultiSkewedValueContext
	SimpleValue() ISimpleValueContext

	// IsSkewedByValuesContext differentiates from other interfaces.
	IsSkewedByValuesContext()
}

type SkewedByValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkewedByValuesContext() *SkewedByValuesContext {
	var p = new(SkewedByValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedByValues
	return p
}

func InitEmptySkewedByValuesContext(p *SkewedByValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_skewedByValues
}

func (*SkewedByValuesContext) IsSkewedByValuesContext() {}

func NewSkewedByValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkewedByValuesContext {
	var p = new(SkewedByValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_skewedByValues

	return p
}

func (s *SkewedByValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkewedByValuesContext) MultiSkewedValue() IMultiSkewedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiSkewedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiSkewedValueContext)
}

func (s *SkewedByValuesContext) SimpleValue() ISimpleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleValueContext)
}

func (s *SkewedByValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkewedByValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkewedByValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSkewedByValues(s)
	}
}

func (s *SkewedByValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSkewedByValues(s)
	}
}

func (p *UniversalParser) SkewedByValues() (localctx ISkewedByValuesContext) {
	localctx = NewSkewedByValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, UniversalParserRULE_skewedByValues)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.MultiSkewedValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.SimpleValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiSkewedValueContext is an interface to support dynamic dispatch.
type IMultiSkewedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	AllSimpleValue() []ISimpleValueContext
	SimpleValue(i int) ISimpleValueContext
	K_CLOSE_PAREN() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsMultiSkewedValueContext differentiates from other interfaces.
	IsMultiSkewedValueContext()
}

type MultiSkewedValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiSkewedValueContext() *MultiSkewedValueContext {
	var p = new(MultiSkewedValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiSkewedValue
	return p
}

func InitEmptyMultiSkewedValueContext(p *MultiSkewedValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiSkewedValue
}

func (*MultiSkewedValueContext) IsMultiSkewedValueContext() {}

func NewMultiSkewedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiSkewedValueContext {
	var p = new(MultiSkewedValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_multiSkewedValue

	return p
}

func (s *MultiSkewedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiSkewedValueContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *MultiSkewedValueContext) AllSimpleValue() []ISimpleValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleValueContext); ok {
			len++
		}
	}

	tst := make([]ISimpleValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleValueContext); ok {
			tst[i] = t.(ISimpleValueContext)
			i++
		}
	}

	return tst
}

func (s *MultiSkewedValueContext) SimpleValue(i int) ISimpleValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleValueContext)
}

func (s *MultiSkewedValueContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *MultiSkewedValueContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *MultiSkewedValueContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *MultiSkewedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiSkewedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiSkewedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiSkewedValue(s)
	}
}

func (s *MultiSkewedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiSkewedValue(s)
	}
}

func (p *UniversalParser) MultiSkewedValue() (localctx IMultiSkewedValueContext) {
	localctx = NewMultiSkewedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, UniversalParserRULE_multiSkewedValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(678)
		p.SimpleValue()
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(679)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)
			p.SimpleValue()
		}

		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(686)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleValueContext is an interface to support dynamic dispatch.
type ISimpleValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSeqs() IExpressionSeqsContext

	// IsSimpleValueContext differentiates from other interfaces.
	IsSimpleValueContext()
}

type SimpleValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleValueContext() *SimpleValueContext {
	var p = new(SimpleValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_simpleValue
	return p
}

func InitEmptySimpleValueContext(p *SimpleValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_simpleValue
}

func (*SimpleValueContext) IsSimpleValueContext() {}

func NewSimpleValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleValueContext {
	var p = new(SimpleValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_simpleValue

	return p
}

func (s *SimpleValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleValueContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *SimpleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSimpleValue(s)
	}
}

func (s *SimpleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSimpleValue(s)
	}
}

func (p *UniversalParser) SimpleValue() (localctx ISimpleValueContext) {
	localctx = NewSimpleValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, UniversalParserRULE_simpleValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.ExpressionSeqs()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageDirectoriesContext is an interface to support dynamic dispatch.
type IStorageDirectoriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_DIRECTORIES() antlr.TerminalNode

	// IsStorageDirectoriesContext differentiates from other interfaces.
	IsStorageDirectoriesContext()
}

type StorageDirectoriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageDirectoriesContext() *StorageDirectoriesContext {
	var p = new(StorageDirectoriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storageDirectories
	return p
}

func InitEmptyStorageDirectoriesContext(p *StorageDirectoriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storageDirectories
}

func (*StorageDirectoriesContext) IsStorageDirectoriesContext() {}

func NewStorageDirectoriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageDirectoriesContext {
	var p = new(StorageDirectoriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_storageDirectories

	return p
}

func (s *StorageDirectoriesContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageDirectoriesContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORED, 0)
}

func (s *StorageDirectoriesContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *StorageDirectoriesContext) T_DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIRECTORIES, 0)
}

func (s *StorageDirectoriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageDirectoriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageDirectoriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStorageDirectories(s)
	}
}

func (s *StorageDirectoriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStorageDirectories(s)
	}
}

func (p *UniversalParser) StorageDirectories() (localctx IStorageDirectoriesContext) {
	localctx = NewStorageDirectoriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, UniversalParserRULE_storageDirectories)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(UniversalParserT_STORED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(691)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(692)
		p.Match(UniversalParserT_DIRECTORIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatSpecContext is an interface to support dynamic dispatch.
type IFormatSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRowFormat() ITableRowFormatContext
	StoredBy() IStoredByContext

	// IsFormatSpecContext differentiates from other interfaces.
	IsFormatSpecContext()
}

type FormatSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormatSpecContext() *FormatSpecContext {
	var p = new(FormatSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_formatSpec
	return p
}

func InitEmptyFormatSpecContext(p *FormatSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_formatSpec
}

func (*FormatSpecContext) IsFormatSpecContext() {}

func NewFormatSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatSpecContext {
	var p = new(FormatSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_formatSpec

	return p
}

func (s *FormatSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatSpecContext) TableRowFormat() ITableRowFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowFormatContext)
}

func (s *FormatSpecContext) StoredBy() IStoredByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStoredByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStoredByContext)
}

func (s *FormatSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFormatSpec(s)
	}
}

func (s *FormatSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFormatSpec(s)
	}
}

func (p *UniversalParser) FormatSpec() (localctx IFormatSpecContext) {
	localctx = NewFormatSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, UniversalParserRULE_formatSpec)
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_ROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.TableRowFormat()
		}

	case UniversalParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(695)
			p.StoredBy()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRowFormatContext is an interface to support dynamic dispatch.
type ITableRowFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RowFormat() IRowFormatContext
	StoredSpec() IStoredSpecContext

	// IsTableRowFormatContext differentiates from other interfaces.
	IsTableRowFormatContext()
}

type TableRowFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowFormatContext() *TableRowFormatContext {
	var p = new(TableRowFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableRowFormat
	return p
}

func InitEmptyTableRowFormatContext(p *TableRowFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableRowFormat
}

func (*TableRowFormatContext) IsTableRowFormatContext() {}

func NewTableRowFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowFormatContext {
	var p = new(TableRowFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_tableRowFormat

	return p
}

func (s *TableRowFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowFormatContext) RowFormat() IRowFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowFormatContext)
}

func (s *TableRowFormatContext) StoredSpec() IStoredSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStoredSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStoredSpecContext)
}

func (s *TableRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTableRowFormat(s)
	}
}

func (s *TableRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTableRowFormat(s)
	}
}

func (p *UniversalParser) TableRowFormat() (localctx ITableRowFormatContext) {
	localctx = NewTableRowFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, UniversalParserRULE_tableRowFormat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.RowFormat()
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_STORED {
		{
			p.SetState(699)
			p.StoredSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStoredByContext is an interface to support dynamic dispatch.
type IStoredByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClassName returns the className rule contexts.
	GetClassName() IExpressionContext

	// SetClassName sets the className rule contexts.
	SetClassName(IExpressionContext)

	// Getter signatures
	T_STORED() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	SerdeProperties() ISerdePropertiesContext
	Expression() IExpressionContext

	// IsStoredByContext differentiates from other interfaces.
	IsStoredByContext()
}

type StoredByContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	className IExpressionContext
}

func NewEmptyStoredByContext() *StoredByContext {
	var p = new(StoredByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storedBy
	return p
}

func InitEmptyStoredByContext(p *StoredByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storedBy
}

func (*StoredByContext) IsStoredByContext() {}

func NewStoredByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StoredByContext {
	var p = new(StoredByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_storedBy

	return p
}

func (s *StoredByContext) GetParser() antlr.Parser { return s.parser }

func (s *StoredByContext) GetClassName() IExpressionContext { return s.className }

func (s *StoredByContext) SetClassName(v IExpressionContext) { s.className = v }

func (s *StoredByContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORED, 0)
}

func (s *StoredByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *StoredByContext) SerdeProperties() ISerdePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISerdePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISerdePropertiesContext)
}

func (s *StoredByContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StoredByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StoredByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StoredByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStoredBy(s)
	}
}

func (s *StoredByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStoredBy(s)
	}
}

func (p *UniversalParser) StoredBy() (localctx IStoredByContext) {
	localctx = NewStoredByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, UniversalParserRULE_storedBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(UniversalParserT_STORED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(704)

		var _x = p.Expression()

		localctx.(*StoredByContext).className = _x
	}
	{
		p.SetState(705)
		p.SerdeProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISerdePropertiesContext is an interface to support dynamic dispatch.
type ISerdePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_SERDEPROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSerdePropertiesContext differentiates from other interfaces.
	IsSerdePropertiesContext()
}

type SerdePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerdePropertiesContext() *SerdePropertiesContext {
	var p = new(SerdePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_serdeProperties
	return p
}

func InitEmptySerdePropertiesContext(p *SerdePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_serdeProperties
}

func (*SerdePropertiesContext) IsSerdePropertiesContext() {}

func NewSerdePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerdePropertiesContext {
	var p = new(SerdePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_serdeProperties

	return p
}

func (s *SerdePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *SerdePropertiesContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *SerdePropertiesContext) T_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDEPROPERTIES, 0)
}

func (s *SerdePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SerdePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerdePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerdePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSerdeProperties(s)
	}
}

func (s *SerdePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSerdeProperties(s)
	}
}

func (p *UniversalParser) SerdeProperties() (localctx ISerdePropertiesContext) {
	localctx = NewSerdePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, UniversalParserRULE_serdeProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.Match(UniversalParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(708)
		p.Match(UniversalParserT_SERDEPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStoredSpecContext is an interface to support dynamic dispatch.
type IStoredSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	FormatType() IFormatTypeContext

	// IsStoredSpecContext differentiates from other interfaces.
	IsStoredSpecContext()
}

type StoredSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStoredSpecContext() *StoredSpecContext {
	var p = new(StoredSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storedSpec
	return p
}

func InitEmptyStoredSpecContext(p *StoredSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storedSpec
}

func (*StoredSpecContext) IsStoredSpecContext() {}

func NewStoredSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StoredSpecContext {
	var p = new(StoredSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_storedSpec

	return p
}

func (s *StoredSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *StoredSpecContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORED, 0)
}

func (s *StoredSpecContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *StoredSpecContext) FormatType() IFormatTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatTypeContext)
}

func (s *StoredSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StoredSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StoredSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStoredSpec(s)
	}
}

func (s *StoredSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStoredSpec(s)
	}
}

func (p *UniversalParser) StoredSpec() (localctx IStoredSpecContext) {
	localctx = NewStoredSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, UniversalParserRULE_storedSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Match(UniversalParserT_STORED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(712)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(713)
		p.FormatType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatTypeContext is an interface to support dynamic dispatch.
type IFormatTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInputFormatClassname returns the inputFormatClassname rule contexts.
	GetInputFormatClassname() IExpressionContext

	// GetOutputFormatClassname returns the outputFormatClassname rule contexts.
	GetOutputFormatClassname() IExpressionContext

	// SetInputFormatClassname sets the inputFormatClassname rule contexts.
	SetInputFormatClassname(IExpressionContext)

	// SetOutputFormatClassname sets the outputFormatClassname rule contexts.
	SetOutputFormatClassname(IExpressionContext)

	// Getter signatures
	T_SEQUENCEFILE() antlr.TerminalNode
	T_TEXTFILE() antlr.TerminalNode
	T_RCFILE() antlr.TerminalNode
	T_ORC() antlr.TerminalNode
	T_PARQUET() antlr.TerminalNode
	T_AVRO() antlr.TerminalNode
	T_JSONFILE() antlr.TerminalNode
	T_INPUTFORMAT() antlr.TerminalNode
	T_OUTPUTFORMAT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsFormatTypeContext differentiates from other interfaces.
	IsFormatTypeContext()
}

type FormatTypeContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	inputFormatClassname  IExpressionContext
	outputFormatClassname IExpressionContext
}

func NewEmptyFormatTypeContext() *FormatTypeContext {
	var p = new(FormatTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_formatType
	return p
}

func InitEmptyFormatTypeContext(p *FormatTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_formatType
}

func (*FormatTypeContext) IsFormatTypeContext() {}

func NewFormatTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatTypeContext {
	var p = new(FormatTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_formatType

	return p
}

func (s *FormatTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatTypeContext) GetInputFormatClassname() IExpressionContext {
	return s.inputFormatClassname
}

func (s *FormatTypeContext) GetOutputFormatClassname() IExpressionContext {
	return s.outputFormatClassname
}

func (s *FormatTypeContext) SetInputFormatClassname(v IExpressionContext) { s.inputFormatClassname = v }

func (s *FormatTypeContext) SetOutputFormatClassname(v IExpressionContext) {
	s.outputFormatClassname = v
}

func (s *FormatTypeContext) T_SEQUENCEFILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEQUENCEFILE, 0)
}

func (s *FormatTypeContext) T_TEXTFILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TEXTFILE, 0)
}

func (s *FormatTypeContext) T_RCFILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RCFILE, 0)
}

func (s *FormatTypeContext) T_ORC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ORC, 0)
}

func (s *FormatTypeContext) T_PARQUET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARQUET, 0)
}

func (s *FormatTypeContext) T_AVRO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AVRO, 0)
}

func (s *FormatTypeContext) T_JSONFILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSONFILE, 0)
}

func (s *FormatTypeContext) T_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INPUTFORMAT, 0)
}

func (s *FormatTypeContext) T_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUTPUTFORMAT, 0)
}

func (s *FormatTypeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FormatTypeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FormatTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFormatType(s)
	}
}

func (s *FormatTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFormatType(s)
	}
}

func (p *UniversalParser) FormatType() (localctx IFormatTypeContext) {
	localctx = NewFormatTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, UniversalParserRULE_formatType)
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_SEQUENCEFILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(715)
			p.Match(UniversalParserT_SEQUENCEFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_TEXTFILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.Match(UniversalParserT_TEXTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_RCFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(717)
			p.Match(UniversalParserT_RCFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_ORC:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(718)
			p.Match(UniversalParserT_ORC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_PARQUET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(719)
			p.Match(UniversalParserT_PARQUET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_AVRO:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(720)
			p.Match(UniversalParserT_AVRO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_JSONFILE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(721)
			p.Match(UniversalParserT_JSONFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_INPUTFORMAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(722)
			p.Match(UniversalParserT_INPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(723)

			var _x = p.Expression()

			localctx.(*FormatTypeContext).inputFormatClassname = _x
		}
		{
			p.SetState(724)
			p.Match(UniversalParserT_OUTPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(725)

			var _x = p.Expression()

			localctx.(*FormatTypeContext).outputFormatClassname = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesSpecContext is an interface to support dynamic dispatch.
type IPropertiesSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TBLPROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsPropertiesSpecContext differentiates from other interfaces.
	IsPropertiesSpecContext()
}

type PropertiesSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesSpecContext() *PropertiesSpecContext {
	var p = new(PropertiesSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertiesSpec
	return p
}

func InitEmptyPropertiesSpecContext(p *PropertiesSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertiesSpec
}

func (*PropertiesSpecContext) IsPropertiesSpecContext() {}

func NewPropertiesSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesSpecContext {
	var p = new(PropertiesSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_propertiesSpec

	return p
}

func (s *PropertiesSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesSpecContext) T_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TBLPROPERTIES, 0)
}

func (s *PropertiesSpecContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *PropertiesSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPropertiesSpec(s)
	}
}

func (s *PropertiesSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPropertiesSpec(s)
	}
}

func (p *UniversalParser) PropertiesSpec() (localctx IPropertiesSpecContext) {
	localctx = NewPropertiesSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, UniversalParserRULE_propertiesSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(UniversalParserT_TBLPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(730)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSelectSpecContext is an interface to support dynamic dispatch.
type ITableSelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AS() antlr.TerminalNode
	Query() IQueryContext

	// IsTableSelectSpecContext differentiates from other interfaces.
	IsTableSelectSpecContext()
}

type TableSelectSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSelectSpecContext() *TableSelectSpecContext {
	var p = new(TableSelectSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableSelectSpec
	return p
}

func InitEmptyTableSelectSpecContext(p *TableSelectSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableSelectSpec
}

func (*TableSelectSpecContext) IsTableSelectSpecContext() {}

func NewTableSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSelectSpecContext {
	var p = new(TableSelectSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_tableSelectSpec

	return p
}

func (s *TableSelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSelectSpecContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *TableSelectSpecContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *TableSelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTableSelectSpec(s)
	}
}

func (s *TableSelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTableSelectSpec(s)
	}
}

func (p *UniversalParser) TableSelectSpec() (localctx ITableSelectSpecContext) {
	localctx = NewTableSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, UniversalParserRULE_tableSelectSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(733)
		p.Query()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILifecycleSpecContext is an interface to support dynamic dispatch.
type ILifecycleSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDays returns the days rule contexts.
	GetDays() INumberContext

	// SetDays sets the days rule contexts.
	SetDays(INumberContext)

	// Getter signatures
	T_LIFECYCLE() antlr.TerminalNode
	Number() INumberContext

	// IsLifecycleSpecContext differentiates from other interfaces.
	IsLifecycleSpecContext()
}

type LifecycleSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	days   INumberContext
}

func NewEmptyLifecycleSpecContext() *LifecycleSpecContext {
	var p = new(LifecycleSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lifecycleSpec
	return p
}

func InitEmptyLifecycleSpecContext(p *LifecycleSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lifecycleSpec
}

func (*LifecycleSpecContext) IsLifecycleSpecContext() {}

func NewLifecycleSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LifecycleSpecContext {
	var p = new(LifecycleSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_lifecycleSpec

	return p
}

func (s *LifecycleSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *LifecycleSpecContext) GetDays() INumberContext { return s.days }

func (s *LifecycleSpecContext) SetDays(v INumberContext) { s.days = v }

func (s *LifecycleSpecContext) T_LIFECYCLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIFECYCLE, 0)
}

func (s *LifecycleSpecContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *LifecycleSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LifecycleSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LifecycleSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLifecycleSpec(s)
	}
}

func (s *LifecycleSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLifecycleSpec(s)
	}
}

func (p *UniversalParser) LifecycleSpec() (localctx ILifecycleSpecContext) {
	localctx = NewLifecycleSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, UniversalParserRULE_lifecycleSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(735)
		p.Match(UniversalParserT_LIFECYCLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(736)

		var _x = p.Number()

		localctx.(*LifecycleSpecContext).days = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertQueryStatementContext is an interface to support dynamic dispatch.
type IInsertQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertInto() IInsertIntoContext
	Query() IQueryContext
	Cte() ICteContext

	// IsInsertQueryStatementContext differentiates from other interfaces.
	IsInsertQueryStatementContext()
}

type InsertQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertQueryStatementContext() *InsertQueryStatementContext {
	var p = new(InsertQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertQueryStatement
	return p
}

func InitEmptyInsertQueryStatementContext(p *InsertQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertQueryStatement
}

func (*InsertQueryStatementContext) IsInsertQueryStatementContext() {}

func NewInsertQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertQueryStatementContext {
	var p = new(InsertQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_insertQueryStatement

	return p
}

func (s *InsertQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertQueryStatementContext) InsertInto() IInsertIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIntoContext)
}

func (s *InsertQueryStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertQueryStatementContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *InsertQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertQueryStatement(s)
	}
}

func (s *InsertQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertQueryStatement(s)
	}
}

func (p *UniversalParser) InsertQueryStatement() (localctx IInsertQueryStatementContext) {
	localctx = NewInsertQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, UniversalParserRULE_insertQueryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_WITH {
		{
			p.SetState(738)
			p.Cte()
		}

	}
	{
		p.SetState(741)
		p.InsertInto()
	}
	{
		p.SetState(742)
		p.Query()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertValueStatementContext is an interface to support dynamic dispatch.
type IInsertValueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertInto() IInsertIntoContext
	InsertValues() IInsertValuesContext

	// IsInsertValueStatementContext differentiates from other interfaces.
	IsInsertValueStatementContext()
}

type InsertValueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValueStatementContext() *InsertValueStatementContext {
	var p = new(InsertValueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertValueStatement
	return p
}

func InitEmptyInsertValueStatementContext(p *InsertValueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertValueStatement
}

func (*InsertValueStatementContext) IsInsertValueStatementContext() {}

func NewInsertValueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValueStatementContext {
	var p = new(InsertValueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_insertValueStatement

	return p
}

func (s *InsertValueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValueStatementContext) InsertInto() IInsertIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIntoContext)
}

func (s *InsertValueStatementContext) InsertValues() IInsertValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValuesContext)
}

func (s *InsertValueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertValueStatement(s)
	}
}

func (s *InsertValueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertValueStatement(s)
	}
}

func (p *UniversalParser) InsertValueStatement() (localctx IInsertValueStatementContext) {
	localctx = NewInsertValueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, UniversalParserRULE_insertValueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.InsertInto()
	}
	{
		p.SetState(745)
		p.InsertValues()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTablePartitionsContext is an interface to support dynamic dispatch.
type IDropTablePartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	T_DROP() antlr.TerminalNode
	IfOption() IIfOptionContext
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext
	T_TABLE() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode
	T_PURGE() antlr.TerminalNode

	// IsDropTablePartitionsContext differentiates from other interfaces.
	IsDropTablePartitionsContext()
}

type DropTablePartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTablePartitionsContext() *DropTablePartitionsContext {
	var p = new(DropTablePartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropTablePartitions
	return p
}

func InitEmptyDropTablePartitionsContext(p *DropTablePartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dropTablePartitions
}

func (*DropTablePartitionsContext) IsDropTablePartitionsContext() {}

func NewDropTablePartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTablePartitionsContext {
	var p = new(DropTablePartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dropTablePartitions

	return p
}

func (s *DropTablePartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTablePartitionsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *DropTablePartitionsContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *DropTablePartitionsContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *DropTablePartitionsContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *DropTablePartitionsContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *DropTablePartitionsContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropTablePartitionsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *DropTablePartitionsContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *DropTablePartitionsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *DropTablePartitionsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *DropTablePartitionsContext) T_PURGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PURGE, 0)
}

func (s *DropTablePartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablePartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTablePartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDropTablePartitions(s)
	}
}

func (s *DropTablePartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDropTablePartitions(s)
	}
}

func (p *UniversalParser) DropTablePartitions() (localctx IDropTablePartitionsContext) {
	localctx = NewDropTablePartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, UniversalParserRULE_dropTablePartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(748)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_TABLE || _la == UniversalParserT_VIEW) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(749)
		p.MultiIdentifier()
	}
	{
		p.SetState(750)
		p.Match(UniversalParserT_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(751)
		p.IfOption()
	}
	{
		p.SetState(752)
		p.PartitionSpec()
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(753)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.PartitionSpec()
		}

		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_PURGE {
		{
			p.SetState(760)
			p.Match(UniversalParserT_PURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddTablePartitionsContext is an interface to support dynamic dispatch.
type IAddTablePartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	T_ADD() antlr.TerminalNode
	IfOption() IIfOptionContext
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext
	T_TABLE() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsAddTablePartitionsContext differentiates from other interfaces.
	IsAddTablePartitionsContext()
}

type AddTablePartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddTablePartitionsContext() *AddTablePartitionsContext {
	var p = new(AddTablePartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_addTablePartitions
	return p
}

func InitEmptyAddTablePartitionsContext(p *AddTablePartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_addTablePartitions
}

func (*AddTablePartitionsContext) IsAddTablePartitionsContext() {}

func NewAddTablePartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddTablePartitionsContext {
	var p = new(AddTablePartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_addTablePartitions

	return p
}

func (s *AddTablePartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AddTablePartitionsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *AddTablePartitionsContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *AddTablePartitionsContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ADD, 0)
}

func (s *AddTablePartitionsContext) IfOption() IIfOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfOptionContext)
}

func (s *AddTablePartitionsContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *AddTablePartitionsContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AddTablePartitionsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *AddTablePartitionsContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *AddTablePartitionsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *AddTablePartitionsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *AddTablePartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddTablePartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddTablePartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterAddTablePartitions(s)
	}
}

func (s *AddTablePartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitAddTablePartitions(s)
	}
}

func (p *UniversalParser) AddTablePartitions() (localctx IAddTablePartitionsContext) {
	localctx = NewAddTablePartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, UniversalParserRULE_addTablePartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_TABLE || _la == UniversalParserT_VIEW) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(765)
		p.MultiIdentifier()
	}
	{
		p.SetState(766)
		p.Match(UniversalParserT_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.IfOption()
	}
	{
		p.SetState(768)
		p.PartitionSpec()
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(769)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(770)
			p.PartitionSpec()
		}

		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTablePartitionsContext is an interface to support dynamic dispatch.
type IRenameTablePartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	AllPartitionSpec() []IPartitionSpecContext
	PartitionSpec(i int) IPartitionSpecContext
	T_RENAME() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode

	// IsRenameTablePartitionsContext differentiates from other interfaces.
	IsRenameTablePartitionsContext()
}

type RenameTablePartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTablePartitionsContext() *RenameTablePartitionsContext {
	var p = new(RenameTablePartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_renameTablePartitions
	return p
}

func InitEmptyRenameTablePartitionsContext(p *RenameTablePartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_renameTablePartitions
}

func (*RenameTablePartitionsContext) IsRenameTablePartitionsContext() {}

func NewRenameTablePartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTablePartitionsContext {
	var p = new(RenameTablePartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_renameTablePartitions

	return p
}

func (s *RenameTablePartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTablePartitionsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *RenameTablePartitionsContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *RenameTablePartitionsContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *RenameTablePartitionsContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RenameTablePartitionsContext) T_RENAME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RENAME, 0)
}

func (s *RenameTablePartitionsContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *RenameTablePartitionsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *RenameTablePartitionsContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *RenameTablePartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTablePartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTablePartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRenameTablePartitions(s)
	}
}

func (s *RenameTablePartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRenameTablePartitions(s)
	}
}

func (p *UniversalParser) RenameTablePartitions() (localctx IRenameTablePartitionsContext) {
	localctx = NewRenameTablePartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, UniversalParserRULE_renameTablePartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(UniversalParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(777)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_TABLE || _la == UniversalParserT_VIEW) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(778)
		p.MultiIdentifier()
	}
	{
		p.SetState(779)
		p.PartitionSpec()
	}
	{
		p.SetState(780)
		p.Match(UniversalParserT_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Match(UniversalParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(782)
		p.PartitionSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertIntoContext is an interface to support dynamic dispatch.
type IInsertIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInsertIntoContext differentiates from other interfaces.
	IsInsertIntoContext()
}

type InsertIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertIntoContext() *InsertIntoContext {
	var p = new(InsertIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertInto
	return p
}

func InitEmptyInsertIntoContext(p *InsertIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertInto
}

func (*InsertIntoContext) IsInsertIntoContext() {}

func NewInsertIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertIntoContext {
	var p = new(InsertIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_insertInto

	return p
}

func (s *InsertIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertIntoContext) CopyAll(ctx *InsertIntoContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertOverwriteTableContext struct {
	InsertIntoContext
	table IMultiIdentifierContext
}

func NewInsertOverwriteTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteTableContext {
	var p = new(InsertOverwriteTableContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertOverwriteTableContext) GetTable() IMultiIdentifierContext { return s.table }

func (s *InsertOverwriteTableContext) SetTable(v IMultiIdentifierContext) { s.table = v }

func (s *InsertOverwriteTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteTableContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INSERT, 0)
}

func (s *InsertOverwriteTableContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OVERWRITE, 0)
}

func (s *InsertOverwriteTableContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *InsertOverwriteTableContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *InsertOverwriteTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertOverwriteTableContext) InsertTableColumns() IInsertTableColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertTableColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertTableColumnsContext)
}

func (s *InsertOverwriteTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertOverwriteTable(s)
	}
}

func (s *InsertOverwriteTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertOverwriteTable(s)
	}
}

type InsertIntoTableContext struct {
	InsertIntoContext
	table IMultiIdentifierContext
}

func NewInsertIntoTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoTableContext {
	var p = new(InsertIntoTableContext)

	InitEmptyInsertIntoContext(&p.InsertIntoContext)
	p.parser = parser
	p.CopyAll(ctx.(*InsertIntoContext))

	return p
}

func (s *InsertIntoTableContext) GetTable() IMultiIdentifierContext { return s.table }

func (s *InsertIntoTableContext) SetTable(v IMultiIdentifierContext) { s.table = v }

func (s *InsertIntoTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoTableContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INSERT, 0)
}

func (s *InsertIntoTableContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTO, 0)
}

func (s *InsertIntoTableContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *InsertIntoTableContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *InsertIntoTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertIntoTableContext) InsertTableColumns() IInsertTableColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertTableColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertTableColumnsContext)
}

func (s *InsertIntoTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertIntoTable(s)
	}
}

func (s *InsertIntoTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertIntoTable(s)
	}
}

func (p *UniversalParser) InsertInto() (localctx IInsertIntoContext) {
	localctx = NewInsertIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, UniversalParserRULE_insertInto)
	var _la int

	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertOverwriteTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.Match(UniversalParserT_INSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.Match(UniversalParserT_OVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(786)
				p.Match(UniversalParserT_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(789)

			var _x = p.MultiIdentifier()

			localctx.(*InsertOverwriteTableContext).table = _x
		}
		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_PARTITION {
			{
				p.SetState(790)
				p.PartitionSpec()
			}

		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(793)
				p.InsertTableColumns()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInsertIntoTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(796)
			p.Match(UniversalParserT_INSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(797)
			p.Match(UniversalParserT_INTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(798)
				p.Match(UniversalParserT_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(801)

			var _x = p.MultiIdentifier()

			localctx.(*InsertIntoTableContext).table = _x
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_PARTITION {
			{
				p.SetState(802)
				p.PartitionSpec()
			}

		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(805)
				p.InsertTableColumns()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertValuesContext is an interface to support dynamic dispatch.
type IInsertValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	AllDefaultExpression() []IDefaultExpressionContext
	DefaultExpression(i int) IDefaultExpressionContext
	K_CLOSE_PAREN() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsInsertValuesContext differentiates from other interfaces.
	IsInsertValuesContext()
}

type InsertValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesContext() *InsertValuesContext {
	var p = new(InsertValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertValues
	return p
}

func InitEmptyInsertValuesContext(p *InsertValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertValues
}

func (*InsertValuesContext) IsInsertValuesContext() {}

func NewInsertValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesContext {
	var p = new(InsertValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_insertValues

	return p
}

func (s *InsertValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VALUES, 0)
}

func (s *InsertValuesContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *InsertValuesContext) AllDefaultExpression() []IDefaultExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			len++
		}
	}

	tst := make([]IDefaultExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefaultExpressionContext); ok {
			tst[i] = t.(IDefaultExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InsertValuesContext) DefaultExpression(i int) IDefaultExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *InsertValuesContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *InsertValuesContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *InsertValuesContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

func (p *UniversalParser) InsertValues() (localctx IInsertValuesContext) {
	localctx = NewInsertValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, UniversalParserRULE_insertValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(UniversalParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(811)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)
		p.defaultExpression(0)
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(813)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.defaultExpression(0)
		}

		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(820)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertTableColumnsContext is an interface to support dynamic dispatch.
type IInsertTableColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsInsertTableColumnsContext differentiates from other interfaces.
	IsInsertTableColumnsContext()
}

type InsertTableColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertTableColumnsContext() *InsertTableColumnsContext {
	var p = new(InsertTableColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertTableColumns
	return p
}

func InitEmptyInsertTableColumnsContext(p *InsertTableColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_insertTableColumns
}

func (*InsertTableColumnsContext) IsInsertTableColumnsContext() {}

func NewInsertTableColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertTableColumnsContext {
	var p = new(InsertTableColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_insertTableColumns

	return p
}

func (s *InsertTableColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertTableColumnsContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *InsertTableColumnsContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *InsertTableColumnsContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *InsertTableColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertTableColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertTableColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInsertTableColumns(s)
	}
}

func (s *InsertTableColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInsertTableColumns(s)
	}
}

func (p *UniversalParser) InsertTableColumns() (localctx IInsertTableColumnsContext) {
	localctx = NewInsertTableColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, UniversalParserRULE_insertTableColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.IdentifierSeq()
	}
	{
		p.SetState(824)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITION() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	AllPartitionVal() []IPartitionValContext
	PartitionVal(i int) IPartitionValContext
	K_CLOSE_PAREN() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITION, 0)
}

func (s *PartitionSpecContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *PartitionSpecContext) AllPartitionVal() []IPartitionValContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValContext); ok {
			tst[i] = t.(IPartitionValContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSpecContext) PartitionVal(i int) IPartitionValContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValContext)
}

func (s *PartitionSpecContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *PartitionSpecContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *PartitionSpecContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (p *UniversalParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, UniversalParserRULE_partitionSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.Match(UniversalParserT_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(827)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(828)
		p.PartitionVal()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(829)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)
			p.PartitionVal()
		}

		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(836)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValContext is an interface to support dynamic dispatch.
type IPartitionValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionValContext differentiates from other interfaces.
	IsPartitionValContext()
}

type PartitionValContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValContext() *PartitionValContext {
	var p = new(PartitionValContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionVal
	return p
}

func InitEmptyPartitionValContext(p *PartitionValContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionVal
}

func (*PartitionValContext) IsPartitionValContext() {}

func NewPartitionValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValContext {
	var p = new(PartitionValContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_partitionVal

	return p
}

func (s *PartitionValContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValContext) CopyAll(ctx *PartitionValContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StandardPartitionValContext struct {
	PartitionValContext
}

func NewStandardPartitionValContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StandardPartitionValContext {
	var p = new(StandardPartitionValContext)

	InitEmptyPartitionValContext(&p.PartitionValContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionValContext))

	return p
}

func (s *StandardPartitionValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardPartitionValContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StandardPartitionValContext) CompareOperator() ICompareOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompareOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompareOperatorContext)
}

func (s *StandardPartitionValContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *StandardPartitionValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStandardPartitionVal(s)
	}
}

func (s *StandardPartitionValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStandardPartitionVal(s)
	}
}

type DefaultPartitionValContext struct {
	PartitionValContext
}

func NewDefaultPartitionValContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultPartitionValContext {
	var p = new(DefaultPartitionValContext)

	InitEmptyPartitionValContext(&p.PartitionValContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionValContext))

	return p
}

func (s *DefaultPartitionValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultPartitionValContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DefaultPartitionValContext) K_EQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EQ, 0)
}

func (s *DefaultPartitionValContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFAULT, 0)
}

func (s *DefaultPartitionValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDefaultPartitionVal(s)
	}
}

func (s *DefaultPartitionValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDefaultPartitionVal(s)
	}
}

func (p *UniversalParser) PartitionVal() (localctx IPartitionValContext) {
	localctx = NewPartitionValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, UniversalParserRULE_partitionVal)
	var _la int

	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStandardPartitionValContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(838)
			p.Identifier()
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-774)) & ^0x3f) == 0 && ((int64(1)<<(_la-774))&4095) != 0 {
			{
				p.SetState(839)
				p.CompareOperator()
			}
			{
				p.SetState(840)
				p.Constant()
			}

		}

	case 2:
		localctx = NewDefaultPartitionValContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(844)
			p.Identifier()
		}
		{
			p.SetState(845)
			p.Match(UniversalParserK_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(846)
			p.Match(UniversalParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfOptionContext is an interface to support dynamic dispatch.
type IIfOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IF() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsIfOptionContext differentiates from other interfaces.
	IsIfOptionContext()
}

type IfOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfOptionContext() *IfOptionContext {
	var p = new(IfOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_ifOption
	return p
}

func InitEmptyIfOptionContext(p *IfOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_ifOption
}

func (*IfOptionContext) IsIfOptionContext() {}

func NewIfOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfOptionContext {
	var p = new(IfOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_ifOption

	return p
}

func (s *IfOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfOptionContext) T_IF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IF, 0)
}

func (s *IfOptionContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXISTS, 0)
}

func (s *IfOptionContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *IfOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterIfOption(s)
	}
}

func (s *IfOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitIfOption(s)
	}
}

func (p *UniversalParser) IfOption() (localctx IIfOptionContext) {
	localctx = NewIfOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, UniversalParserRULE_ifOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(UniversalParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NOT {
		{
			p.SetState(851)
			p.Match(UniversalParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(854)
		p.Match(UniversalParserT_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceOptionContext is an interface to support dynamic dispatch.
type IReplaceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OR() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode

	// IsReplaceOptionContext differentiates from other interfaces.
	IsReplaceOptionContext()
}

type ReplaceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceOptionContext() *ReplaceOptionContext {
	var p = new(ReplaceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_replaceOption
	return p
}

func InitEmptyReplaceOptionContext(p *ReplaceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_replaceOption
}

func (*ReplaceOptionContext) IsReplaceOptionContext() {}

func NewReplaceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceOptionContext {
	var p = new(ReplaceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_replaceOption

	return p
}

func (s *ReplaceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceOptionContext) T_OR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OR, 0)
}

func (s *ReplaceOptionContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPLACE, 0)
}

func (s *ReplaceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterReplaceOption(s)
	}
}

func (s *ReplaceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitReplaceOption(s)
	}
}

func (p *UniversalParser) ReplaceOption() (localctx IReplaceOptionContext) {
	localctx = NewReplaceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, UniversalParserRULE_replaceOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(UniversalParserT_OR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(857)
		p.Match(UniversalParserT_REPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullOptionContext is an interface to support dynamic dispatch.
type INullOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsNullOptionContext differentiates from other interfaces.
	IsNullOptionContext()
}

type NullOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullOptionContext() *NullOptionContext {
	var p = new(NullOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_nullOption
	return p
}

func InitEmptyNullOptionContext(p *NullOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_nullOption
}

func (*NullOptionContext) IsNullOptionContext() {}

func NewNullOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullOptionContext {
	var p = new(NullOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_nullOption

	return p
}

func (s *NullOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *NullOptionContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULL, 0)
}

func (s *NullOptionContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *NullOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNullOption(s)
	}
}

func (s *NullOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNullOption(s)
	}
}

func (p *UniversalParser) NullOption() (localctx INullOptionContext) {
	localctx = NewNullOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, UniversalParserRULE_nullOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NOT {
		{
			p.SetState(859)
			p.Match(UniversalParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(862)
		p.Match(UniversalParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultOptionContext is an interface to support dynamic dispatch.
type IDefaultOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	T_DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultOptionContext differentiates from other interfaces.
	IsDefaultOptionContext()
}

type DefaultOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
}

func NewEmptyDefaultOptionContext() *DefaultOptionContext {
	var p = new(DefaultOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_defaultOption
	return p
}

func InitEmptyDefaultOptionContext(p *DefaultOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_defaultOption
}

func (*DefaultOptionContext) IsDefaultOptionContext() {}

func NewDefaultOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultOptionContext {
	var p = new(DefaultOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_defaultOption

	return p
}

func (s *DefaultOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultOptionContext) GetValue() IExpressionContext { return s.value }

func (s *DefaultOptionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *DefaultOptionContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFAULT, 0)
}

func (s *DefaultOptionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDefaultOption(s)
	}
}

func (s *DefaultOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDefaultOption(s)
	}
}

func (p *UniversalParser) DefaultOption() (localctx IDefaultOptionContext) {
	localctx = NewDefaultOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, UniversalParserRULE_defaultOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		p.Match(UniversalParserT_DEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(865)

		var _x = p.Expression()

		localctx.(*DefaultOptionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Cte() ICteContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *UniversalParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, UniversalParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_WITH {
		{
			p.SetState(867)
			p.Cte()
		}

	}
	{
		p.SetState(870)
		p.queryTerm(0)
	}
	{
		p.SetState(871)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_namedQuery returns the _namedQuery rule contexts.
	Get_namedQuery() INamedQueryContext

	// Set_namedQuery sets the _namedQuery rule contexts.
	Set_namedQuery(INamedQueryContext)

	// GetNamedQueryCollettion returns the namedQueryCollettion rule context list.
	GetNamedQueryCollettion() []INamedQueryContext

	// SetNamedQueryCollettion sets the namedQueryCollettion rule context list.
	SetNamedQueryCollettion([]INamedQueryContext)

	// Getter signatures
	T_WITH() antlr.TerminalNode
	AllNamedQuery() []INamedQueryContext
	NamedQuery(i int) INamedQueryContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_namedQuery          INamedQueryContext
	namedQueryCollettion []INamedQueryContext
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) Get_namedQuery() INamedQueryContext { return s._namedQuery }

func (s *CteContext) Set_namedQuery(v INamedQueryContext) { s._namedQuery = v }

func (s *CteContext) GetNamedQueryCollettion() []INamedQueryContext { return s.namedQueryCollettion }

func (s *CteContext) SetNamedQueryCollettion(v []INamedQueryContext) { s.namedQueryCollettion = v }

func (s *CteContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *CteContext) AllNamedQuery() []INamedQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedQueryContext); ok {
			len++
		}
	}

	tst := make([]INamedQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedQueryContext); ok {
			tst[i] = t.(INamedQueryContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) NamedQuery(i int) INamedQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *CteContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *CteContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (p *UniversalParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, UniversalParserRULE_cte)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(UniversalParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(874)

		var _x = p.NamedQuery()

		localctx.(*CteContext)._namedQuery = _x
	}
	localctx.(*CteContext).namedQueryCollettion = append(localctx.(*CteContext).namedQueryCollettion, localctx.(*CteContext)._namedQuery)
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(875)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)

			var _x = p.NamedQuery()

			localctx.(*CteContext)._namedQuery = _x
		}
		localctx.(*CteContext).namedQueryCollettion = append(localctx.(*CteContext).namedQueryCollettion, localctx.(*CteContext)._namedQuery)

		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	Query() IQueryContext
	K_CLOSE_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext
	T_AS() antlr.TerminalNode

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedQuery
	return p
}

func InitEmptyNamedQueryContext(p *NamedQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedQuery
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (p *UniversalParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, UniversalParserRULE_namedQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(883)
			p.ColumnAliases()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_AS {
		{
			p.SetState(886)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(889)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(890)
		p.Query()
	}
	{
		p.SetState(891)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *ColumnAliasesContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *ColumnAliasesContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *UniversalParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, UniversalParserRULE_columnAliases)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(894)
		p.IdentifierSeq()
	}
	{
		p.SetState(895)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OrderBy() IOrderByContext
	ClusterBy() IClusterByContext
	DistributeBy() IDistributeByContext
	SortBy() ISortByContext
	WindowClause() IWindowClauseContext
	LimitItem() ILimitItemContext
	OffsetItem() IOffsetItemContext

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) OrderBy() IOrderByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByContext)
}

func (s *QueryOrganizationContext) ClusterBy() IClusterByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByContext)
}

func (s *QueryOrganizationContext) DistributeBy() IDistributeByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeByContext)
}

func (s *QueryOrganizationContext) SortBy() ISortByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByContext)
}

func (s *QueryOrganizationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QueryOrganizationContext) LimitItem() ILimitItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitItemContext)
}

func (s *QueryOrganizationContext) OffsetItem() IOffsetItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetItemContext)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQueryOrganization(s)
	}
}

func (s *QueryOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQueryOrganization(s)
	}
}

func (p *UniversalParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, UniversalParserRULE_queryOrganization)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ORDER {
		{
			p.SetState(897)
			p.OrderBy()
		}

	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_CLUSTER || _la == UniversalParserT_CLUSTERED || _la == UniversalParserT_RANGE {
		{
			p.SetState(900)
			p.ClusterBy()
		}

	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_DISTRIBUTE {
		{
			p.SetState(903)
			p.DistributeBy()
		}

	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_SORT || _la == UniversalParserT_SORTED {
		{
			p.SetState(906)
			p.SortBy()
		}

	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_WINDOW {
		{
			p.SetState(909)
			p.WindowClause()
		}

	}
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_LIMIT {
		{
			p.SetState(912)
			p.LimitItem()
		}

	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_OFFSET {
		{
			p.SetState(915)
			p.OffsetItem()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CombineOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewCombineOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CombineOperationContext {
	var p = new(CombineOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *CombineOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *CombineOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *CombineOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *CombineOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *CombineOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *CombineOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *CombineOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombineOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *CombineOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *CombineOperationContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTERSECT, 0)
}

func (s *CombineOperationContext) T_UNION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNION, 0)
}

func (s *CombineOperationContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCEPT, 0)
}

func (s *CombineOperationContext) T_SETMINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SETMINUS, 0)
}

func (s *CombineOperationContext) T_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUS, 0)
}

func (s *CombineOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *CombineOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCombineOperation(s)
	}
}

func (s *CombineOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCombineOperation(s)
	}
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

func (p *UniversalParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *UniversalParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, UniversalParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(919)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewCombineOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
			localctx.(*CombineOperationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_queryTerm)
			p.SetState(921)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(922)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*CombineOperationContext).operator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == UniversalParserT_EXCEPT || _la == UniversalParserT_INTERSECT || _la == UniversalParserT_MINUS || _la == UniversalParserT_SETMINUS || _la == UniversalParserT_UNION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*CombineOperationContext).operator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(924)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == UniversalParserT_ALL || _la == UniversalParserT_DISTINCT {
				{
					p.SetState(923)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(926)

				var _x = p.queryTerm(2)

				localctx.(*CombineOperationContext).right = _x
			}

		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (p *UniversalParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, UniversalParserRULE_queryPrimary)
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_SELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.QuerySpecification()
		}

	case UniversalParserK_OPEN_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.Query()
		}
		{
			p.SetState(935)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectClause() ISelectClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	AggregationClause() IAggregationClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QuerySpecificationContext) AggregationClause() IAggregationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *UniversalParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, UniversalParserRULE_querySpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.SelectClause()
	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(940)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(943)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(946)
			p.AggregationClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(949)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(952)
			p.WindowClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hint returns the _hint rule contexts.
	Get_hint() IHintContext

	// Set_hint sets the _hint rule contexts.
	Set_hint(IHintContext)

	// GetHints returns the hints rule context list.
	GetHints() []IHintContext

	// SetHints sets the hints rule context list.
	SetHints([]IHintContext)

	// Getter signatures
	T_SELECT() antlr.TerminalNode
	NamedExpressionSeq() INamedExpressionSeqContext
	SetQuantifier() ISetQuantifierContext
	AllHint() []IHintContext
	Hint(i int) IHintContext

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_hint  IHintContext
	hints  []IHintContext
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) Get_hint() IHintContext { return s._hint }

func (s *SelectClauseContext) Set_hint(v IHintContext) { s._hint = v }

func (s *SelectClauseContext) GetHints() []IHintContext { return s.hints }

func (s *SelectClauseContext) SetHints(v []IHintContext) { s.hints = v }

func (s *SelectClauseContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SELECT, 0)
}

func (s *SelectClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectClauseContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SelectClauseContext) AllHint() []IHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintContext); ok {
			len++
		}
	}

	tst := make([]IHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintContext); ok {
			tst[i] = t.(IHintContext)
			i++
		}
	}

	return tst
}

func (s *SelectClauseContext) Hint(i int) IHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *UniversalParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, UniversalParserRULE_selectClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(UniversalParserT_SELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(956)

				var _x = p.Hint()

				localctx.(*SelectClauseContext)._hint = _x
			}
			localctx.(*SelectClauseContext).hints = append(localctx.(*SelectClauseContext).hints, localctx.(*SelectClauseContext)._hint)

		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(963)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(962)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(965)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FROM() antlr.TerminalNode
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode
	AllLateralView() []ILateralViewContext
	LateralView(i int) ILateralViewContext
	PivotClause() IPivotClauseContext
	UnpivotClause() IUnpivotClauseContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *FromClauseContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *FromClauseContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *FromClauseContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *FromClauseContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *FromClauseContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *FromClauseContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *FromClauseContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromClauseContext) UnpivotClause() IUnpivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotClauseContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *UniversalParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, UniversalParserRULE_fromClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Match(UniversalParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(968)
		p.Relation()
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(969)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(970)
				p.Relation()
			}

		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(976)
				p.LateralView()
			}

		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(982)
			p.PivotClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(985)
			p.UnpivotClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext
	AliasSpec() IAliasSpecContext

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VALUES, 0)
}

func (s *InlineTableContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *InlineTableContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *UniversalParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, UniversalParserRULE_inlineTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(UniversalParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(989)
		p.ExpressionSeq()
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(990)
			p.AliasSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTableContext is an interface to support dynamic dispatch.
type IFunctionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StandardFunction() IStandardFunctionContext
	AliasSpec() IAliasSpecContext

	// IsFunctionTableContext differentiates from other interfaces.
	IsFunctionTableContext()
}

type FunctionTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTableContext() *FunctionTableContext {
	var p = new(FunctionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_functionTable
	return p
}

func InitEmptyFunctionTableContext(p *FunctionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_functionTable
}

func (*FunctionTableContext) IsFunctionTableContext() {}

func NewFunctionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTableContext {
	var p = new(FunctionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_functionTable

	return p
}

func (s *FunctionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTableContext) StandardFunction() IStandardFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFunctionContext)
}

func (s *FunctionTableContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *FunctionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFunctionTable(s)
	}
}

func (s *FunctionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFunctionTable(s)
	}
}

func (p *UniversalParser) FunctionTable() (localctx IFunctionTableContext) {
	localctx = NewFunctionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, UniversalParserRULE_functionTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.StandardFunction()
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(994)
			p.AliasSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalClauseContext is an interface to support dynamic dispatch.
type ITemporalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimestamp returns the timestamp rule contexts.
	GetTimestamp() IValueExpressionContext

	// SetTimestamp sets the timestamp rule contexts.
	SetTimestamp(IValueExpressionContext)

	// Getter signatures
	T_AS() antlr.TerminalNode
	T_OF() antlr.TerminalNode
	Version() IVersionContext
	T_SYSTEM_VERSION() antlr.TerminalNode
	T_VERSION() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_SYSTEM_TIME() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsTemporalClauseContext differentiates from other interfaces.
	IsTemporalClauseContext()
}

type TemporalClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	timestamp IValueExpressionContext
}

func NewEmptyTemporalClauseContext() *TemporalClauseContext {
	var p = new(TemporalClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_temporalClause
	return p
}

func InitEmptyTemporalClauseContext(p *TemporalClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_temporalClause
}

func (*TemporalClauseContext) IsTemporalClauseContext() {}

func NewTemporalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalClauseContext {
	var p = new(TemporalClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_temporalClause

	return p
}

func (s *TemporalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalClauseContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *TemporalClauseContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *TemporalClauseContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *TemporalClauseContext) T_OF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OF, 0)
}

func (s *TemporalClauseContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *TemporalClauseContext) T_SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYSTEM_VERSION, 0)
}

func (s *TemporalClauseContext) T_VERSION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VERSION, 0)
}

func (s *TemporalClauseContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *TemporalClauseContext) T_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYSTEM_TIME, 0)
}

func (s *TemporalClauseContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TIMESTAMP, 0)
}

func (s *TemporalClauseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TemporalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTemporalClause(s)
	}
}

func (s *TemporalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTemporalClause(s)
	}
}

func (p *UniversalParser) TemporalClause() (localctx ITemporalClauseContext) {
	localctx = NewTemporalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, UniversalParserRULE_temporalClause)
	var _la int

	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_FOR {
			{
				p.SetState(997)
				p.Match(UniversalParserT_FOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1000)
			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_SYSTEM_VERSION || _la == UniversalParserT_VERSION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1001)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1002)
			p.Match(UniversalParserT_OF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1003)
			p.Version()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_FOR {
			{
				p.SetState(1004)
				p.Match(UniversalParserT_FOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1007)
			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_SYSTEM_TIME || _la == UniversalParserT_TIMESTAMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1008)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1009)
			p.Match(UniversalParserT_OF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1010)

			var _x = p.valueExpression(0)

			localctx.(*TemporalClauseContext).timestamp = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	T_TABLESAMPLE() antlr.TerminalNode
	AllK_OPEN_PAREN() []antlr.TerminalNode
	K_OPEN_PAREN(i int) antlr.TerminalNode
	AllK_CLOSE_PAREN() []antlr.TerminalNode
	K_CLOSE_PAREN(i int) antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	T_REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) T_TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLESAMPLE, 0)
}

func (s *SampleContext) AllK_OPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_OPEN_PAREN)
}

func (s *SampleContext) K_OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, i)
}

func (s *SampleContext) AllK_CLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_CLOSE_PAREN)
}

func (s *SampleContext) K_CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, i)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) T_REPEATABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSample(s)
	}
}

func (s *SampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSample(s)
	}
}

func (p *UniversalParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, UniversalParserRULE_sample)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(UniversalParserT_TABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1014)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1015)
			p.SampleMethod()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1018)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1019)
			p.Match(UniversalParserT_REPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1020)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1021)

			var _m = p.Match(UniversalParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1022)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleByRowsContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROWS, 0)
}

func (s *SampleByRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSampleByRows(s)
	}
}

func (s *SampleByRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSampleByRows(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	percentage antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) T_PERCENTLIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTLIT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserDECIMAL_VALUE, 0)
}

func (s *SampleByPercentileContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *SampleByPercentileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSampleByPercentile(s)
	}
}

func (s *SampleByPercentileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSampleByPercentile(s)
	}
}

type SampleByBucketContext struct {
	SampleMethodContext
	numerator antlr.Token
}

func NewSampleByBucketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByBucketContext {
	var p = new(SampleByBucketContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByBucketContext) GetNumerator() antlr.Token { return s.numerator }

func (s *SampleByBucketContext) SetNumerator(v antlr.Token) { s.numerator = v }

func (s *SampleByBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByBucketContext) T_BUCKET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BUCKET, 0)
}

func (s *SampleByBucketContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUT, 0)
}

func (s *SampleByBucketContext) T_OF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OF, 0)
}

func (s *SampleByBucketContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserINTEGER_VALUE)
}

func (s *SampleByBucketContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, i)
}

func (s *SampleByBucketContext) T_ON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ON, 0)
}

func (s *SampleByBucketContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SampleByBucketContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *SampleByBucketContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *SampleByBucketContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *SampleByBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSampleByBucket(s)
	}
}

func (s *SampleByBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSampleByBucket(s)
	}
}

type SampleByBytesContext struct {
	SampleMethodContext
	bytes IExpressionContext
}

func NewSampleByBytesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByBytesContext {
	var p = new(SampleByBytesContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByBytesContext) GetBytes() IExpressionContext { return s.bytes }

func (s *SampleByBytesContext) SetBytes(v IExpressionContext) { s.bytes = v }

func (s *SampleByBytesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByBytesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleByBytesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSampleByBytes(s)
	}
}

func (s *SampleByBytesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSampleByBytes(s)
	}
}

func (p *UniversalParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, UniversalParserRULE_sampleMethod)
	var _la int

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(1025)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1028)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SampleByPercentileContext).percentage = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserINTEGER_VALUE || _la == UniversalParserDECIMAL_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SampleByPercentileContext).percentage = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1029)
			p.Match(UniversalParserT_PERCENTLIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1030)
			p.Expression()
		}
		{
			p.SetState(1031)
			p.Match(UniversalParserT_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSampleByBucketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1033)
			p.Match(UniversalParserT_BUCKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1034)

			var _m = p.Match(UniversalParserINTEGER_VALUE)

			localctx.(*SampleByBucketContext).numerator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1035)
			p.Match(UniversalParserT_OUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1036)
			p.Match(UniversalParserT_OF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1037)
			p.Match(UniversalParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_ON {
			{
				p.SetState(1038)
				p.Match(UniversalParserT_ON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1044)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1039)
					p.Identifier()
				}

			case 2:
				{
					p.SetState(1040)
					p.MultiIdentifier()
				}
				{
					p.SetState(1041)
					p.Match(UniversalParserK_OPEN_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1042)
					p.Match(UniversalParserK_CLOSE_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 4:
		localctx = NewSampleByBytesContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1048)

			var _x = p.Expression()

			localctx.(*SampleByBytesContext).bytes = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *AliasedQueryContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *AliasedQueryContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *AliasedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterAliasedQuery(s)
	}
}

func (s *AliasedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitAliasedQuery(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
	table IMultiIdentifierContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetTable() IMultiIdentifierContext { return s.table }

func (s *TableNameContext) SetTable(v IMultiIdentifierContext) { s.table = v }

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *TableNameContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *TableNameContext) TemporalClause() ITemporalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalClauseContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *UniversalParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, UniversalParserRULE_relationPrimary)
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1051)

			var _x = p.MultiIdentifier()

			localctx.(*TableNameContext).table = _x
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1052)
				p.ExpressionSeqs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1055)
				p.TemporalClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1058)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1061)
				p.AliasSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1064)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1065)
			p.Query()
		}
		{
			p.SetState(1066)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1067)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1070)
				p.AliasSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IRelationPrimaryContext

	// SetLeft sets the left rule contexts.
	SetLeft(IRelationPrimaryContext)

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	T_LATERAL() antlr.TerminalNode
	AllRelationExtension() []IRelationExtensionContext
	RelationExtension(i int) IRelationExtensionContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IRelationPrimaryContext
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) GetLeft() IRelationPrimaryContext { return s.left }

func (s *RelationContext) SetLeft(v IRelationPrimaryContext) { s.left = v }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) T_LATERAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LATERAL, 0)
}

func (s *RelationContext) AllRelationExtension() []IRelationExtensionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationExtensionContext); ok {
			len++
		}
	}

	tst := make([]IRelationExtensionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationExtensionContext); ok {
			tst[i] = t.(IRelationExtensionContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) RelationExtension(i int) IRelationExtensionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationExtensionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationExtensionContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *UniversalParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, UniversalParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1075)
			p.Match(UniversalParserT_LATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1078)

		var _x = p.RelationPrimary()

		localctx.(*RelationContext).left = _x
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1079)
				p.RelationExtension()
			}

		}
		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationExtensionContext is an interface to support dynamic dispatch.
type IRelationExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JoinRelation() IJoinRelationContext
	PivotClause() IPivotClauseContext
	UnpivotClause() IUnpivotClauseContext

	// IsRelationExtensionContext differentiates from other interfaces.
	IsRelationExtensionContext()
}

type RelationExtensionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationExtensionContext() *RelationExtensionContext {
	var p = new(RelationExtensionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relationExtension
	return p
}

func InitEmptyRelationExtensionContext(p *RelationExtensionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_relationExtension
}

func (*RelationExtensionContext) IsRelationExtensionContext() {}

func NewRelationExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationExtensionContext {
	var p = new(RelationExtensionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_relationExtension

	return p
}

func (s *RelationExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationExtensionContext) JoinRelation() IJoinRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationExtensionContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *RelationExtensionContext) UnpivotClause() IUnpivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotClauseContext)
}

func (s *RelationExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRelationExtension(s)
	}
}

func (s *RelationExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRelationExtension(s)
	}
}

func (p *UniversalParser) RelationExtension() (localctx IRelationExtensionContext) {
	localctx = NewRelationExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, UniversalParserRULE_relationExtension)
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_ANTI, UniversalParserT_CROSS, UniversalParserT_FULL, UniversalParserT_INNER, UniversalParserT_JOIN, UniversalParserT_LEFT, UniversalParserT_NATURAL, UniversalParserT_RIGHT, UniversalParserT_SEMI:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1085)
			p.JoinRelation()
		}

	case UniversalParserT_PIVOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1086)
			p.PivotClause()
		}

	case UniversalParserT_UNPIVOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1087)
			p.UnpivotClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JoinType() IJoinTypeContext
	T_JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	T_NATURAL() antlr.TerminalNode
	T_LATERAL() antlr.TerminalNode
	JoinCondtion() IJoinCondtionContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) T_NATURAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NATURAL, 0)
}

func (s *JoinRelationContext) T_LATERAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LATERAL, 0)
}

func (s *JoinRelationContext) JoinCondtion() IJoinCondtionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCondtionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCondtionContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *UniversalParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, UniversalParserRULE_joinRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NATURAL {
		{
			p.SetState(1090)
			p.Match(UniversalParserT_NATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1093)
		p.JoinType()
	}
	{
		p.SetState(1094)
		p.Match(UniversalParserT_JOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1095)
			p.Match(UniversalParserT_LATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1098)

		var _x = p.RelationPrimary()

		localctx.(*JoinRelationContext).right = _x
	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1099)
			p.JoinCondtion()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCondtionContext is an interface to support dynamic dispatch.
type IJoinCondtionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	T_USING() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsJoinCondtionContext differentiates from other interfaces.
	IsJoinCondtionContext()
}

type JoinCondtionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCondtionContext() *JoinCondtionContext {
	var p = new(JoinCondtionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinCondtion
	return p
}

func InitEmptyJoinCondtionContext(p *JoinCondtionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinCondtion
}

func (*JoinCondtionContext) IsJoinCondtionContext() {}

func NewJoinCondtionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCondtionContext {
	var p = new(JoinCondtionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_joinCondtion

	return p
}

func (s *JoinCondtionContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCondtionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ON, 0)
}

func (s *JoinCondtionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCondtionContext) T_USING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_USING, 0)
}

func (s *JoinCondtionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *JoinCondtionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *JoinCondtionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *JoinCondtionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCondtionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCondtionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterJoinCondtion(s)
	}
}

func (s *JoinCondtionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitJoinCondtion(s)
	}
}

func (p *UniversalParser) JoinCondtion() (localctx IJoinCondtionContext) {
	localctx = NewJoinCondtionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, UniversalParserRULE_joinCondtion)
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_ON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1102)
			p.Match(UniversalParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.booleanExpression(0)
		}

	case UniversalParserT_USING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Match(UniversalParserT_USING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1105)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1106)
			p.IdentifierSeq()
		}
		{
			p.SetState(1107)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INNER() antlr.TerminalNode
	T_CROSS() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode
	T_SEMI() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INNER, 0)
}

func (s *JoinTypeContext) T_CROSS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CROSS, 0)
}

func (s *JoinTypeContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEFT, 0)
}

func (s *JoinTypeContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUTER, 0)
}

func (s *JoinTypeContext) T_SEMI() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEMI, 0)
}

func (s *JoinTypeContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RIGHT, 0)
}

func (s *JoinTypeContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FULL, 0)
}

func (s *JoinTypeContext) T_ANTI() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *UniversalParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, UniversalParserRULE_joinType)
	var _la int

	p.SetState(1135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_INNER {
			{
				p.SetState(1111)
				p.Match(UniversalParserT_INNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Match(UniversalParserT_CROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1115)
			p.Match(UniversalParserT_LEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_OUTER {
			{
				p.SetState(1116)
				p.Match(UniversalParserT_OUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_LEFT {
			{
				p.SetState(1119)
				p.Match(UniversalParserT_LEFT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1122)
			p.Match(UniversalParserT_SEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1123)
			p.Match(UniversalParserT_RIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_OUTER {
			{
				p.SetState(1124)
				p.Match(UniversalParserT_OUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1127)
			p.Match(UniversalParserT_FULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_OUTER {
			{
				p.SetState(1128)
				p.Match(UniversalParserT_OUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_LEFT {
			{
				p.SetState(1131)
				p.Match(UniversalParserT_LEFT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1134)
			p.Match(UniversalParserT_ANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_pivotAggregateItem returns the _pivotAggregateItem rule contexts.
	Get_pivotAggregateItem() IPivotAggregateItemContext

	// Get_pivotValue returns the _pivotValue rule contexts.
	Get_pivotValue() IPivotValueContext

	// Set_pivotAggregateItem sets the _pivotAggregateItem rule contexts.
	Set_pivotAggregateItem(IPivotAggregateItemContext)

	// Set_pivotValue sets the _pivotValue rule contexts.
	Set_pivotValue(IPivotValueContext)

	// GetAggregates returns the aggregates rule context list.
	GetAggregates() []IPivotAggregateItemContext

	// GetPivotValues returns the pivotValues rule context list.
	GetPivotValues() []IPivotValueContext

	// SetAggregates sets the aggregates rule context list.
	SetAggregates([]IPivotAggregateItemContext)

	// SetPivotValues sets the pivotValues rule context list.
	SetPivotValues([]IPivotValueContext)

	// Getter signatures
	T_PIVOT() antlr.TerminalNode
	AllK_OPEN_PAREN() []antlr.TerminalNode
	K_OPEN_PAREN(i int) antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	PivotColumn() IPivotColumnContext
	T_IN() antlr.TerminalNode
	AllK_CLOSE_PAREN() []antlr.TerminalNode
	K_CLOSE_PAREN(i int) antlr.TerminalNode
	AllPivotAggregateItem() []IPivotAggregateItemContext
	PivotAggregateItem(i int) IPivotAggregateItemContext
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_pivotAggregateItem IPivotAggregateItemContext
	aggregates          []IPivotAggregateItemContext
	_pivotValue         IPivotValueContext
	pivotValues         []IPivotValueContext
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) Get_pivotAggregateItem() IPivotAggregateItemContext {
	return s._pivotAggregateItem
}

func (s *PivotClauseContext) Get_pivotValue() IPivotValueContext { return s._pivotValue }

func (s *PivotClauseContext) Set_pivotAggregateItem(v IPivotAggregateItemContext) {
	s._pivotAggregateItem = v
}

func (s *PivotClauseContext) Set_pivotValue(v IPivotValueContext) { s._pivotValue = v }

func (s *PivotClauseContext) GetAggregates() []IPivotAggregateItemContext { return s.aggregates }

func (s *PivotClauseContext) GetPivotValues() []IPivotValueContext { return s.pivotValues }

func (s *PivotClauseContext) SetAggregates(v []IPivotAggregateItemContext) { s.aggregates = v }

func (s *PivotClauseContext) SetPivotValues(v []IPivotValueContext) { s.pivotValues = v }

func (s *PivotClauseContext) T_PIVOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PIVOT, 0)
}

func (s *PivotClauseContext) AllK_OPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_OPEN_PAREN)
}

func (s *PivotClauseContext) K_OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, i)
}

func (s *PivotClauseContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *PivotClauseContext) PivotColumn() IPivotColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotColumnContext)
}

func (s *PivotClauseContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *PivotClauseContext) AllK_CLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_CLOSE_PAREN)
}

func (s *PivotClauseContext) K_CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, i)
}

func (s *PivotClauseContext) AllPivotAggregateItem() []IPivotAggregateItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotAggregateItemContext); ok {
			len++
		}
	}

	tst := make([]IPivotAggregateItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotAggregateItemContext); ok {
			tst[i] = t.(IPivotAggregateItemContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotAggregateItem(i int) IPivotAggregateItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotAggregateItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotAggregateItemContext)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *PivotClauseContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (p *UniversalParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, UniversalParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(UniversalParserT_PIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1138)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1139)

		var _x = p.PivotAggregateItem()

		localctx.(*PivotClauseContext)._pivotAggregateItem = _x
	}
	localctx.(*PivotClauseContext).aggregates = append(localctx.(*PivotClauseContext).aggregates, localctx.(*PivotClauseContext)._pivotAggregateItem)
	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1140)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1141)

			var _x = p.PivotAggregateItem()

			localctx.(*PivotClauseContext)._pivotAggregateItem = _x
		}
		localctx.(*PivotClauseContext).aggregates = append(localctx.(*PivotClauseContext).aggregates, localctx.(*PivotClauseContext)._pivotAggregateItem)

		p.SetState(1146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1147)
		p.Match(UniversalParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1148)
		p.PivotColumn()
	}
	{
		p.SetState(1149)
		p.Match(UniversalParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1150)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1151)

		var _x = p.PivotValue()

		localctx.(*PivotClauseContext)._pivotValue = _x
	}
	localctx.(*PivotClauseContext).pivotValues = append(localctx.(*PivotClauseContext).pivotValues, localctx.(*PivotClauseContext)._pivotValue)
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1152)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1153)

			var _x = p.PivotValue()

			localctx.(*PivotClauseContext)._pivotValue = _x
		}
		localctx.(*PivotClauseContext).pivotValues = append(localctx.(*PivotClauseContext).pivotValues, localctx.(*PivotClauseContext)._pivotValue)

		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1159)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1160)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotAggregateItemContext is an interface to support dynamic dispatch.
type IPivotAggregateItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AliasSpec() IAliasSpecContext

	// IsPivotAggregateItemContext differentiates from other interfaces.
	IsPivotAggregateItemContext()
}

type PivotAggregateItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotAggregateItemContext() *PivotAggregateItemContext {
	var p = new(PivotAggregateItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotAggregateItem
	return p
}

func InitEmptyPivotAggregateItemContext(p *PivotAggregateItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotAggregateItem
}

func (*PivotAggregateItemContext) IsPivotAggregateItemContext() {}

func NewPivotAggregateItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotAggregateItemContext {
	var p = new(PivotAggregateItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_pivotAggregateItem

	return p
}

func (s *PivotAggregateItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotAggregateItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PivotAggregateItemContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *PivotAggregateItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotAggregateItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotAggregateItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPivotAggregateItem(s)
	}
}

func (s *PivotAggregateItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPivotAggregateItem(s)
	}
}

func (p *UniversalParser) PivotAggregateItem() (localctx IPivotAggregateItemContext) {
	localctx = NewPivotAggregateItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, UniversalParserRULE_pivotAggregateItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Expression()
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1163)
			p.AliasSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotColumnContext is an interface to support dynamic dispatch.
type IPivotColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ExpressionSeqs() IExpressionSeqsContext

	// IsPivotColumnContext differentiates from other interfaces.
	IsPivotColumnContext()
}

type PivotColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotColumnContext() *PivotColumnContext {
	var p = new(PivotColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotColumn
	return p
}

func InitEmptyPivotColumnContext(p *PivotColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotColumn
}

func (*PivotColumnContext) IsPivotColumnContext() {}

func NewPivotColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotColumnContext {
	var p = new(PivotColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_pivotColumn

	return p
}

func (s *PivotColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotColumnContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *PivotColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPivotColumn(s)
	}
}

func (s *PivotColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPivotColumn(s)
	}
}

func (p *UniversalParser) PivotColumn() (localctx IPivotColumnContext) {
	localctx = NewPivotColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, UniversalParserRULE_pivotColumn)
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1166)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1167)
			p.ExpressionSeqs()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AliasSpec() IAliasSpecContext
	ExpressionSeqs() IExpressionSeqsContext

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PivotValueContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *PivotValueContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (p *UniversalParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, UniversalParserRULE_pivotValue)
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1170)
			p.Expression()
		}
		p.SetState(1172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1171)
				p.AliasSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1174)
			p.ExpressionSeqs()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotClauseContext is an interface to support dynamic dispatch.
type IUnpivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UNPIVOT() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	UnpivotSingleValueColumn() IUnpivotSingleValueColumnContext
	UnpivotMultiValueColumn() IUnpivotMultiValueColumnContext
	UnpivotOption() IUnpivotOptionContext
	UnpivotColumnAlias() IUnpivotColumnAliasContext

	// IsUnpivotClauseContext differentiates from other interfaces.
	IsUnpivotClauseContext()
}

type UnpivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotClauseContext() *UnpivotClauseContext {
	var p = new(UnpivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotClause
	return p
}

func InitEmptyUnpivotClauseContext(p *UnpivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotClause
}

func (*UnpivotClauseContext) IsUnpivotClauseContext() {}

func NewUnpivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotClauseContext {
	var p = new(UnpivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotClause

	return p
}

func (s *UnpivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotClauseContext) T_UNPIVOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNPIVOT, 0)
}

func (s *UnpivotClauseContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *UnpivotClauseContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *UnpivotClauseContext) UnpivotSingleValueColumn() IUnpivotSingleValueColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotSingleValueColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotSingleValueColumnContext)
}

func (s *UnpivotClauseContext) UnpivotMultiValueColumn() IUnpivotMultiValueColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotMultiValueColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotMultiValueColumnContext)
}

func (s *UnpivotClauseContext) UnpivotOption() IUnpivotOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotOptionContext)
}

func (s *UnpivotClauseContext) UnpivotColumnAlias() IUnpivotColumnAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasContext)
}

func (s *UnpivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotClause(s)
	}
}

func (s *UnpivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotClause(s)
	}
}

func (p *UniversalParser) UnpivotClause() (localctx IUnpivotClauseContext) {
	localctx = NewUnpivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, UniversalParserRULE_unpivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.Match(UniversalParserT_UNPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_EXCLUDE || _la == UniversalParserT_INCLUDE {
		{
			p.SetState(1178)
			p.UnpivotOption()
		}

	}
	{
		p.SetState(1181)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1182)
			p.UnpivotSingleValueColumn()
		}

	case 2:
		{
			p.SetState(1183)
			p.UnpivotMultiValueColumn()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1186)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1187)
			p.UnpivotColumnAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotOptionContext is an interface to support dynamic dispatch.
type IUnpivotOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOpt returns the opt token.
	GetOpt() antlr.Token

	// SetOpt sets the opt token.
	SetOpt(antlr.Token)

	// Getter signatures
	T_NULLS() antlr.TerminalNode
	T_INCLUDE() antlr.TerminalNode
	T_EXCLUDE() antlr.TerminalNode

	// IsUnpivotOptionContext differentiates from other interfaces.
	IsUnpivotOptionContext()
}

type UnpivotOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	opt    antlr.Token
}

func NewEmptyUnpivotOptionContext() *UnpivotOptionContext {
	var p = new(UnpivotOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotOption
	return p
}

func InitEmptyUnpivotOptionContext(p *UnpivotOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotOption
}

func (*UnpivotOptionContext) IsUnpivotOptionContext() {}

func NewUnpivotOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotOptionContext {
	var p = new(UnpivotOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotOption

	return p
}

func (s *UnpivotOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotOptionContext) GetOpt() antlr.Token { return s.opt }

func (s *UnpivotOptionContext) SetOpt(v antlr.Token) { s.opt = v }

func (s *UnpivotOptionContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *UnpivotOptionContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INCLUDE, 0)
}

func (s *UnpivotOptionContext) T_EXCLUDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCLUDE, 0)
}

func (s *UnpivotOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotOption(s)
	}
}

func (s *UnpivotOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotOption(s)
	}
}

func (p *UniversalParser) UnpivotOption() (localctx IUnpivotOptionContext) {
	localctx = NewUnpivotOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, UniversalParserRULE_unpivotOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UnpivotOptionContext).opt = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_EXCLUDE || _la == UniversalParserT_INCLUDE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UnpivotOptionContext).opt = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1191)
		p.Match(UniversalParserT_NULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotSingleValueColumnContext is an interface to support dynamic dispatch.
type IUnpivotSingleValueColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnpivotVauleColumn returns the unpivotVauleColumn rule contexts.
	GetUnpivotVauleColumn() IIdentifierContext

	// Get_unpivotColumnItem returns the _unpivotColumnItem rule contexts.
	Get_unpivotColumnItem() IUnpivotColumnItemContext

	// SetUnpivotVauleColumn sets the unpivotVauleColumn rule contexts.
	SetUnpivotVauleColumn(IIdentifierContext)

	// Set_unpivotColumnItem sets the _unpivotColumnItem rule contexts.
	Set_unpivotColumnItem(IUnpivotColumnItemContext)

	// GetUnpivotColumns returns the unpivotColumns rule context list.
	GetUnpivotColumns() []IUnpivotColumnItemContext

	// SetUnpivotColumns sets the unpivotColumns rule context list.
	SetUnpivotColumns([]IUnpivotColumnItemContext)

	// Getter signatures
	T_FOR() antlr.TerminalNode
	UnpivotNameColumn() IUnpivotNameColumnContext
	T_IN() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllUnpivotColumnItem() []IUnpivotColumnItemContext
	UnpivotColumnItem(i int) IUnpivotColumnItemContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsUnpivotSingleValueColumnContext differentiates from other interfaces.
	IsUnpivotSingleValueColumnContext()
}

type UnpivotSingleValueColumnContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	unpivotVauleColumn IIdentifierContext
	_unpivotColumnItem IUnpivotColumnItemContext
	unpivotColumns     []IUnpivotColumnItemContext
}

func NewEmptyUnpivotSingleValueColumnContext() *UnpivotSingleValueColumnContext {
	var p = new(UnpivotSingleValueColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotSingleValueColumn
	return p
}

func InitEmptyUnpivotSingleValueColumnContext(p *UnpivotSingleValueColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotSingleValueColumn
}

func (*UnpivotSingleValueColumnContext) IsUnpivotSingleValueColumnContext() {}

func NewUnpivotSingleValueColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotSingleValueColumnContext {
	var p = new(UnpivotSingleValueColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotSingleValueColumn

	return p
}

func (s *UnpivotSingleValueColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotSingleValueColumnContext) GetUnpivotVauleColumn() IIdentifierContext {
	return s.unpivotVauleColumn
}

func (s *UnpivotSingleValueColumnContext) Get_unpivotColumnItem() IUnpivotColumnItemContext {
	return s._unpivotColumnItem
}

func (s *UnpivotSingleValueColumnContext) SetUnpivotVauleColumn(v IIdentifierContext) {
	s.unpivotVauleColumn = v
}

func (s *UnpivotSingleValueColumnContext) Set_unpivotColumnItem(v IUnpivotColumnItemContext) {
	s._unpivotColumnItem = v
}

func (s *UnpivotSingleValueColumnContext) GetUnpivotColumns() []IUnpivotColumnItemContext {
	return s.unpivotColumns
}

func (s *UnpivotSingleValueColumnContext) SetUnpivotColumns(v []IUnpivotColumnItemContext) {
	s.unpivotColumns = v
}

func (s *UnpivotSingleValueColumnContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *UnpivotSingleValueColumnContext) UnpivotNameColumn() IUnpivotNameColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotNameColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotNameColumnContext)
}

func (s *UnpivotSingleValueColumnContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *UnpivotSingleValueColumnContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *UnpivotSingleValueColumnContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *UnpivotSingleValueColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnpivotSingleValueColumnContext) AllUnpivotColumnItem() []IUnpivotColumnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotColumnItemContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotColumnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotColumnItemContext); ok {
			tst[i] = t.(IUnpivotColumnItemContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotSingleValueColumnContext) UnpivotColumnItem(i int) IUnpivotColumnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnItemContext)
}

func (s *UnpivotSingleValueColumnContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *UnpivotSingleValueColumnContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *UnpivotSingleValueColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotSingleValueColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotSingleValueColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotSingleValueColumn(s)
	}
}

func (s *UnpivotSingleValueColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotSingleValueColumn(s)
	}
}

func (p *UniversalParser) UnpivotSingleValueColumn() (localctx IUnpivotSingleValueColumnContext) {
	localctx = NewUnpivotSingleValueColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, UniversalParserRULE_unpivotSingleValueColumn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)

		var _x = p.Identifier()

		localctx.(*UnpivotSingleValueColumnContext).unpivotVauleColumn = _x
	}
	{
		p.SetState(1194)
		p.Match(UniversalParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1195)
		p.UnpivotNameColumn()
	}
	{
		p.SetState(1196)
		p.Match(UniversalParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1197)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1198)

		var _x = p.UnpivotColumnItem()

		localctx.(*UnpivotSingleValueColumnContext)._unpivotColumnItem = _x
	}
	localctx.(*UnpivotSingleValueColumnContext).unpivotColumns = append(localctx.(*UnpivotSingleValueColumnContext).unpivotColumns, localctx.(*UnpivotSingleValueColumnContext)._unpivotColumnItem)
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1199)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1200)

			var _x = p.UnpivotColumnItem()

			localctx.(*UnpivotSingleValueColumnContext)._unpivotColumnItem = _x
		}
		localctx.(*UnpivotSingleValueColumnContext).unpivotColumns = append(localctx.(*UnpivotSingleValueColumnContext).unpivotColumns, localctx.(*UnpivotSingleValueColumnContext)._unpivotColumnItem)

		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1206)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotMultiValueColumnContext is an interface to support dynamic dispatch.
type IUnpivotMultiValueColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unpivotMultiColumnItem returns the _unpivotMultiColumnItem rule contexts.
	Get_unpivotMultiColumnItem() IUnpivotMultiColumnItemContext

	// Set_unpivotMultiColumnItem sets the _unpivotMultiColumnItem rule contexts.
	Set_unpivotMultiColumnItem(IUnpivotMultiColumnItemContext)

	// GetUnpivotColumnSets returns the unpivotColumnSets rule context list.
	GetUnpivotColumnSets() []IUnpivotMultiColumnItemContext

	// SetUnpivotColumnSets sets the unpivotColumnSets rule context list.
	SetUnpivotColumnSets([]IUnpivotMultiColumnItemContext)

	// Getter signatures
	AllK_OPEN_PAREN() []antlr.TerminalNode
	K_OPEN_PAREN(i int) antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	AllK_CLOSE_PAREN() []antlr.TerminalNode
	K_CLOSE_PAREN(i int) antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	UnpivotNameColumn() IUnpivotNameColumnContext
	T_IN() antlr.TerminalNode
	AllUnpivotMultiColumnItem() []IUnpivotMultiColumnItemContext
	UnpivotMultiColumnItem(i int) IUnpivotMultiColumnItemContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsUnpivotMultiValueColumnContext differentiates from other interfaces.
	IsUnpivotMultiValueColumnContext()
}

type UnpivotMultiValueColumnContext struct {
	antlr.BaseParserRuleContext
	parser                  antlr.Parser
	_unpivotMultiColumnItem IUnpivotMultiColumnItemContext
	unpivotColumnSets       []IUnpivotMultiColumnItemContext
}

func NewEmptyUnpivotMultiValueColumnContext() *UnpivotMultiValueColumnContext {
	var p = new(UnpivotMultiValueColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotMultiValueColumn
	return p
}

func InitEmptyUnpivotMultiValueColumnContext(p *UnpivotMultiValueColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotMultiValueColumn
}

func (*UnpivotMultiValueColumnContext) IsUnpivotMultiValueColumnContext() {}

func NewUnpivotMultiValueColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotMultiValueColumnContext {
	var p = new(UnpivotMultiValueColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotMultiValueColumn

	return p
}

func (s *UnpivotMultiValueColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotMultiValueColumnContext) Get_unpivotMultiColumnItem() IUnpivotMultiColumnItemContext {
	return s._unpivotMultiColumnItem
}

func (s *UnpivotMultiValueColumnContext) Set_unpivotMultiColumnItem(v IUnpivotMultiColumnItemContext) {
	s._unpivotMultiColumnItem = v
}

func (s *UnpivotMultiValueColumnContext) GetUnpivotColumnSets() []IUnpivotMultiColumnItemContext {
	return s.unpivotColumnSets
}

func (s *UnpivotMultiValueColumnContext) SetUnpivotColumnSets(v []IUnpivotMultiColumnItemContext) {
	s.unpivotColumnSets = v
}

func (s *UnpivotMultiValueColumnContext) AllK_OPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_OPEN_PAREN)
}

func (s *UnpivotMultiValueColumnContext) K_OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, i)
}

func (s *UnpivotMultiValueColumnContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *UnpivotMultiValueColumnContext) AllK_CLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_CLOSE_PAREN)
}

func (s *UnpivotMultiValueColumnContext) K_CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, i)
}

func (s *UnpivotMultiValueColumnContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *UnpivotMultiValueColumnContext) UnpivotNameColumn() IUnpivotNameColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotNameColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotNameColumnContext)
}

func (s *UnpivotMultiValueColumnContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *UnpivotMultiValueColumnContext) AllUnpivotMultiColumnItem() []IUnpivotMultiColumnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotMultiColumnItemContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotMultiColumnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotMultiColumnItemContext); ok {
			tst[i] = t.(IUnpivotMultiColumnItemContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotMultiValueColumnContext) UnpivotMultiColumnItem(i int) IUnpivotMultiColumnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotMultiColumnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotMultiColumnItemContext)
}

func (s *UnpivotMultiValueColumnContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *UnpivotMultiValueColumnContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *UnpivotMultiValueColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotMultiValueColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotMultiValueColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotMultiValueColumn(s)
	}
}

func (s *UnpivotMultiValueColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotMultiValueColumn(s)
	}
}

func (p *UniversalParser) UnpivotMultiValueColumn() (localctx IUnpivotMultiValueColumnContext) {
	localctx = NewUnpivotMultiValueColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, UniversalParserRULE_unpivotMultiValueColumn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1209)
		p.IdentifierSeq()
	}
	{
		p.SetState(1210)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1211)
		p.Match(UniversalParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1212)
		p.UnpivotNameColumn()
	}
	{
		p.SetState(1213)
		p.Match(UniversalParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1214)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1215)

		var _x = p.UnpivotMultiColumnItem()

		localctx.(*UnpivotMultiValueColumnContext)._unpivotMultiColumnItem = _x
	}
	localctx.(*UnpivotMultiValueColumnContext).unpivotColumnSets = append(localctx.(*UnpivotMultiValueColumnContext).unpivotColumnSets, localctx.(*UnpivotMultiValueColumnContext)._unpivotMultiColumnItem)
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1216)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)

			var _x = p.UnpivotMultiColumnItem()

			localctx.(*UnpivotMultiValueColumnContext)._unpivotMultiColumnItem = _x
		}
		localctx.(*UnpivotMultiValueColumnContext).unpivotColumnSets = append(localctx.(*UnpivotMultiValueColumnContext).unpivotColumnSets, localctx.(*UnpivotMultiValueColumnContext)._unpivotMultiColumnItem)

		p.SetState(1222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1223)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotNameColumnContext is an interface to support dynamic dispatch.
type IUnpivotNameColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnpivotNameColumnContext differentiates from other interfaces.
	IsUnpivotNameColumnContext()
}

type UnpivotNameColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotNameColumnContext() *UnpivotNameColumnContext {
	var p = new(UnpivotNameColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotNameColumn
	return p
}

func InitEmptyUnpivotNameColumnContext(p *UnpivotNameColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotNameColumn
}

func (*UnpivotNameColumnContext) IsUnpivotNameColumnContext() {}

func NewUnpivotNameColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotNameColumnContext {
	var p = new(UnpivotNameColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotNameColumn

	return p
}

func (s *UnpivotNameColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotNameColumnContext) CopyAll(ctx *UnpivotNameColumnContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnpivotNameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotNameColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleUnpivotNameColumnContext struct {
	UnpivotNameColumnContext
}

func NewSingleUnpivotNameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleUnpivotNameColumnContext {
	var p = new(SingleUnpivotNameColumnContext)

	InitEmptyUnpivotNameColumnContext(&p.UnpivotNameColumnContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnpivotNameColumnContext))

	return p
}

func (s *SingleUnpivotNameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleUnpivotNameColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleUnpivotNameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSingleUnpivotNameColumn(s)
	}
}

func (s *SingleUnpivotNameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSingleUnpivotNameColumn(s)
	}
}

type MultiUnpivotNameColumnContext struct {
	UnpivotNameColumnContext
}

func NewMultiUnpivotNameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiUnpivotNameColumnContext {
	var p = new(MultiUnpivotNameColumnContext)

	InitEmptyUnpivotNameColumnContext(&p.UnpivotNameColumnContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnpivotNameColumnContext))

	return p
}

func (s *MultiUnpivotNameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiUnpivotNameColumnContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *MultiUnpivotNameColumnContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *MultiUnpivotNameColumnContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *MultiUnpivotNameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiUnpivotNameColumn(s)
	}
}

func (s *MultiUnpivotNameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiUnpivotNameColumn(s)
	}
}

func (p *UniversalParser) UnpivotNameColumn() (localctx IUnpivotNameColumnContext) {
	localctx = NewUnpivotNameColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, UniversalParserRULE_unpivotNameColumn)
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleUnpivotNameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1225)
			p.Identifier()
		}

	case 2:
		localctx = NewMultiUnpivotNameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.IdentifierSeq()
		}
		{
			p.SetState(1228)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnItemContext is an interface to support dynamic dispatch.
type IUnpivotColumnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnpivotColumn() IUnpivotColumnContext
	UnpivotColumnAlias() IUnpivotColumnAliasContext

	// IsUnpivotColumnItemContext differentiates from other interfaces.
	IsUnpivotColumnItemContext()
}

type UnpivotColumnItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnItemContext() *UnpivotColumnItemContext {
	var p = new(UnpivotColumnItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnItem
	return p
}

func InitEmptyUnpivotColumnItemContext(p *UnpivotColumnItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnItem
}

func (*UnpivotColumnItemContext) IsUnpivotColumnItemContext() {}

func NewUnpivotColumnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnItemContext {
	var p = new(UnpivotColumnItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumnItem

	return p
}

func (s *UnpivotColumnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnItemContext) UnpivotColumn() IUnpivotColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnContext)
}

func (s *UnpivotColumnItemContext) UnpivotColumnAlias() IUnpivotColumnAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasContext)
}

func (s *UnpivotColumnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumnItem(s)
	}
}

func (s *UnpivotColumnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumnItem(s)
	}
}

func (p *UniversalParser) UnpivotColumnItem() (localctx IUnpivotColumnItemContext) {
	localctx = NewUnpivotColumnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, UniversalParserRULE_unpivotColumnItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.UnpivotColumn()
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1233)
			p.UnpivotColumnAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotMultiColumnItemContext is an interface to support dynamic dispatch.
type IUnpivotMultiColumnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	MultiIdentifierSeq() IMultiIdentifierSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode
	UnpivotColumnAlias() IUnpivotColumnAliasContext

	// IsUnpivotMultiColumnItemContext differentiates from other interfaces.
	IsUnpivotMultiColumnItemContext()
}

type UnpivotMultiColumnItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotMultiColumnItemContext() *UnpivotMultiColumnItemContext {
	var p = new(UnpivotMultiColumnItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotMultiColumnItem
	return p
}

func InitEmptyUnpivotMultiColumnItemContext(p *UnpivotMultiColumnItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotMultiColumnItem
}

func (*UnpivotMultiColumnItemContext) IsUnpivotMultiColumnItemContext() {}

func NewUnpivotMultiColumnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotMultiColumnItemContext {
	var p = new(UnpivotMultiColumnItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotMultiColumnItem

	return p
}

func (s *UnpivotMultiColumnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotMultiColumnItemContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *UnpivotMultiColumnItemContext) MultiIdentifierSeq() IMultiIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierSeqContext)
}

func (s *UnpivotMultiColumnItemContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *UnpivotMultiColumnItemContext) UnpivotColumnAlias() IUnpivotColumnAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasContext)
}

func (s *UnpivotMultiColumnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotMultiColumnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotMultiColumnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotMultiColumnItem(s)
	}
}

func (s *UnpivotMultiColumnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotMultiColumnItem(s)
	}
}

func (p *UniversalParser) UnpivotMultiColumnItem() (localctx IUnpivotMultiColumnItemContext) {
	localctx = NewUnpivotMultiColumnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, UniversalParserRULE_unpivotMultiColumnItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1237)
		p.MultiIdentifierSeq()
	}
	{
		p.SetState(1238)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1239)
			p.UnpivotColumnAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnAliasContext is an interface to support dynamic dispatch.
type IUnpivotColumnAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnpivotColumnAliasOption() IUnpivotColumnAliasOptionContext
	T_AS() antlr.TerminalNode

	// IsUnpivotColumnAliasContext differentiates from other interfaces.
	IsUnpivotColumnAliasContext()
}

type UnpivotColumnAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnAliasContext() *UnpivotColumnAliasContext {
	var p = new(UnpivotColumnAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAlias
	return p
}

func InitEmptyUnpivotColumnAliasContext(p *UnpivotColumnAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAlias
}

func (*UnpivotColumnAliasContext) IsUnpivotColumnAliasContext() {}

func NewUnpivotColumnAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnAliasContext {
	var p = new(UnpivotColumnAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumnAlias

	return p
}

func (s *UnpivotColumnAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnAliasContext) UnpivotColumnAliasOption() IUnpivotColumnAliasOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasOptionContext)
}

func (s *UnpivotColumnAliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *UnpivotColumnAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumnAlias(s)
	}
}

func (s *UnpivotColumnAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumnAlias(s)
	}
}

func (p *UniversalParser) UnpivotColumnAlias() (localctx IUnpivotColumnAliasContext) {
	localctx = NewUnpivotColumnAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, UniversalParserRULE_unpivotColumnAlias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1242)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1245)
		p.UnpivotColumnAliasOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnAliasOptionContext is an interface to support dynamic dispatch.
type IUnpivotColumnAliasOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnpivotColumnAliasValueList() IUnpivotColumnAliasValueListContext
	UnpivotColumnAliasValue() IUnpivotColumnAliasValueContext

	// IsUnpivotColumnAliasOptionContext differentiates from other interfaces.
	IsUnpivotColumnAliasOptionContext()
}

type UnpivotColumnAliasOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnAliasOptionContext() *UnpivotColumnAliasOptionContext {
	var p = new(UnpivotColumnAliasOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasOption
	return p
}

func InitEmptyUnpivotColumnAliasOptionContext(p *UnpivotColumnAliasOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasOption
}

func (*UnpivotColumnAliasOptionContext) IsUnpivotColumnAliasOptionContext() {}

func NewUnpivotColumnAliasOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnAliasOptionContext {
	var p = new(UnpivotColumnAliasOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasOption

	return p
}

func (s *UnpivotColumnAliasOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnAliasOptionContext) UnpivotColumnAliasValueList() IUnpivotColumnAliasValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasValueListContext)
}

func (s *UnpivotColumnAliasOptionContext) UnpivotColumnAliasValue() IUnpivotColumnAliasValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasValueContext)
}

func (s *UnpivotColumnAliasOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnAliasOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnAliasOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumnAliasOption(s)
	}
}

func (s *UnpivotColumnAliasOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumnAliasOption(s)
	}
}

func (p *UniversalParser) UnpivotColumnAliasOption() (localctx IUnpivotColumnAliasOptionContext) {
	localctx = NewUnpivotColumnAliasOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, UniversalParserRULE_unpivotColumnAliasOption)
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1247)
			p.UnpivotColumnAliasValueList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1248)
			p.UnpivotColumnAliasValue()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnAliasValueListContext is an interface to support dynamic dispatch.
type IUnpivotColumnAliasValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_unpivotColumnAliasValue returns the _unpivotColumnAliasValue rule contexts.
	Get_unpivotColumnAliasValue() IUnpivotColumnAliasValueContext

	// Set_unpivotColumnAliasValue sets the _unpivotColumnAliasValue rule contexts.
	Set_unpivotColumnAliasValue(IUnpivotColumnAliasValueContext)

	// GetUnpivotColumnAliasValues returns the unpivotColumnAliasValues rule context list.
	GetUnpivotColumnAliasValues() []IUnpivotColumnAliasValueContext

	// SetUnpivotColumnAliasValues sets the unpivotColumnAliasValues rule context list.
	SetUnpivotColumnAliasValues([]IUnpivotColumnAliasValueContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllUnpivotColumnAliasValue() []IUnpivotColumnAliasValueContext
	UnpivotColumnAliasValue(i int) IUnpivotColumnAliasValueContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsUnpivotColumnAliasValueListContext differentiates from other interfaces.
	IsUnpivotColumnAliasValueListContext()
}

type UnpivotColumnAliasValueListContext struct {
	antlr.BaseParserRuleContext
	parser                   antlr.Parser
	_unpivotColumnAliasValue IUnpivotColumnAliasValueContext
	unpivotColumnAliasValues []IUnpivotColumnAliasValueContext
}

func NewEmptyUnpivotColumnAliasValueListContext() *UnpivotColumnAliasValueListContext {
	var p = new(UnpivotColumnAliasValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValueList
	return p
}

func InitEmptyUnpivotColumnAliasValueListContext(p *UnpivotColumnAliasValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValueList
}

func (*UnpivotColumnAliasValueListContext) IsUnpivotColumnAliasValueListContext() {}

func NewUnpivotColumnAliasValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnAliasValueListContext {
	var p = new(UnpivotColumnAliasValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValueList

	return p
}

func (s *UnpivotColumnAliasValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnAliasValueListContext) Get_unpivotColumnAliasValue() IUnpivotColumnAliasValueContext {
	return s._unpivotColumnAliasValue
}

func (s *UnpivotColumnAliasValueListContext) Set_unpivotColumnAliasValue(v IUnpivotColumnAliasValueContext) {
	s._unpivotColumnAliasValue = v
}

func (s *UnpivotColumnAliasValueListContext) GetUnpivotColumnAliasValues() []IUnpivotColumnAliasValueContext {
	return s.unpivotColumnAliasValues
}

func (s *UnpivotColumnAliasValueListContext) SetUnpivotColumnAliasValues(v []IUnpivotColumnAliasValueContext) {
	s.unpivotColumnAliasValues = v
}

func (s *UnpivotColumnAliasValueListContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *UnpivotColumnAliasValueListContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *UnpivotColumnAliasValueListContext) AllUnpivotColumnAliasValue() []IUnpivotColumnAliasValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnpivotColumnAliasValueContext); ok {
			len++
		}
	}

	tst := make([]IUnpivotColumnAliasValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnpivotColumnAliasValueContext); ok {
			tst[i] = t.(IUnpivotColumnAliasValueContext)
			i++
		}
	}

	return tst
}

func (s *UnpivotColumnAliasValueListContext) UnpivotColumnAliasValue(i int) IUnpivotColumnAliasValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpivotColumnAliasValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpivotColumnAliasValueContext)
}

func (s *UnpivotColumnAliasValueListContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *UnpivotColumnAliasValueListContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *UnpivotColumnAliasValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnAliasValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnAliasValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumnAliasValueList(s)
	}
}

func (s *UnpivotColumnAliasValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumnAliasValueList(s)
	}
}

func (p *UniversalParser) UnpivotColumnAliasValueList() (localctx IUnpivotColumnAliasValueListContext) {
	localctx = NewUnpivotColumnAliasValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, UniversalParserRULE_unpivotColumnAliasValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1252)

		var _x = p.UnpivotColumnAliasValue()

		localctx.(*UnpivotColumnAliasValueListContext)._unpivotColumnAliasValue = _x
	}
	localctx.(*UnpivotColumnAliasValueListContext).unpivotColumnAliasValues = append(localctx.(*UnpivotColumnAliasValueListContext).unpivotColumnAliasValues, localctx.(*UnpivotColumnAliasValueListContext)._unpivotColumnAliasValue)
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1253)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1254)

			var _x = p.UnpivotColumnAliasValue()

			localctx.(*UnpivotColumnAliasValueListContext)._unpivotColumnAliasValue = _x
		}
		localctx.(*UnpivotColumnAliasValueListContext).unpivotColumnAliasValues = append(localctx.(*UnpivotColumnAliasValueListContext).unpivotColumnAliasValues, localctx.(*UnpivotColumnAliasValueListContext)._unpivotColumnAliasValue)

		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1260)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnAliasValueContext is an interface to support dynamic dispatch.
type IUnpivotColumnAliasValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() IStringContext
	Identifier() IIdentifierContext

	// IsUnpivotColumnAliasValueContext differentiates from other interfaces.
	IsUnpivotColumnAliasValueContext()
}

type UnpivotColumnAliasValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnAliasValueContext() *UnpivotColumnAliasValueContext {
	var p = new(UnpivotColumnAliasValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValue
	return p
}

func InitEmptyUnpivotColumnAliasValueContext(p *UnpivotColumnAliasValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValue
}

func (*UnpivotColumnAliasValueContext) IsUnpivotColumnAliasValueContext() {}

func NewUnpivotColumnAliasValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnAliasValueContext {
	var p = new(UnpivotColumnAliasValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumnAliasValue

	return p
}

func (s *UnpivotColumnAliasValueContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnAliasValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnpivotColumnAliasValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnpivotColumnAliasValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnAliasValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnAliasValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumnAliasValue(s)
	}
}

func (s *UnpivotColumnAliasValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumnAliasValue(s)
	}
}

func (p *UniversalParser) UnpivotColumnAliasValue() (localctx IUnpivotColumnAliasValueContext) {
	localctx = NewUnpivotColumnAliasValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, UniversalParserRULE_unpivotColumnAliasValue)
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1262)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1263)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpivotColumnContext is an interface to support dynamic dispatch.
type IUnpivotColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiIdentifier() IMultiIdentifierContext

	// IsUnpivotColumnContext differentiates from other interfaces.
	IsUnpivotColumnContext()
}

type UnpivotColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpivotColumnContext() *UnpivotColumnContext {
	var p = new(UnpivotColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumn
	return p
}

func InitEmptyUnpivotColumnContext(p *UnpivotColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unpivotColumn
}

func (*UnpivotColumnContext) IsUnpivotColumnContext() {}

func NewUnpivotColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpivotColumnContext {
	var p = new(UnpivotColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unpivotColumn

	return p
}

func (s *UnpivotColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpivotColumnContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *UnpivotColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpivotColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpivotColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnpivotColumn(s)
	}
}

func (s *UnpivotColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnpivotColumn(s)
	}
}

func (p *UniversalParser) UnpivotColumn() (localctx IUnpivotColumnContext) {
	localctx = NewUnpivotColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, UniversalParserRULE_unpivotColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.MultiIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IMultiIdentifierContext

	// GetTabName returns the tabName rule contexts.
	GetTabName() IIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IMultiIdentifierContext)

	// SetTabName sets the tabName rule contexts.
	SetTabName(IIdentifierContext)

	// Getter signatures
	T_LATERAL() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	ExpressionSeqs() IExpressionSeqsContext
	T_AS() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	MultiIdentifier() IMultiIdentifierContext
	Identifier() IIdentifierContext
	T_OUTER() antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IMultiIdentifierContext
	tabName      IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetFunctionName() IMultiIdentifierContext { return s.functionName }

func (s *LateralViewContext) GetTabName() IIdentifierContext { return s.tabName }

func (s *LateralViewContext) SetFunctionName(v IMultiIdentifierContext) { s.functionName = v }

func (s *LateralViewContext) SetTabName(v IIdentifierContext) { s.tabName = v }

func (s *LateralViewContext) T_LATERAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LATERAL, 0)
}

func (s *LateralViewContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *LateralViewContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *LateralViewContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *LateralViewContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *LateralViewContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *LateralViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUTER, 0)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (p *UniversalParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, UniversalParserRULE_lateralView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Match(UniversalParserT_LATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1269)
		p.Match(UniversalParserT_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1270)
			p.Match(UniversalParserT_OUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1273)

		var _x = p.MultiIdentifier()

		localctx.(*LateralViewContext).functionName = _x
	}
	{
		p.SetState(1274)
		p.ExpressionSeqs()
	}
	{
		p.SetState(1275)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tabName = _x
	}
	{
		p.SetState(1276)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1277)
		p.IdentifierSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) T_WHERE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *UniversalParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, UniversalParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1279)
		p.Match(UniversalParserT_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1280)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *UniversalParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, UniversalParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Match(UniversalParserT_HAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1283)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationClauseContext is an interface to support dynamic dispatch.
type IAggregationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAggregationClauseContext differentiates from other interfaces.
	IsAggregationClauseContext()
}

type AggregationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationClauseContext() *AggregationClauseContext {
	var p = new(AggregationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_aggregationClause
	return p
}

func InitEmptyAggregationClauseContext(p *AggregationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_aggregationClause
}

func (*AggregationClauseContext) IsAggregationClauseContext() {}

func NewAggregationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationClauseContext {
	var p = new(AggregationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_aggregationClause

	return p
}

func (s *AggregationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationClauseContext) CopyAll(ctx *AggregationClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AggregationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GroupExprContext struct {
	AggregationClauseContext
	_groupByClause                           IGroupByClauseContext
	groupingExpressionsWithGroupingAnalytics []IGroupByClauseContext
}

func NewGroupExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupExprContext {
	var p = new(GroupExprContext)

	InitEmptyAggregationClauseContext(&p.AggregationClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AggregationClauseContext))

	return p
}

func (s *GroupExprContext) Get_groupByClause() IGroupByClauseContext { return s._groupByClause }

func (s *GroupExprContext) Set_groupByClause(v IGroupByClauseContext) { s._groupByClause = v }

func (s *GroupExprContext) GetGroupingExpressionsWithGroupingAnalytics() []IGroupByClauseContext {
	return s.groupingExpressionsWithGroupingAnalytics
}

func (s *GroupExprContext) SetGroupingExpressionsWithGroupingAnalytics(v []IGroupByClauseContext) {
	s.groupingExpressionsWithGroupingAnalytics = v
}

func (s *GroupExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupExprContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUP, 0)
}

func (s *GroupExprContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *GroupExprContext) AllGroupByClause() []IGroupByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			len++
		}
	}

	tst := make([]IGroupByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByClauseContext); ok {
			tst[i] = t.(IGroupByClauseContext)
			i++
		}
	}

	return tst
}

func (s *GroupExprContext) GroupByClause(i int) IGroupByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *GroupExprContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *GroupExprContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *GroupExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupExpr(s)
	}
}

func (s *GroupExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupExpr(s)
	}
}

type GroupCollectionContext struct {
	AggregationClauseContext
}

func NewGroupCollectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupCollectionContext {
	var p = new(GroupCollectionContext)

	InitEmptyAggregationClauseContext(&p.AggregationClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AggregationClauseContext))

	return p
}

func (s *GroupCollectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupCollectionContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUP, 0)
}

func (s *GroupCollectionContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *GroupCollectionContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *GroupCollectionContext) GroupOption() IGroupOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupOptionContext)
}

func (s *GroupCollectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupCollection(s)
	}
}

func (s *GroupCollectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupCollection(s)
	}
}

func (p *UniversalParser) AggregationClause() (localctx IAggregationClauseContext) {
	localctx = NewAggregationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, UniversalParserRULE_aggregationClause)
	var _alt int

	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGroupExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1285)
			p.Match(UniversalParserT_GROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.Match(UniversalParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1287)

			var _x = p.GroupByClause()

			localctx.(*GroupExprContext)._groupByClause = _x
		}
		localctx.(*GroupExprContext).groupingExpressionsWithGroupingAnalytics = append(localctx.(*GroupExprContext).groupingExpressionsWithGroupingAnalytics, localctx.(*GroupExprContext)._groupByClause)
		p.SetState(1292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1288)
					p.Match(UniversalParserK_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1289)

					var _x = p.GroupByClause()

					localctx.(*GroupExprContext)._groupByClause = _x
				}
				localctx.(*GroupExprContext).groupingExpressionsWithGroupingAnalytics = append(localctx.(*GroupExprContext).groupingExpressionsWithGroupingAnalytics, localctx.(*GroupExprContext)._groupByClause)

			}
			p.SetState(1294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupCollectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1295)
			p.Match(UniversalParserT_GROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Match(UniversalParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.ExpressionSeq()
		}
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1298)
				p.GroupOption()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupOptionContext is an interface to support dynamic dispatch.
type IGroupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupOptionContext differentiates from other interfaces.
	IsGroupOptionContext()
}

type GroupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupOptionContext() *GroupOptionContext {
	var p = new(GroupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupOption
	return p
}

func InitEmptyGroupOptionContext(p *GroupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupOption
}

func (*GroupOptionContext) IsGroupOptionContext() {}

func NewGroupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupOptionContext {
	var p = new(GroupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_groupOption

	return p
}

func (s *GroupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupOptionContext) CopyAll(ctx *GroupOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GroupWithContext struct {
	GroupOptionContext
	kind antlr.Token
}

func NewGroupWithContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupWithContext {
	var p = new(GroupWithContext)

	InitEmptyGroupOptionContext(&p.GroupOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupOptionContext))

	return p
}

func (s *GroupWithContext) GetKind() antlr.Token { return s.kind }

func (s *GroupWithContext) SetKind(v antlr.Token) { s.kind = v }

func (s *GroupWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupWithContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *GroupWithContext) T_ROLLUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLLUP, 0)
}

func (s *GroupWithContext) T_CUBE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CUBE, 0)
}

func (s *GroupWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupWith(s)
	}
}

func (s *GroupWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupWith(s)
	}
}

type GroupWithSetContext struct {
	GroupOptionContext
}

func NewGroupWithSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupWithSetContext {
	var p = new(GroupWithSetContext)

	InitEmptyGroupOptionContext(&p.GroupOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupOptionContext))

	return p
}

func (s *GroupWithSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupWithSetContext) T_GROUPING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUPING, 0)
}

func (s *GroupWithSetContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SETS, 0)
}

func (s *GroupWithSetContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *GroupWithSetContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupWithSetContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupWithSetContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *GroupWithSetContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *GroupWithSetContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *GroupWithSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupWithSet(s)
	}
}

func (s *GroupWithSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupWithSet(s)
	}
}

func (p *UniversalParser) GroupOption() (localctx IGroupOptionContext) {
	localctx = NewGroupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, UniversalParserRULE_groupOption)
	var _la int

	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_WITH:
		localctx = NewGroupWithContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1303)
			p.Match(UniversalParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupWithContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_CUBE || _la == UniversalParserT_ROLLUP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupWithContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case UniversalParserT_GROUPING:
		localctx = NewGroupWithSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1305)
			p.Match(UniversalParserT_GROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1306)
			p.Match(UniversalParserT_SETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1307)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1308)
			p.GroupingSet()
		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(1309)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1310)
				p.GroupingSet()
			}

			p.SetState(1315)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1316)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupingAnalytics() IGroupingAnalyticsContext
	Expression() IExpressionContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GroupingAnalytics() IGroupingAnalyticsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingAnalyticsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingAnalyticsContext)
}

func (s *GroupByClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *UniversalParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, UniversalParserRULE_groupByClause)
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1320)
			p.GroupingAnalytics()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1321)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GroupingAnalytics() IGroupingAnalyticsContext
	GroupingSet() IGroupingSetContext

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) GroupingAnalytics() IGroupingAnalyticsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingAnalyticsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingAnalyticsContext)
}

func (s *GroupingElementContext) GroupingSet() IGroupingSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *UniversalParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, UniversalParserRULE_groupingElement)
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1324)
			p.GroupingAnalytics()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1325)
			p.GroupingSet()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingAnalyticsContext is an interface to support dynamic dispatch.
type IGroupingAnalyticsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingAnalyticsContext differentiates from other interfaces.
	IsGroupingAnalyticsContext()
}

type GroupingAnalyticsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingAnalyticsContext() *GroupingAnalyticsContext {
	var p = new(GroupingAnalyticsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingAnalytics
	return p
}

func InitEmptyGroupingAnalyticsContext(p *GroupingAnalyticsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingAnalytics
}

func (*GroupingAnalyticsContext) IsGroupingAnalyticsContext() {}

func NewGroupingAnalyticsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingAnalyticsContext {
	var p = new(GroupingAnalyticsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_groupingAnalytics

	return p
}

func (s *GroupingAnalyticsContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingAnalyticsContext) CopyAll(ctx *GroupingAnalyticsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingAnalyticsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingAnalyticsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GroupCubeContext struct {
	GroupingAnalyticsContext
	kind antlr.Token
}

func NewGroupCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupCubeContext {
	var p = new(GroupCubeContext)

	InitEmptyGroupingAnalyticsContext(&p.GroupingAnalyticsContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingAnalyticsContext))

	return p
}

func (s *GroupCubeContext) GetKind() antlr.Token { return s.kind }

func (s *GroupCubeContext) SetKind(v antlr.Token) { s.kind = v }

func (s *GroupCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupCubeContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *GroupCubeContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupCubeContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupCubeContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *GroupCubeContext) T_ROLLUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLLUP, 0)
}

func (s *GroupCubeContext) T_CUBE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CUBE, 0)
}

func (s *GroupCubeContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *GroupCubeContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *GroupCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupCube(s)
	}
}

func (s *GroupCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupCube(s)
	}
}

type GroupSetContext struct {
	GroupingAnalyticsContext
}

func NewGroupSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupSetContext {
	var p = new(GroupSetContext)

	InitEmptyGroupingAnalyticsContext(&p.GroupingAnalyticsContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingAnalyticsContext))

	return p
}

func (s *GroupSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupSetContext) T_GROUPING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUPING, 0)
}

func (s *GroupSetContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SETS, 0)
}

func (s *GroupSetContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *GroupSetContext) AllGroupingElement() []IGroupingElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupingElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingElementContext); ok {
			tst[i] = t.(IGroupingElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupSetContext) GroupingElement(i int) IGroupingElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupSetContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *GroupSetContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *GroupSetContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *GroupSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupSet(s)
	}
}

func (s *GroupSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupSet(s)
	}
}

func (p *UniversalParser) GroupingAnalytics() (localctx IGroupingAnalyticsContext) {
	localctx = NewGroupingAnalyticsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, UniversalParserRULE_groupingAnalytics)
	var _la int

	p.SetState(1353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_CUBE, UniversalParserT_ROLLUP:
		localctx = NewGroupCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1328)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupCubeContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_CUBE || _la == UniversalParserT_ROLLUP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupCubeContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1329)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1330)
			p.GroupingSet()
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(1331)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1332)
				p.GroupingSet()
			}

			p.SetState(1337)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1338)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_GROUPING:
		localctx = NewGroupSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1340)
			p.Match(UniversalParserT_GROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Match(UniversalParserT_SETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.GroupingElement()
		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(1344)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1345)
				p.GroupingElement()
			}

			p.SetState(1350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1351)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSeqs() IExpressionSeqsContext
	Expression() IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *GroupingSetContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *UniversalParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, UniversalParserRULE_groupingSet)
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1355)
			p.ExpressionSeqs()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1356)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintContext is an interface to support dynamic dispatch.
type IHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	K_HINT_START() antlr.TerminalNode
	K_HINT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsHintContext differentiates from other interfaces.
	IsHintContext()
}

type HintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptyHintContext() *HintContext {
	var p = new(HintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_hint
	return p
}

func InitEmptyHintContext(p *HintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_hint
}

func (*HintContext) IsHintContext() {}

func NewHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintContext {
	var p = new(HintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_hint

	return p
}

func (s *HintContext) GetParser() antlr.Parser { return s.parser }

func (s *HintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *HintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *HintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *HintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *HintContext) K_HINT_START() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_HINT_START, 0)
}

func (s *HintContext) K_HINT_END() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_HINT_END, 0)
}

func (s *HintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *HintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *HintContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *HintContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *HintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterHint(s)
	}
}

func (s *HintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitHint(s)
	}
}

func (p *UniversalParser) Hint() (localctx IHintContext) {
	localctx = NewHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, UniversalParserRULE_hint)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(UniversalParserK_HINT_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1360)

		var _x = p.HintStatement()

		localctx.(*HintContext)._hintStatement = _x
	}
	localctx.(*HintContext).hintStatements = append(localctx.(*HintContext).hintStatements, localctx.(*HintContext)._hintStatement)
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1362)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1361)
					p.Match(UniversalParserK_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1364)

				var _x = p.HintStatement()

				localctx.(*HintContext)._hintStatement = _x
			}
			localctx.(*HintContext).hintStatements = append(localctx.(*HintContext).hintStatements, localctx.(*HintContext)._hintStatement)

		}
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1370)
		p.Match(UniversalParserK_HINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_defaultExpression returns the _defaultExpression rule contexts.
	Get_defaultExpression() IDefaultExpressionContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_defaultExpression sets the _defaultExpression rule contexts.
	Set_defaultExpression(IDefaultExpressionContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IDefaultExpressionContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IDefaultExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllDefaultExpression() []IDefaultExpressionContext
	DefaultExpression(i int) IDefaultExpressionContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	hintName           IIdentifierContext
	_defaultExpression IDefaultExpressionContext
	parameters         []IDefaultExpressionContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_defaultExpression() IDefaultExpressionContext {
	return s._defaultExpression
}

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_defaultExpression(v IDefaultExpressionContext) {
	s._defaultExpression = v
}

func (s *HintStatementContext) GetParameters() []IDefaultExpressionContext { return s.parameters }

func (s *HintStatementContext) SetParameters(v []IDefaultExpressionContext) { s.parameters = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *HintStatementContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *HintStatementContext) AllDefaultExpression() []IDefaultExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			len++
		}
	}

	tst := make([]IDefaultExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefaultExpressionContext); ok {
			tst[i] = t.(IDefaultExpressionContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) DefaultExpression(i int) IDefaultExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *HintStatementContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *HintStatementContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterHintStatement(s)
	}
}

func (s *HintStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitHintStatement(s)
	}
}

func (p *UniversalParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, UniversalParserRULE_hintStatement)
	var _la int

	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1372)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1373)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}
		{
			p.SetState(1374)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1375)

			var _x = p.defaultExpression(0)

			localctx.(*HintStatementContext)._defaultExpression = _x
		}
		localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._defaultExpression)
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(1376)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1377)

				var _x = p.defaultExpression(0)

				localctx.(*HintStatementContext)._defaultExpression = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._defaultExpression)

			p.SetState(1382)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1383)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_namedExpression returns the _namedExpression rule contexts.
	Get_namedExpression() INamedExpressionContext

	// Set_namedExpression sets the _namedExpression rule contexts.
	Set_namedExpression(INamedExpressionContext)

	// GetNamedExpressionCollection returns the namedExpressionCollection rule context list.
	GetNamedExpressionCollection() []INamedExpressionContext

	// SetNamedExpressionCollection sets the namedExpressionCollection rule context list.
	SetNamedExpressionCollection([]INamedExpressionContext)

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_namedExpression          INamedExpressionContext
	namedExpressionCollection []INamedExpressionContext
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) Get_namedExpression() INamedExpressionContext {
	return s._namedExpression
}

func (s *NamedExpressionSeqContext) Set_namedExpression(v INamedExpressionContext) {
	s._namedExpression = v
}

func (s *NamedExpressionSeqContext) GetNamedExpressionCollection() []INamedExpressionContext {
	return s.namedExpressionCollection
}

func (s *NamedExpressionSeqContext) SetNamedExpressionCollection(v []INamedExpressionContext) {
	s.namedExpressionCollection = v
}

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *NamedExpressionSeqContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNamedExpressionSeq(s)
	}
}

func (s *NamedExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNamedExpressionSeq(s)
	}
}

func (p *UniversalParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, UniversalParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)

		var _x = p.NamedExpression()

		localctx.(*NamedExpressionSeqContext)._namedExpression = _x
	}
	localctx.(*NamedExpressionSeqContext).namedExpressionCollection = append(localctx.(*NamedExpressionSeqContext).namedExpressionCollection, localctx.(*NamedExpressionSeqContext)._namedExpression)
	p.SetState(1392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1388)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1389)

				var _x = p.NamedExpression()

				localctx.(*NamedExpressionSeqContext)._namedExpression = _x
			}
			localctx.(*NamedExpressionSeqContext).namedExpressionCollection = append(localctx.(*NamedExpressionSeqContext).namedExpressionCollection, localctx.(*NamedExpressionSeqContext)._namedExpression)

		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) CopyAll(ctx *NamedExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryColumnContext struct {
	NamedExpressionContext
}

func NewQueryColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryColumnContext {
	var p = new(QueryColumnContext)

	InitEmptyNamedExpressionContext(&p.NamedExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedExpressionContext))

	return p
}

func (s *QueryColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryColumnContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryColumnContext) AliasSpec() IAliasSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasSpecContext)
}

func (s *QueryColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQueryColumn(s)
	}
}

func (s *QueryColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQueryColumn(s)
	}
}

type QueryStarsContext struct {
	NamedExpressionContext
}

func NewQueryStarsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStarsContext {
	var p = new(QueryStarsContext)

	InitEmptyNamedExpressionContext(&p.NamedExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedExpressionContext))

	return p
}

func (s *QueryStarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStarsContext) AllQueryColumns() IAllQueryColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllQueryColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllQueryColumnsContext)
}

func (s *QueryStarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQueryStars(s)
	}
}

func (s *QueryStarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQueryStars(s)
	}
}

func (p *UniversalParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, UniversalParserRULE_namedExpression)
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQueryStarsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1395)
			p.AllQueryColumns()
		}

	case 2:
		localctx = NewQueryColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1396)
			p.Expression()
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1397)
				p.AliasSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllQueryColumnsContext is an interface to support dynamic dispatch.
type IAllQueryColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableSchema returns the tableSchema rule contexts.
	GetTableSchema() IIdentifierContext

	// SetTableSchema sets the tableSchema rule contexts.
	SetTableSchema(IIdentifierContext)

	// Getter signatures
	K_MULTIPLY() antlr.TerminalNode
	K_DOT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAllQueryColumnsContext differentiates from other interfaces.
	IsAllQueryColumnsContext()
}

type AllQueryColumnsContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	tableSchema IIdentifierContext
}

func NewEmptyAllQueryColumnsContext() *AllQueryColumnsContext {
	var p = new(AllQueryColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_allQueryColumns
	return p
}

func InitEmptyAllQueryColumnsContext(p *AllQueryColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_allQueryColumns
}

func (*AllQueryColumnsContext) IsAllQueryColumnsContext() {}

func NewAllQueryColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllQueryColumnsContext {
	var p = new(AllQueryColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_allQueryColumns

	return p
}

func (s *AllQueryColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AllQueryColumnsContext) GetTableSchema() IIdentifierContext { return s.tableSchema }

func (s *AllQueryColumnsContext) SetTableSchema(v IIdentifierContext) { s.tableSchema = v }

func (s *AllQueryColumnsContext) K_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MULTIPLY, 0)
}

func (s *AllQueryColumnsContext) K_DOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_DOT, 0)
}

func (s *AllQueryColumnsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AllQueryColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllQueryColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllQueryColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterAllQueryColumns(s)
	}
}

func (s *AllQueryColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitAllQueryColumns(s)
	}
}

func (p *UniversalParser) AllQueryColumns() (localctx IAllQueryColumnsContext) {
	localctx = NewAllQueryColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, UniversalParserRULE_allQueryColumns)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1402)

			var _x = p.Identifier()

			localctx.(*AllQueryColumnsContext).tableSchema = _x
		}
		{
			p.SetState(1403)
			p.Match(UniversalParserK_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1407)
		p.Match(UniversalParserK_MULTIPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSeqsContext is an interface to support dynamic dispatch.
type IExpressionSeqsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsExpressionSeqsContext differentiates from other interfaces.
	IsExpressionSeqsContext()
}

type ExpressionSeqsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSeqsContext() *ExpressionSeqsContext {
	var p = new(ExpressionSeqsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expressionSeqs
	return p
}

func InitEmptyExpressionSeqsContext(p *ExpressionSeqsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expressionSeqs
}

func (*ExpressionSeqsContext) IsExpressionSeqsContext() {}

func NewExpressionSeqsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSeqsContext {
	var p = new(ExpressionSeqsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_expressionSeqs

	return p
}

func (s *ExpressionSeqsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSeqsContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *ExpressionSeqsContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *ExpressionSeqsContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *ExpressionSeqsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSeqsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSeqsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExpressionSeqs(s)
	}
}

func (s *ExpressionSeqsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExpressionSeqs(s)
	}
}

func (p *UniversalParser) ExpressionSeqs() (localctx IExpressionSeqsContext) {
	localctx = NewExpressionSeqsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, UniversalParserRULE_expressionSeqs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.ExpressionSeq()
	}
	{
		p.SetState(1411)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSeqContext is an interface to support dynamic dispatch.
type IExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetExpressionCollection returns the expressionCollection rule context list.
	GetExpressionCollection() []IExpressionContext

	// SetExpressionCollection sets the expressionCollection rule context list.
	SetExpressionCollection([]IExpressionContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsExpressionSeqContext differentiates from other interfaces.
	IsExpressionSeqContext()
}

type ExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_expression          IExpressionContext
	expressionCollection []IExpressionContext
}

func NewEmptyExpressionSeqContext() *ExpressionSeqContext {
	var p = new(ExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expressionSeq
	return p
}

func InitEmptyExpressionSeqContext(p *ExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expressionSeq
}

func (*ExpressionSeqContext) IsExpressionSeqContext() {}

func NewExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSeqContext {
	var p = new(ExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_expressionSeq

	return p
}

func (s *ExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSeqContext) Get_expression() IExpressionContext { return s._expression }

func (s *ExpressionSeqContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *ExpressionSeqContext) GetExpressionCollection() []IExpressionContext {
	return s.expressionCollection
}

func (s *ExpressionSeqContext) SetExpressionCollection(v []IExpressionContext) {
	s.expressionCollection = v
}

func (s *ExpressionSeqContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSeqContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSeqContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *ExpressionSeqContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *ExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExpressionSeq(s)
	}
}

func (s *ExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExpressionSeq(s)
	}
}

func (p *UniversalParser) ExpressionSeq() (localctx IExpressionSeqContext) {
	localctx = NewExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, UniversalParserRULE_expressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)

		var _x = p.Expression()

		localctx.(*ExpressionSeqContext)._expression = _x
	}
	localctx.(*ExpressionSeqContext).expressionCollection = append(localctx.(*ExpressionSeqContext).expressionCollection, localctx.(*ExpressionSeqContext)._expression)
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1414)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1415)

				var _x = p.Expression()

				localctx.(*ExpressionSeqContext)._expression = _x
			}
			localctx.(*ExpressionSeqContext).expressionCollection = append(localctx.(*ExpressionSeqContext).expressionCollection, localctx.(*ExpressionSeqContext)._expression)

		}
		p.SetState(1420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *UniversalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, UniversalParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1421)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
	reservedOpt antlr.Token
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetReservedOpt() antlr.Token { return s.reservedOpt }

func (s *LogicalNotContext) SetReservedOpt(v antlr.Token) { s.reservedOpt = v }

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *LogicalNotContext) K_EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EXCLAMATION, 0)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type ExistsContext struct {
	BooleanExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXISTS, 0)
}

func (s *ExistsContext) SubQueryExpress() ISubQueryExpressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExists(s)
	}
}

type DefaultBinaryContext struct {
	BooleanExpressionContext
}

func NewDefaultBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultBinaryContext {
	var p = new(DefaultBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *DefaultBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultBinaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DefaultBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDefaultBinary(s)
	}
}

func (s *DefaultBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDefaultBinary(s)
	}
}

type BooleanPriorityContext struct {
	BooleanExpressionContext
}

func NewBooleanPriorityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanPriorityContext {
	var p = new(BooleanPriorityContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanPriorityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanPriorityContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *BooleanPriorityContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *BooleanPriorityContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *BooleanPriorityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBooleanPriority(s)
	}
}

func (s *BooleanPriorityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBooleanPriority(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) T_AND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AND, 0)
}

func (s *LogicalBinaryContext) T_OR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *UniversalParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *UniversalParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 214
	p.EnterRecursionRule(localctx, 214, UniversalParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBooleanPriorityContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1424)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1425)
			p.booleanExpression(0)
		}
		{
			p.SetState(1426)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1428)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LogicalNotContext).reservedOpt = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_NOT || _la == UniversalParserK_EXCLAMATION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LogicalNotContext).reservedOpt = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1429)
			p.booleanExpression(6)
		}

	case 3:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1430)
			p.Match(UniversalParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1431)
			p.SubQueryExpress()
		}

	case 4:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1432)
			p.valueExpression(0)
		}
		{
			p.SetState(1433)
			p.Predicate()
		}

	case 5:
		localctx = NewDefaultBinaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1435)
			p.valueExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_booleanExpression)
				p.SetState(1438)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1439)

					var _m = p.Match(UniversalParserT_AND)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1440)

					var _x = p.booleanExpression(5)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_booleanExpression)
				p.SetState(1441)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1442)

					var _m = p.Match(UniversalParserT_OR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1443)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BetweenPredicatedContext struct {
	PredicateContext
	kind  antlr.Token
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicatedContext {
	var p = new(BetweenPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *BetweenPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *BetweenPredicatedContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenPredicatedContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenPredicatedContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenPredicatedContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicatedContext) T_AND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AND, 0)
}

func (s *BetweenPredicatedContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BETWEEN, 0)
}

func (s *BetweenPredicatedContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicatedContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *BetweenPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBetweenPredicated(s)
	}
}

func (s *BetweenPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBetweenPredicated(s)
	}
}

type RegexpPredicatedContext struct {
	PredicateContext
	kind    antlr.Token
	pattern IValueExpressionContext
}

func NewRegexpPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicatedContext {
	var p = new(RegexpPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *RegexpPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *RegexpPredicatedContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *RegexpPredicatedContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *RegexpPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicatedContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP, 0)
}

func (s *RegexpPredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *RegexpPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *RegexpPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRegexpPredicated(s)
	}
}

func (s *RegexpPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRegexpPredicated(s)
	}
}

type InValuePredicatedContext struct {
	PredicateContext
	kind antlr.Token
}

func NewInValuePredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InValuePredicatedContext {
	var p = new(InValuePredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InValuePredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *InValuePredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *InValuePredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InValuePredicatedContext) ExpressionSeqs() IExpressionSeqsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqsContext)
}

func (s *InValuePredicatedContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *InValuePredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *InValuePredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInValuePredicated(s)
	}
}

func (s *InValuePredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInValuePredicated(s)
	}
}

type LikePatternPredicatedContext struct {
	PredicateContext
	kind    antlr.Token
	pattern IValueExpressionContext
	escape  IStringContext
}

func NewLikePatternPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePatternPredicatedContext {
	var p = new(LikePatternPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikePatternPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *LikePatternPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *LikePatternPredicatedContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikePatternPredicatedContext) GetEscape() IStringContext { return s.escape }

func (s *LikePatternPredicatedContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikePatternPredicatedContext) SetEscape(v IStringContext) { s.escape = v }

func (s *LikePatternPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePatternPredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikePatternPredicatedContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIKE, 0)
}

func (s *LikePatternPredicatedContext) T_ILIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ILIKE, 0)
}

func (s *LikePatternPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *LikePatternPredicatedContext) T_ESCAPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ESCAPE, 0)
}

func (s *LikePatternPredicatedContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *LikePatternPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLikePatternPredicated(s)
	}
}

func (s *LikePatternPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLikePatternPredicated(s)
	}
}

type BooleanPredicatedContext struct {
	PredicateContext
	kind antlr.Token
}

func NewBooleanPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanPredicatedContext {
	var p = new(BooleanPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BooleanPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *BooleanPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *BooleanPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanPredicatedContext) T_IS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IS, 0)
}

func (s *BooleanPredicatedContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRUE, 0)
}

func (s *BooleanPredicatedContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FALSE, 0)
}

func (s *BooleanPredicatedContext) T_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNKNOWN, 0)
}

func (s *BooleanPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *BooleanPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBooleanPredicated(s)
	}
}

func (s *BooleanPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBooleanPredicated(s)
	}
}

type NullPredicatedContext struct {
	PredicateContext
	kind antlr.Token
}

func NewNullPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicatedContext {
	var p = new(NullPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *NullPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *NullPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicatedContext) T_IS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IS, 0)
}

func (s *NullPredicatedContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULL, 0)
}

func (s *NullPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *NullPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNullPredicated(s)
	}
}

func (s *NullPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNullPredicated(s)
	}
}

type InQueryPredicatedContext struct {
	PredicateContext
	kind antlr.Token
}

func NewInQueryPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InQueryPredicatedContext {
	var p = new(InQueryPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InQueryPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *InQueryPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *InQueryPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InQueryPredicatedContext) SubQueryExpress() ISubQueryExpressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressContext)
}

func (s *InQueryPredicatedContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *InQueryPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *InQueryPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInQueryPredicated(s)
	}
}

func (s *InQueryPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInQueryPredicated(s)
	}
}

type RlikePredicatedContext struct {
	PredicateContext
	kind    antlr.Token
	pattern IValueExpressionContext
}

func NewRlikePredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RlikePredicatedContext {
	var p = new(RlikePredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *RlikePredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *RlikePredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *RlikePredicatedContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *RlikePredicatedContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *RlikePredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RlikePredicatedContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RLIKE, 0)
}

func (s *RlikePredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *RlikePredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *RlikePredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRlikePredicated(s)
	}
}

func (s *RlikePredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRlikePredicated(s)
	}
}

type LikeQuantifierPredicatedContext struct {
	PredicateContext
	kind       antlr.Token
	quantifier antlr.Token
}

func NewLikeQuantifierPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeQuantifierPredicatedContext {
	var p = new(LikeQuantifierPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikeQuantifierPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *LikeQuantifierPredicatedContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *LikeQuantifierPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *LikeQuantifierPredicatedContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *LikeQuantifierPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeQuantifierPredicatedContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *LikeQuantifierPredicatedContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *LikeQuantifierPredicatedContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIKE, 0)
}

func (s *LikeQuantifierPredicatedContext) T_ILIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ILIKE, 0)
}

func (s *LikeQuantifierPredicatedContext) T_ANY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANY, 0)
}

func (s *LikeQuantifierPredicatedContext) T_SOME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SOME, 0)
}

func (s *LikeQuantifierPredicatedContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALL, 0)
}

func (s *LikeQuantifierPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *LikeQuantifierPredicatedContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *LikeQuantifierPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLikeQuantifierPredicated(s)
	}
}

func (s *LikeQuantifierPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLikeQuantifierPredicated(s)
	}
}

type DistinctFromPredicatedContext struct {
	PredicateContext
	kind  antlr.Token
	right IValueExpressionContext
}

func NewDistinctFromPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromPredicatedContext {
	var p = new(DistinctFromPredicatedContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromPredicatedContext) GetKind() antlr.Token { return s.kind }

func (s *DistinctFromPredicatedContext) SetKind(v antlr.Token) { s.kind = v }

func (s *DistinctFromPredicatedContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromPredicatedContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromPredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromPredicatedContext) T_IS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IS, 0)
}

func (s *DistinctFromPredicatedContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *DistinctFromPredicatedContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISTINCT, 0)
}

func (s *DistinctFromPredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromPredicatedContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *DistinctFromPredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDistinctFromPredicated(s)
	}
}

func (s *DistinctFromPredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDistinctFromPredicated(s)
	}
}

func (p *UniversalParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, UniversalParserRULE_predicate)
	var _la int

	p.SetState(1513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBetweenPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1449)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1452)

			var _m = p.Match(UniversalParserT_BETWEEN)

			localctx.(*BetweenPredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1453)

			var _x = p.valueExpression(0)

			localctx.(*BetweenPredicatedContext).lower = _x
		}
		{
			p.SetState(1454)
			p.Match(UniversalParserT_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1455)

			var _x = p.valueExpression(0)

			localctx.(*BetweenPredicatedContext).upper = _x
		}

	case 2:
		localctx = NewInValuePredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1457)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1460)

			var _m = p.Match(UniversalParserT_IN)

			localctx.(*InValuePredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.ExpressionSeqs()
		}

	case 3:
		localctx = NewInQueryPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1462)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1465)

			var _m = p.Match(UniversalParserT_IN)

			localctx.(*InQueryPredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.SubQueryExpress()
		}

	case 4:
		localctx = NewRlikePredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1467)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1470)

			var _m = p.Match(UniversalParserT_RLIKE)

			localctx.(*RlikePredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1471)

			var _x = p.valueExpression(0)

			localctx.(*RlikePredicatedContext).pattern = _x
		}

	case 5:
		localctx = NewRegexpPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1472)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1475)

			var _m = p.Match(UniversalParserT_REGEXP)

			localctx.(*RegexpPredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)

			var _x = p.valueExpression(0)

			localctx.(*RegexpPredicatedContext).pattern = _x
		}

	case 6:
		localctx = NewLikeQuantifierPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1477)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1480)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeQuantifierPredicatedContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_LIKE || _la == UniversalParserT_ILIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeQuantifierPredicatedContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1481)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeQuantifierPredicatedContext).quantifier = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_ALL || _la == UniversalParserT_ANY || _la == UniversalParserT_SOME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeQuantifierPredicatedContext).quantifier = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1482)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1483)
				p.ExpressionSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1486)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewLikePatternPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1487)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1490)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikePatternPredicatedContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_LIKE || _la == UniversalParserT_ILIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikePatternPredicatedContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1491)

			var _x = p.valueExpression(0)

			localctx.(*LikePatternPredicatedContext).pattern = _x
		}
		p.SetState(1494)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1492)
				p.Match(UniversalParserT_ESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1493)

				var _x = p.String_()

				localctx.(*LikePatternPredicatedContext).escape = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewNullPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1496)
			p.Match(UniversalParserT_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1497)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1500)

			var _m = p.Match(UniversalParserT_NULL)

			localctx.(*NullPredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewBooleanPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1501)
			p.Match(UniversalParserT_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1502)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1505)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BooleanPredicatedContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_FALSE || _la == UniversalParserT_TRUE || _la == UniversalParserT_UNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BooleanPredicatedContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		localctx = NewDistinctFromPredicatedContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1506)
			p.Match(UniversalParserT_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NOT {
			{
				p.SetState(1507)
				p.Match(UniversalParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1510)

			var _m = p.Match(UniversalParserT_DISTINCT)

			localctx.(*DistinctFromPredicatedContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1511)
			p.Match(UniversalParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromPredicatedContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DefaultUnaryContext struct {
	ValueExpressionContext
}

func NewDefaultUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultUnaryContext {
	var p = new(DefaultUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *DefaultUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultUnaryContext) DefaultExpression() IDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *DefaultUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDefaultUnary(s)
	}
}

func (s *DefaultUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDefaultUnary(s)
	}
}

type ValuePriorityContext struct {
	ValueExpressionContext
	mid IValueExpressionContext
}

func NewValuePriorityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuePriorityContext {
	var p = new(ValuePriorityContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValuePriorityContext) GetMid() IValueExpressionContext { return s.mid }

func (s *ValuePriorityContext) SetMid(v IValueExpressionContext) { s.mid = v }

func (s *ValuePriorityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuePriorityContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *ValuePriorityContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *ValuePriorityContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValuePriorityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterValuePriority(s)
	}
}

func (s *ValuePriorityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitValuePriority(s)
	}
}

type ArithmeticUnaryReverseContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryReverseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryReverseContext {
	var p = new(ArithmeticUnaryReverseContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryReverseContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryReverseContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryReverseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryReverseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryReverseContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_ADD, 0)
}

func (s *ArithmeticUnaryReverseContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *ArithmeticUnaryReverseContext) K_TILDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_TILDE, 0)
}

func (s *ArithmeticUnaryReverseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterArithmeticUnaryReverse(s)
	}
}

func (s *ArithmeticUnaryReverseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitArithmeticUnaryReverse(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) K_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MULTIPLY, 0)
}

func (s *ArithmeticBinaryContext) K_DIVIDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_DIVIDE, 0)
}

func (s *ArithmeticBinaryContext) K_PERCENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_PERCENT, 0)
}

func (s *ArithmeticBinaryContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIV, 0)
}

func (s *ArithmeticBinaryContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_ADD, 0)
}

func (s *ArithmeticBinaryContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *ArithmeticBinaryContext) K_CONCAT_PIPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CONCAT_PIPE, 0)
}

func (s *ArithmeticBinaryContext) K_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_AMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) K_HAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_HAT, 0)
}

func (s *ArithmeticBinaryContext) K_PIPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_PIPE, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type CompareBinaryContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewCompareBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CompareBinaryContext {
	var p = new(CompareBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *CompareBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *CompareBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *CompareBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *CompareBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *CompareBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompareBinaryContext) CompareOperator() ICompareOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompareOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompareOperatorContext)
}

func (s *CompareBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CompareBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CompareBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCompareBinary(s)
	}
}

func (s *CompareBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCompareBinary(s)
	}
}

func (p *UniversalParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *UniversalParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 218
	p.EnterRecursionRule(localctx, 218, UniversalParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValuePriorityContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1516)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)

			var _x = p.valueExpression(0)

			localctx.(*ValuePriorityContext).mid = _x
		}
		{
			p.SetState(1518)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewArithmeticUnaryReverseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1520)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryReverseContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-759)) & ^0x3f) == 0 && ((int64(1)<<(_la-759))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryReverseContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1521)
			p.valueExpression(8)
		}

	case 3:
		localctx = NewDefaultUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1522)
			p.defaultExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1525)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1526)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == UniversalParserT_DIV || ((int64((_la-761)) & ^0x3f) == 0 && ((int64(1)<<(_la-761))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1527)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1528)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1529)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-759)) & ^0x3f) == 0 && ((int64(1)<<(_la-759))&4099) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1530)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1531)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1532)

					var _m = p.Match(UniversalParserK_AMPERSAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1533)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1534)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1535)

					var _m = p.Match(UniversalParserK_HAT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1536)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1537)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1538)

					var _m = p.Match(UniversalParserK_PIPE)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1539)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewCompareBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*CompareBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_valueExpression)
				p.SetState(1540)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1541)
					p.CompareOperator()
				}
				{
					p.SetState(1542)

					var _x = p.valueExpression(3)

					localctx.(*CompareBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultExpressionContext is an interface to support dynamic dispatch.
type IDefaultExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDefaultExpressionContext differentiates from other interfaces.
	IsDefaultExpressionContext()
}

type DefaultExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultExpressionContext() *DefaultExpressionContext {
	var p = new(DefaultExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_defaultExpression
	return p
}

func InitEmptyDefaultExpressionContext(p *DefaultExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_defaultExpression
}

func (*DefaultExpressionContext) IsDefaultExpressionContext() {}

func NewDefaultExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultExpressionContext {
	var p = new(DefaultExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_defaultExpression

	return p
}

func (s *DefaultExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultExpressionContext) CopyAll(ctx *DefaultExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DefaultExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	DefaultExpressionContext
	base      IIdentifierContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IIdentifierContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IIdentifierContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) K_DOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_DOT, 0)
}

func (s *DereferenceContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DereferenceContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type ColumnReferenceContext struct {
	DefaultExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type CaseExpressionContext struct {
	DefaultExpressionContext
}

func NewCaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) CaseExpress() ICaseExpressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressContext)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

type FixValueContext struct {
	DefaultExpressionContext
}

func NewFixValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FixValueContext {
	var p = new(FixValueContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *FixValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FixValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFixValue(s)
	}
}

func (s *FixValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFixValue(s)
	}
}

type SubQueryExpressionContext struct {
	DefaultExpressionContext
}

func NewSubQueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubQueryExpressionContext {
	var p = new(SubQueryExpressionContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *SubQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQueryExpressionContext) SubQueryExpress() ISubQueryExpressContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubQueryExpressContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubQueryExpressContext)
}

func (s *SubQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSubQueryExpression(s)
	}
}

func (s *SubQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSubQueryExpression(s)
	}
}

type FunctionExpressionContext struct {
	DefaultExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) Function() IFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

type SubScriptContext struct {
	DefaultExpressionContext
	value IDefaultExpressionContext
	index IValueExpressionContext
}

func NewSubScriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubScriptContext {
	var p = new(SubScriptContext)

	InitEmptyDefaultExpressionContext(&p.DefaultExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*DefaultExpressionContext))

	return p
}

func (s *SubScriptContext) GetValue() IDefaultExpressionContext { return s.value }

func (s *SubScriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubScriptContext) SetValue(v IDefaultExpressionContext) { s.value = v }

func (s *SubScriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubScriptContext) K_OPEN_BRACKET() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_BRACKET, 0)
}

func (s *SubScriptContext) K_CLOSE_BRACKET() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_BRACKET, 0)
}

func (s *SubScriptContext) DefaultExpression() IDefaultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultExpressionContext)
}

func (s *SubScriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSubScript(s)
	}
}

func (s *SubScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSubScript(s)
	}
}

func (p *UniversalParser) DefaultExpression() (localctx IDefaultExpressionContext) {
	return p.defaultExpression(0)
}

func (p *UniversalParser) defaultExpression(_p int) (localctx IDefaultExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDefaultExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDefaultExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 220
	p.EnterRecursionRule(localctx, 220, UniversalParserRULE_defaultExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1550)
			p.CaseExpress()
		}

	case 2:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1551)
			p.Function()
		}

	case 3:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1552)
			p.Identifier()
		}

	case 4:
		localctx = NewDereferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1553)

			var _x = p.Identifier()

			localctx.(*DereferenceContext).base = _x
		}
		{
			p.SetState(1554)
			p.Match(UniversalParserK_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1555)

			var _x = p.Identifier()

			localctx.(*DereferenceContext).fieldName = _x
		}

	case 5:
		localctx = NewSubQueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1557)
			p.SubQueryExpress()
		}

	case 6:
		localctx = NewFixValueContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1558)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSubScriptContext(p, NewDefaultExpressionContext(p, _parentctx, _parentState))
			localctx.(*SubScriptContext).value = _prevctx

			p.PushNewRecursionContext(localctx, _startState, UniversalParserRULE_defaultExpression)
			p.SetState(1561)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1562)
				p.Match(UniversalParserK_OPEN_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1563)

				var _x = p.valueExpression(0)

				localctx.(*SubScriptContext).index = _x
			}
			{
				p.SetState(1564)
				p.Match(UniversalParserK_CLOSE_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseExpressContext is an interface to support dynamic dispatch.
type ICaseExpressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SearchedCase() ISearchedCaseContext
	SimpleCase() ISimpleCaseContext

	// IsCaseExpressContext differentiates from other interfaces.
	IsCaseExpressContext()
}

type CaseExpressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressContext() *CaseExpressContext {
	var p = new(CaseExpressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_caseExpress
	return p
}

func InitEmptyCaseExpressContext(p *CaseExpressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_caseExpress
}

func (*CaseExpressContext) IsCaseExpressContext() {}

func NewCaseExpressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressContext {
	var p = new(CaseExpressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_caseExpress

	return p
}

func (s *CaseExpressContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressContext) SearchedCase() ISearchedCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchedCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchedCaseContext)
}

func (s *CaseExpressContext) SimpleCase() ISimpleCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCaseContext)
}

func (s *CaseExpressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCaseExpress(s)
	}
}

func (s *CaseExpressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCaseExpress(s)
	}
}

func (p *UniversalParser) CaseExpress() (localctx ICaseExpressContext) {
	localctx = NewCaseExpressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, UniversalParserRULE_caseExpress)
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1571)
			p.SearchedCase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1572)
			p.SimpleCase()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchedCaseContext is an interface to support dynamic dispatch.
type ISearchedCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	ElseClause() IElseClauseContext

	// IsSearchedCaseContext differentiates from other interfaces.
	IsSearchedCaseContext()
}

type SearchedCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchedCaseContext() *SearchedCaseContext {
	var p = new(SearchedCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_searchedCase
	return p
}

func InitEmptySearchedCaseContext(p *SearchedCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_searchedCase
}

func (*SearchedCaseContext) IsSearchedCaseContext() {}

func NewSearchedCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_searchedCase

	return p
}

func (s *SearchedCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchedCaseContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CASE, 0)
}

func (s *SearchedCaseContext) T_END() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_END, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *UniversalParser) SearchedCase() (localctx ISearchedCaseContext) {
	localctx = NewSearchedCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, UniversalParserRULE_searchedCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Match(UniversalParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == UniversalParserT_WHEN {
		{
			p.SetState(1576)
			p.WhenClause()
		}

		p.SetState(1579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ELSE {
		{
			p.SetState(1581)
			p.ElseClause()
		}

	}
	{
		p.SetState(1584)
		p.Match(UniversalParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCaseContext is an interface to support dynamic dispatch.
type ISimpleCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	T_CASE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	Expression() IExpressionContext
	AllWhenClause() []IWhenClauseContext
	WhenClause(i int) IWhenClauseContext
	ElseClause() IElseClauseContext

	// IsSimpleCaseContext differentiates from other interfaces.
	IsSimpleCaseContext()
}

type SimpleCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
}

func NewEmptySimpleCaseContext() *SimpleCaseContext {
	var p = new(SimpleCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_simpleCase
	return p
}

func InitEmptySimpleCaseContext(p *SimpleCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_simpleCase
}

func (*SimpleCaseContext) IsSimpleCaseContext() {}

func NewSimpleCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_simpleCase

	return p
}

func (s *SimpleCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CASE, 0)
}

func (s *SimpleCaseContext) T_END() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_END, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (p *UniversalParser) SimpleCase() (localctx ISimpleCaseContext) {
	localctx = NewSimpleCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, UniversalParserRULE_simpleCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.Match(UniversalParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1587)

		var _x = p.Expression()

		localctx.(*SimpleCaseContext).value = _x
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == UniversalParserT_WHEN {
		{
			p.SetState(1588)
			p.WhenClause()
		}

		p.SetState(1591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ELSE {
		{
			p.SetState(1593)
			p.ElseClause()
		}

	}
	{
		p.SetState(1596)
		p.Match(UniversalParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	T_WHEN() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WHEN, 0)
}

func (s *WhenClauseContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_THEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *UniversalParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, UniversalParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1598)
		p.Match(UniversalParserT_WHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1599)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1600)
		p.Match(UniversalParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1601)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ELSE, 0)
}

func (s *ElseClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterElseClause(s)
	}
}

func (s *ElseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitElseClause(s)
	}
}

func (p *UniversalParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, UniversalParserRULE_elseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)
		p.Match(UniversalParserT_ELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1604)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SpecFunction() ISpecFunctionContext
	StandardFunction() IStandardFunctionContext

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_function
	return p
}

func InitEmptyFunctionContext(p *FunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_function
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) SpecFunction() ISpecFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecFunctionContext)
}

func (s *FunctionContext) StandardFunction() IStandardFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFunctionContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFunction(s)
	}
}

func (p *UniversalParser) Function() (localctx IFunctionContext) {
	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, UniversalParserRULE_function)
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1606)
			p.SpecFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1607)
			p.StandardFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecFunctionContext is an interface to support dynamic dispatch.
type ISpecFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CastFunction() ICastFunctionContext
	StructFunction() IStructFunctionContext
	FirstFunction() IFirstFunctionContext
	AnyValueFunction() IAnyValueFunctionContext
	LastFunction() ILastFunctionContext
	TrimFunction() ITrimFunctionContext
	ExtractFunction() IExtractFunctionContext
	SubstringFunction() ISubstringFunctionContext
	OverlayFunction() IOverlayFunctionContext
	PercentileFunction() IPercentileFunctionContext
	TransArrayFunction() ITransArrayFunctionContext

	// IsSpecFunctionContext differentiates from other interfaces.
	IsSpecFunctionContext()
}

type SpecFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecFunctionContext() *SpecFunctionContext {
	var p = new(SpecFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_specFunction
	return p
}

func InitEmptySpecFunctionContext(p *SpecFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_specFunction
}

func (*SpecFunctionContext) IsSpecFunctionContext() {}

func NewSpecFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecFunctionContext {
	var p = new(SpecFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_specFunction

	return p
}

func (s *SpecFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecFunctionContext) CastFunction() ICastFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastFunctionContext)
}

func (s *SpecFunctionContext) StructFunction() IStructFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFunctionContext)
}

func (s *SpecFunctionContext) FirstFunction() IFirstFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFirstFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFirstFunctionContext)
}

func (s *SpecFunctionContext) AnyValueFunction() IAnyValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyValueFunctionContext)
}

func (s *SpecFunctionContext) LastFunction() ILastFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFunctionContext)
}

func (s *SpecFunctionContext) TrimFunction() ITrimFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimFunctionContext)
}

func (s *SpecFunctionContext) ExtractFunction() IExtractFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtractFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtractFunctionContext)
}

func (s *SpecFunctionContext) SubstringFunction() ISubstringFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubstringFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubstringFunctionContext)
}

func (s *SpecFunctionContext) OverlayFunction() IOverlayFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverlayFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverlayFunctionContext)
}

func (s *SpecFunctionContext) PercentileFunction() IPercentileFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPercentileFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPercentileFunctionContext)
}

func (s *SpecFunctionContext) TransArrayFunction() ITransArrayFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransArrayFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransArrayFunctionContext)
}

func (s *SpecFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSpecFunction(s)
	}
}

func (s *SpecFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSpecFunction(s)
	}
}

func (p *UniversalParser) SpecFunction() (localctx ISpecFunctionContext) {
	localctx = NewSpecFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, UniversalParserRULE_specFunction)
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserT_CAST, UniversalParserT_TRY_CAST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1610)
			p.CastFunction()
		}

	case UniversalParserT_STRUCT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1611)
			p.StructFunction()
		}

	case UniversalParserT_FIRST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1612)
			p.FirstFunction()
		}

	case UniversalParserT_ANY_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1613)
			p.AnyValueFunction()
		}

	case UniversalParserT_LAST:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1614)
			p.LastFunction()
		}

	case UniversalParserT_TRIM, UniversalParserT_LTRIM, UniversalParserT_RTRIM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1615)
			p.TrimFunction()
		}

	case UniversalParserT_EXTRACT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1616)
			p.ExtractFunction()
		}

	case UniversalParserT_SUBSTR, UniversalParserT_SUBSTRING:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1617)
			p.SubstringFunction()
		}

	case UniversalParserT_OVERLAY:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1618)
			p.OverlayFunction()
		}

	case UniversalParserT_PERCENTILE_CONT, UniversalParserT_PERCENTILE_DISC:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1619)
			p.PercentileFunction()
		}

	case UniversalParserT_TRANS_ARRAY:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1620)
			p.TransArrayFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastFunctionContext is an interface to support dynamic dispatch.
type ICastFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	T_AS() antlr.TerminalNode
	DataType() IDataTypeContext
	K_CLOSE_PAREN() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_TRY_CAST() antlr.TerminalNode

	// IsCastFunctionContext differentiates from other interfaces.
	IsCastFunctionContext()
}

type CastFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyCastFunctionContext() *CastFunctionContext {
	var p = new(CastFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_castFunction
	return p
}

func InitEmptyCastFunctionContext(p *CastFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_castFunction
}

func (*CastFunctionContext) IsCastFunctionContext() {}

func NewCastFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastFunctionContext {
	var p = new(CastFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_castFunction

	return p
}

func (s *CastFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastFunctionContext) GetName() antlr.Token { return s.name }

func (s *CastFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *CastFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *CastFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastFunctionContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *CastFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *CastFunctionContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CAST, 0)
}

func (s *CastFunctionContext) T_TRY_CAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRY_CAST, 0)
}

func (s *CastFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCastFunction(s)
	}
}

func (s *CastFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCastFunction(s)
	}
}

func (p *UniversalParser) CastFunction() (localctx ICastFunctionContext) {
	localctx = NewCastFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, UniversalParserRULE_castFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CastFunctionContext).name = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_CAST || _la == UniversalParserT_TRY_CAST) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CastFunctionContext).name = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1624)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1625)
		p.Expression()
	}
	{
		p.SetState(1626)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1627)
		p.DataType()
	}
	{
		p.SetState(1628)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFunctionContext is an interface to support dynamic dispatch.
type IStructFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_namedExpression returns the _namedExpression rule contexts.
	Get_namedExpression() INamedExpressionContext

	// Set_namedExpression sets the _namedExpression rule contexts.
	Set_namedExpression(INamedExpressionContext)

	// GetArgument returns the argument rule context list.
	GetArgument() []INamedExpressionContext

	// SetArgument sets the argument rule context list.
	SetArgument([]INamedExpressionContext)

	// Getter signatures
	T_STRUCT() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsStructFunctionContext differentiates from other interfaces.
	IsStructFunctionContext()
}

type StructFunctionContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_namedExpression INamedExpressionContext
	argument         []INamedExpressionContext
}

func NewEmptyStructFunctionContext() *StructFunctionContext {
	var p = new(StructFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_structFunction
	return p
}

func InitEmptyStructFunctionContext(p *StructFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_structFunction
}

func (*StructFunctionContext) IsStructFunctionContext() {}

func NewStructFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFunctionContext {
	var p = new(StructFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_structFunction

	return p
}

func (s *StructFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFunctionContext) Get_namedExpression() INamedExpressionContext {
	return s._namedExpression
}

func (s *StructFunctionContext) Set_namedExpression(v INamedExpressionContext) {
	s._namedExpression = v
}

func (s *StructFunctionContext) GetArgument() []INamedExpressionContext { return s.argument }

func (s *StructFunctionContext) SetArgument(v []INamedExpressionContext) { s.argument = v }

func (s *StructFunctionContext) T_STRUCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STRUCT, 0)
}

func (s *StructFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *StructFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *StructFunctionContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StructFunctionContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *StructFunctionContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *StructFunctionContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *StructFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStructFunction(s)
	}
}

func (s *StructFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStructFunction(s)
	}
}

func (p *UniversalParser) StructFunction() (localctx IStructFunctionContext) {
	localctx = NewStructFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, UniversalParserRULE_structFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Match(UniversalParserT_STRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1631)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1632)

			var _x = p.NamedExpression()

			localctx.(*StructFunctionContext)._namedExpression = _x
		}
		localctx.(*StructFunctionContext).argument = append(localctx.(*StructFunctionContext).argument, localctx.(*StructFunctionContext)._namedExpression)
		p.SetState(1637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(1633)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1634)

				var _x = p.NamedExpression()

				localctx.(*StructFunctionContext)._namedExpression = _x
			}
			localctx.(*StructFunctionContext).argument = append(localctx.(*StructFunctionContext).argument, localctx.(*StructFunctionContext)._namedExpression)

			p.SetState(1639)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1642)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFirstFunctionContext is an interface to support dynamic dispatch.
type IFirstFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FIRST() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	K_CLOSE_PAREN() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_NULLS() antlr.TerminalNode

	// IsFirstFunctionContext differentiates from other interfaces.
	IsFirstFunctionContext()
}

type FirstFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirstFunctionContext() *FirstFunctionContext {
	var p = new(FirstFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_firstFunction
	return p
}

func InitEmptyFirstFunctionContext(p *FirstFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_firstFunction
}

func (*FirstFunctionContext) IsFirstFunctionContext() {}

func NewFirstFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FirstFunctionContext {
	var p = new(FirstFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_firstFunction

	return p
}

func (s *FirstFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FirstFunctionContext) T_FIRST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIRST, 0)
}

func (s *FirstFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *FirstFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FirstFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *FirstFunctionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IGNORE, 0)
}

func (s *FirstFunctionContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *FirstFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FirstFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FirstFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFirstFunction(s)
	}
}

func (s *FirstFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFirstFunction(s)
	}
}

func (p *UniversalParser) FirstFunction() (localctx IFirstFunctionContext) {
	localctx = NewFirstFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, UniversalParserRULE_firstFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1644)
		p.Match(UniversalParserT_FIRST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1645)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1646)
		p.Expression()
	}
	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_IGNORE {
		{
			p.SetState(1647)
			p.Match(UniversalParserT_IGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1648)
			p.Match(UniversalParserT_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1651)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyValueFunctionContext is an interface to support dynamic dispatch.
type IAnyValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ANY_VALUE() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	K_CLOSE_PAREN() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_NULLS() antlr.TerminalNode

	// IsAnyValueFunctionContext differentiates from other interfaces.
	IsAnyValueFunctionContext()
}

type AnyValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyValueFunctionContext() *AnyValueFunctionContext {
	var p = new(AnyValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_anyValueFunction
	return p
}

func InitEmptyAnyValueFunctionContext(p *AnyValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_anyValueFunction
}

func (*AnyValueFunctionContext) IsAnyValueFunctionContext() {}

func NewAnyValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyValueFunctionContext {
	var p = new(AnyValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_anyValueFunction

	return p
}

func (s *AnyValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyValueFunctionContext) T_ANY_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANY_VALUE, 0)
}

func (s *AnyValueFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *AnyValueFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AnyValueFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *AnyValueFunctionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IGNORE, 0)
}

func (s *AnyValueFunctionContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *AnyValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterAnyValueFunction(s)
	}
}

func (s *AnyValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitAnyValueFunction(s)
	}
}

func (p *UniversalParser) AnyValueFunction() (localctx IAnyValueFunctionContext) {
	localctx = NewAnyValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, UniversalParserRULE_anyValueFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1653)
		p.Match(UniversalParserT_ANY_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1654)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1655)
		p.Expression()
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_IGNORE {
		{
			p.SetState(1656)
			p.Match(UniversalParserT_IGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.Match(UniversalParserT_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1660)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastFunctionContext is an interface to support dynamic dispatch.
type ILastFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LAST() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	K_CLOSE_PAREN() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_NULLS() antlr.TerminalNode

	// IsLastFunctionContext differentiates from other interfaces.
	IsLastFunctionContext()
}

type LastFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFunctionContext() *LastFunctionContext {
	var p = new(LastFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lastFunction
	return p
}

func InitEmptyLastFunctionContext(p *LastFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_lastFunction
}

func (*LastFunctionContext) IsLastFunctionContext() {}

func NewLastFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFunctionContext {
	var p = new(LastFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_lastFunction

	return p
}

func (s *LastFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFunctionContext) T_LAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAST, 0)
}

func (s *LastFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *LastFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LastFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *LastFunctionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IGNORE, 0)
}

func (s *LastFunctionContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *LastFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLastFunction(s)
	}
}

func (s *LastFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLastFunction(s)
	}
}

func (p *UniversalParser) LastFunction() (localctx ILastFunctionContext) {
	localctx = NewLastFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, UniversalParserRULE_lastFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1662)
		p.Match(UniversalParserT_LAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1663)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1664)
		p.Expression()
	}
	p.SetState(1667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_IGNORE {
		{
			p.SetState(1665)
			p.Match(UniversalParserT_IGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.Match(UniversalParserT_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1669)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubQueryExpressContext is an interface to support dynamic dispatch.
type ISubQueryExpressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	Query() IQueryContext
	K_CLOSE_PAREN() antlr.TerminalNode

	// IsSubQueryExpressContext differentiates from other interfaces.
	IsSubQueryExpressContext()
}

type SubQueryExpressContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubQueryExpressContext() *SubQueryExpressContext {
	var p = new(SubQueryExpressContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_subQueryExpress
	return p
}

func InitEmptySubQueryExpressContext(p *SubQueryExpressContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_subQueryExpress
}

func (*SubQueryExpressContext) IsSubQueryExpressContext() {}

func NewSubQueryExpressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubQueryExpressContext {
	var p = new(SubQueryExpressContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_subQueryExpress

	return p
}

func (s *SubQueryExpressContext) GetParser() antlr.Parser { return s.parser }

func (s *SubQueryExpressContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *SubQueryExpressContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubQueryExpressContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *SubQueryExpressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubQueryExpressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubQueryExpressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSubQueryExpress(s)
	}
}

func (s *SubQueryExpressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSubQueryExpress(s)
	}
}

func (p *UniversalParser) SubQueryExpress() (localctx ISubQueryExpressContext) {
	localctx = NewSubQueryExpressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, UniversalParserRULE_subQueryExpress)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1672)
		p.Query()
	}
	{
		p.SetState(1673)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimFunctionContext is an interface to support dynamic dispatch.
type ITrimFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// GetTrimStr returns the trimStr rule contexts.
	GetTrimStr() IValueExpressionContext

	// GetSrcStr returns the srcStr rule contexts.
	GetSrcStr() IValueExpressionContext

	// SetTrimStr sets the trimStr rule contexts.
	SetTrimStr(IValueExpressionContext)

	// SetSrcStr sets the srcStr rule contexts.
	SetSrcStr(IValueExpressionContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	T_TRIM() antlr.TerminalNode
	T_RTRIM() antlr.TerminalNode
	T_LTRIM() antlr.TerminalNode
	T_BOTH() antlr.TerminalNode
	T_LEADING() antlr.TerminalNode
	T_TRAILING() antlr.TerminalNode

	// IsTrimFunctionContext differentiates from other interfaces.
	IsTrimFunctionContext()
}

type TrimFunctionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    antlr.Token
	option  antlr.Token
	trimStr IValueExpressionContext
	srcStr  IValueExpressionContext
}

func NewEmptyTrimFunctionContext() *TrimFunctionContext {
	var p = new(TrimFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_trimFunction
	return p
}

func InitEmptyTrimFunctionContext(p *TrimFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_trimFunction
}

func (*TrimFunctionContext) IsTrimFunctionContext() {}

func NewTrimFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimFunctionContext {
	var p = new(TrimFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_trimFunction

	return p
}

func (s *TrimFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimFunctionContext) GetName() antlr.Token { return s.name }

func (s *TrimFunctionContext) GetOption() antlr.Token { return s.option }

func (s *TrimFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *TrimFunctionContext) SetOption(v antlr.Token) { s.option = v }

func (s *TrimFunctionContext) GetTrimStr() IValueExpressionContext { return s.trimStr }

func (s *TrimFunctionContext) GetSrcStr() IValueExpressionContext { return s.srcStr }

func (s *TrimFunctionContext) SetTrimStr(v IValueExpressionContext) { s.trimStr = v }

func (s *TrimFunctionContext) SetSrcStr(v IValueExpressionContext) { s.srcStr = v }

func (s *TrimFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *TrimFunctionContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *TrimFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *TrimFunctionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimFunctionContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRIM, 0)
}

func (s *TrimFunctionContext) T_RTRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RTRIM, 0)
}

func (s *TrimFunctionContext) T_LTRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LTRIM, 0)
}

func (s *TrimFunctionContext) T_BOTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BOTH, 0)
}

func (s *TrimFunctionContext) T_LEADING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEADING, 0)
}

func (s *TrimFunctionContext) T_TRAILING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRAILING, 0)
}

func (s *TrimFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTrimFunction(s)
	}
}

func (s *TrimFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTrimFunction(s)
	}
}

func (p *UniversalParser) TrimFunction() (localctx ITrimFunctionContext) {
	localctx = NewTrimFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, UniversalParserRULE_trimFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1675)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TrimFunctionContext).name = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_TRIM || _la == UniversalParserT_LTRIM || _la == UniversalParserT_RTRIM) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TrimFunctionContext).name = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1676)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1677)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_BOTH || _la == UniversalParserT_LEADING || _la == UniversalParserT_TRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1680)

			var _x = p.valueExpression(0)

			localctx.(*TrimFunctionContext).trimStr = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1683)
		p.Match(UniversalParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1684)

		var _x = p.valueExpression(0)

		localctx.(*TrimFunctionContext).srcStr = _x
	}
	{
		p.SetState(1685)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtractFunctionContext is an interface to support dynamic dispatch.
type IExtractFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetField returns the field rule contexts.
	GetField() IIdentifierContext

	// GetSource returns the source rule contexts.
	GetSource() IValueExpressionContext

	// SetField sets the field rule contexts.
	SetField(IIdentifierContext)

	// SetSource sets the source rule contexts.
	SetSource(IValueExpressionContext)

	// Getter signatures
	T_EXTRACT() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ValueExpression() IValueExpressionContext

	// IsExtractFunctionContext differentiates from other interfaces.
	IsExtractFunctionContext()
}

type ExtractFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewEmptyExtractFunctionContext() *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_extractFunction
	return p
}

func InitEmptyExtractFunctionContext(p *ExtractFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_extractFunction
}

func (*ExtractFunctionContext) IsExtractFunctionContext() {}

func NewExtractFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_extractFunction

	return p
}

func (s *ExtractFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractFunctionContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractFunctionContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractFunctionContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractFunctionContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractFunctionContext) T_EXTRACT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTRACT, 0)
}

func (s *ExtractFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *ExtractFunctionContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *ExtractFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *ExtractFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractFunctionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtractFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExtractFunction(s)
	}
}

func (s *ExtractFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExtractFunction(s)
	}
}

func (p *UniversalParser) ExtractFunction() (localctx IExtractFunctionContext) {
	localctx = NewExtractFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, UniversalParserRULE_extractFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1687)
		p.Match(UniversalParserT_EXTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1688)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1689)

		var _x = p.Identifier()

		localctx.(*ExtractFunctionContext).field = _x
	}
	{
		p.SetState(1690)
		p.Match(UniversalParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1691)

		var _x = p.valueExpression(0)

		localctx.(*ExtractFunctionContext).source = _x
	}
	{
		p.SetState(1692)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubstringFunctionContext is an interface to support dynamic dispatch.
type ISubstringFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetSubSplitOne returns the subSplitOne token.
	GetSubSplitOne() antlr.Token

	// GetSubSpiltTwo returns the subSpiltTwo token.
	GetSubSpiltTwo() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetSubSplitOne sets the subSplitOne token.
	SetSubSplitOne(antlr.Token)

	// SetSubSpiltTwo sets the subSpiltTwo token.
	SetSubSpiltTwo(antlr.Token)

	// GetStr returns the str rule contexts.
	GetStr() IValueExpressionContext

	// GetPos returns the pos rule contexts.
	GetPos() IValueExpressionContext

	// GetLen_ returns the len_ rule contexts.
	GetLen_() IValueExpressionContext

	// SetStr sets the str rule contexts.
	SetStr(IValueExpressionContext)

	// SetPos sets the pos rule contexts.
	SetPos(IValueExpressionContext)

	// SetLen_ sets the len_ rule contexts.
	SetLen_(IValueExpressionContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	T_SUBSTR() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode
	T_FOR() antlr.TerminalNode

	// IsSubstringFunctionContext differentiates from other interfaces.
	IsSubstringFunctionContext()
}

type SubstringFunctionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	name        antlr.Token
	str         IValueExpressionContext
	subSplitOne antlr.Token
	pos         IValueExpressionContext
	subSpiltTwo antlr.Token
	len_        IValueExpressionContext
}

func NewEmptySubstringFunctionContext() *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_substringFunction
	return p
}

func InitEmptySubstringFunctionContext(p *SubstringFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_substringFunction
}

func (*SubstringFunctionContext) IsSubstringFunctionContext() {}

func NewSubstringFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_substringFunction

	return p
}

func (s *SubstringFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubstringFunctionContext) GetName() antlr.Token { return s.name }

func (s *SubstringFunctionContext) GetSubSplitOne() antlr.Token { return s.subSplitOne }

func (s *SubstringFunctionContext) GetSubSpiltTwo() antlr.Token { return s.subSpiltTwo }

func (s *SubstringFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SubstringFunctionContext) SetSubSplitOne(v antlr.Token) { s.subSplitOne = v }

func (s *SubstringFunctionContext) SetSubSpiltTwo(v antlr.Token) { s.subSpiltTwo = v }

func (s *SubstringFunctionContext) GetStr() IValueExpressionContext { return s.str }

func (s *SubstringFunctionContext) GetPos() IValueExpressionContext { return s.pos }

func (s *SubstringFunctionContext) GetLen_() IValueExpressionContext { return s.len_ }

func (s *SubstringFunctionContext) SetStr(v IValueExpressionContext) { s.str = v }

func (s *SubstringFunctionContext) SetPos(v IValueExpressionContext) { s.pos = v }

func (s *SubstringFunctionContext) SetLen_(v IValueExpressionContext) { s.len_ = v }

func (s *SubstringFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *SubstringFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *SubstringFunctionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstringFunctionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringFunctionContext) T_SUBSTR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBSTR, 0)
}

func (s *SubstringFunctionContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBSTRING, 0)
}

func (s *SubstringFunctionContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *SubstringFunctionContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *SubstringFunctionContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *SubstringFunctionContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *SubstringFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubstringFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSubstringFunction(s)
	}
}

func (p *UniversalParser) SubstringFunction() (localctx ISubstringFunctionContext) {
	localctx = NewSubstringFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, UniversalParserRULE_substringFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1694)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SubstringFunctionContext).name = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_SUBSTR || _la == UniversalParserT_SUBSTRING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SubstringFunctionContext).name = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1695)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1696)

		var _x = p.valueExpression(0)

		localctx.(*SubstringFunctionContext).str = _x
	}
	{
		p.SetState(1697)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SubstringFunctionContext).subSplitOne = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_FROM || _la == UniversalParserK_COMMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SubstringFunctionContext).subSplitOne = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1698)

		var _x = p.valueExpression(0)

		localctx.(*SubstringFunctionContext).pos = _x
	}
	p.SetState(1701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_FOR || _la == UniversalParserK_COMMA {
		{
			p.SetState(1699)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SubstringFunctionContext).subSpiltTwo = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_FOR || _la == UniversalParserK_COMMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SubstringFunctionContext).subSpiltTwo = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1700)

			var _x = p.valueExpression(0)

			localctx.(*SubstringFunctionContext).len_ = _x
		}

	}
	{
		p.SetState(1703)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverlayFunctionContext is an interface to support dynamic dispatch.
type IOverlayFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInput returns the input rule contexts.
	GetInput() IValueExpressionContext

	// GetReplace returns the replace rule contexts.
	GetReplace() IValueExpressionContext

	// GetPosition returns the position rule contexts.
	GetPosition() IValueExpressionContext

	// GetLength returns the length rule contexts.
	GetLength() IValueExpressionContext

	// SetInput sets the input rule contexts.
	SetInput(IValueExpressionContext)

	// SetReplace sets the replace rule contexts.
	SetReplace(IValueExpressionContext)

	// SetPosition sets the position rule contexts.
	SetPosition(IValueExpressionContext)

	// SetLength sets the length rule contexts.
	SetLength(IValueExpressionContext)

	// Getter signatures
	T_OVERLAY() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	T_PLACING() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	T_FOR() antlr.TerminalNode

	// IsOverlayFunctionContext differentiates from other interfaces.
	IsOverlayFunctionContext()
}

type OverlayFunctionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	input    IValueExpressionContext
	replace  IValueExpressionContext
	position IValueExpressionContext
	length   IValueExpressionContext
}

func NewEmptyOverlayFunctionContext() *OverlayFunctionContext {
	var p = new(OverlayFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_overlayFunction
	return p
}

func InitEmptyOverlayFunctionContext(p *OverlayFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_overlayFunction
}

func (*OverlayFunctionContext) IsOverlayFunctionContext() {}

func NewOverlayFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverlayFunctionContext {
	var p = new(OverlayFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_overlayFunction

	return p
}

func (s *OverlayFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *OverlayFunctionContext) GetInput() IValueExpressionContext { return s.input }

func (s *OverlayFunctionContext) GetReplace() IValueExpressionContext { return s.replace }

func (s *OverlayFunctionContext) GetPosition() IValueExpressionContext { return s.position }

func (s *OverlayFunctionContext) GetLength() IValueExpressionContext { return s.length }

func (s *OverlayFunctionContext) SetInput(v IValueExpressionContext) { s.input = v }

func (s *OverlayFunctionContext) SetReplace(v IValueExpressionContext) { s.replace = v }

func (s *OverlayFunctionContext) SetPosition(v IValueExpressionContext) { s.position = v }

func (s *OverlayFunctionContext) SetLength(v IValueExpressionContext) { s.length = v }

func (s *OverlayFunctionContext) T_OVERLAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OVERLAY, 0)
}

func (s *OverlayFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *OverlayFunctionContext) T_PLACING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PLACING, 0)
}

func (s *OverlayFunctionContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM, 0)
}

func (s *OverlayFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *OverlayFunctionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverlayFunctionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *OverlayFunctionContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *OverlayFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverlayFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverlayFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterOverlayFunction(s)
	}
}

func (s *OverlayFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitOverlayFunction(s)
	}
}

func (p *UniversalParser) OverlayFunction() (localctx IOverlayFunctionContext) {
	localctx = NewOverlayFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, UniversalParserRULE_overlayFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(UniversalParserT_OVERLAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1706)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1707)

		var _x = p.valueExpression(0)

		localctx.(*OverlayFunctionContext).input = _x
	}
	{
		p.SetState(1708)
		p.Match(UniversalParserT_PLACING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1709)

		var _x = p.valueExpression(0)

		localctx.(*OverlayFunctionContext).replace = _x
	}
	{
		p.SetState(1710)
		p.Match(UniversalParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1711)

		var _x = p.valueExpression(0)

		localctx.(*OverlayFunctionContext).position = _x
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_FOR {
		{
			p.SetState(1712)
			p.Match(UniversalParserT_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)

			var _x = p.valueExpression(0)

			localctx.(*OverlayFunctionContext).length = _x
		}

	}
	{
		p.SetState(1716)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPercentileFunctionContext is an interface to support dynamic dispatch.
type IPercentileFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IValueExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IValueExpressionContext)

	// Getter signatures
	AllK_OPEN_PAREN() []antlr.TerminalNode
	K_OPEN_PAREN(i int) antlr.TerminalNode
	AllK_CLOSE_PAREN() []antlr.TerminalNode
	K_CLOSE_PAREN(i int) antlr.TerminalNode
	T_WITHIN() antlr.TerminalNode
	T_GROUP() antlr.TerminalNode
	OrderBy() IOrderByContext
	ValueExpression() IValueExpressionContext
	T_PERCENTILE_CONT() antlr.TerminalNode
	T_PERCENTILE_DISC() antlr.TerminalNode
	FilterSpec() IFilterSpecContext
	OverSpec() IOverSpecContext

	// IsPercentileFunctionContext differentiates from other interfaces.
	IsPercentileFunctionContext()
}

type PercentileFunctionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	name       antlr.Token
	percentage IValueExpressionContext
}

func NewEmptyPercentileFunctionContext() *PercentileFunctionContext {
	var p = new(PercentileFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_percentileFunction
	return p
}

func InitEmptyPercentileFunctionContext(p *PercentileFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_percentileFunction
}

func (*PercentileFunctionContext) IsPercentileFunctionContext() {}

func NewPercentileFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PercentileFunctionContext {
	var p = new(PercentileFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_percentileFunction

	return p
}

func (s *PercentileFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *PercentileFunctionContext) GetName() antlr.Token { return s.name }

func (s *PercentileFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *PercentileFunctionContext) GetPercentage() IValueExpressionContext { return s.percentage }

func (s *PercentileFunctionContext) SetPercentage(v IValueExpressionContext) { s.percentage = v }

func (s *PercentileFunctionContext) AllK_OPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_OPEN_PAREN)
}

func (s *PercentileFunctionContext) K_OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, i)
}

func (s *PercentileFunctionContext) AllK_CLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_CLOSE_PAREN)
}

func (s *PercentileFunctionContext) K_CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, i)
}

func (s *PercentileFunctionContext) T_WITHIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITHIN, 0)
}

func (s *PercentileFunctionContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUP, 0)
}

func (s *PercentileFunctionContext) OrderBy() IOrderByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByContext)
}

func (s *PercentileFunctionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PercentileFunctionContext) T_PERCENTILE_CONT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE_CONT, 0)
}

func (s *PercentileFunctionContext) T_PERCENTILE_DISC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE_DISC, 0)
}

func (s *PercentileFunctionContext) FilterSpec() IFilterSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterSpecContext)
}

func (s *PercentileFunctionContext) OverSpec() IOverSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverSpecContext)
}

func (s *PercentileFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PercentileFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PercentileFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPercentileFunction(s)
	}
}

func (s *PercentileFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPercentileFunction(s)
	}
}

func (p *UniversalParser) PercentileFunction() (localctx IPercentileFunctionContext) {
	localctx = NewPercentileFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, UniversalParserRULE_percentileFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1718)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PercentileFunctionContext).name = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_PERCENTILE_CONT || _la == UniversalParserT_PERCENTILE_DISC) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PercentileFunctionContext).name = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1719)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)

		var _x = p.valueExpression(0)

		localctx.(*PercentileFunctionContext).percentage = _x
	}
	{
		p.SetState(1721)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1722)
		p.Match(UniversalParserT_WITHIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1723)
		p.Match(UniversalParserT_GROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1724)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1725)
		p.OrderBy()
	}
	{
		p.SetState(1726)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1727)
			p.FilterSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1730)
			p.OverSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransArrayFunctionContext is an interface to support dynamic dispatch.
type ITransArrayFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRANS_ARRAY() antlr.TerminalNode
	AllK_OPEN_PAREN() []antlr.TerminalNode
	K_OPEN_PAREN(i int) antlr.TerminalNode
	Arguments() IArgumentsContext
	AllK_CLOSE_PAREN() []antlr.TerminalNode
	K_CLOSE_PAREN(i int) antlr.TerminalNode
	T_AS() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext

	// IsTransArrayFunctionContext differentiates from other interfaces.
	IsTransArrayFunctionContext()
}

type TransArrayFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransArrayFunctionContext() *TransArrayFunctionContext {
	var p = new(TransArrayFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_transArrayFunction
	return p
}

func InitEmptyTransArrayFunctionContext(p *TransArrayFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_transArrayFunction
}

func (*TransArrayFunctionContext) IsTransArrayFunctionContext() {}

func NewTransArrayFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransArrayFunctionContext {
	var p = new(TransArrayFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_transArrayFunction

	return p
}

func (s *TransArrayFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransArrayFunctionContext) T_TRANS_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANS_ARRAY, 0)
}

func (s *TransArrayFunctionContext) AllK_OPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_OPEN_PAREN)
}

func (s *TransArrayFunctionContext) K_OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, i)
}

func (s *TransArrayFunctionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *TransArrayFunctionContext) AllK_CLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_CLOSE_PAREN)
}

func (s *TransArrayFunctionContext) K_CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, i)
}

func (s *TransArrayFunctionContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *TransArrayFunctionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *TransArrayFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransArrayFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransArrayFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTransArrayFunction(s)
	}
}

func (s *TransArrayFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTransArrayFunction(s)
	}
}

func (p *UniversalParser) TransArrayFunction() (localctx ITransArrayFunctionContext) {
	localctx = NewTransArrayFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, UniversalParserRULE_transArrayFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1733)
		p.Match(UniversalParserT_TRANS_ARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1734)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1735)
		p.Arguments()
	}
	{
		p.SetState(1736)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1737)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1738)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1739)
		p.IdentifierSeq()
	}
	{
		p.SetState(1740)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardFunctionContext is an interface to support dynamic dispatch.
type IStandardFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullsOption returns the nullsOption token.
	GetNullsOption() antlr.Token

	// SetNullsOption sets the nullsOption token.
	SetNullsOption(antlr.Token)

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IMultiIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IMultiIdentifierContext)

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext
	Arguments() IArgumentsContext
	FilterSpec() IFilterSpecContext
	T_NULLS() antlr.TerminalNode
	OverSpec() IOverSpecContext
	T_IGNORE() antlr.TerminalNode
	T_RESPECT() antlr.TerminalNode

	// IsStandardFunctionContext differentiates from other interfaces.
	IsStandardFunctionContext()
}

type StandardFunctionContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IMultiIdentifierContext
	nullsOption  antlr.Token
}

func NewEmptyStandardFunctionContext() *StandardFunctionContext {
	var p = new(StandardFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_standardFunction
	return p
}

func InitEmptyStandardFunctionContext(p *StandardFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_standardFunction
}

func (*StandardFunctionContext) IsStandardFunctionContext() {}

func NewStandardFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardFunctionContext {
	var p = new(StandardFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_standardFunction

	return p
}

func (s *StandardFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardFunctionContext) GetNullsOption() antlr.Token { return s.nullsOption }

func (s *StandardFunctionContext) SetNullsOption(v antlr.Token) { s.nullsOption = v }

func (s *StandardFunctionContext) GetFunctionName() IMultiIdentifierContext { return s.functionName }

func (s *StandardFunctionContext) SetFunctionName(v IMultiIdentifierContext) { s.functionName = v }

func (s *StandardFunctionContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *StandardFunctionContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *StandardFunctionContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *StandardFunctionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *StandardFunctionContext) FilterSpec() IFilterSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterSpecContext)
}

func (s *StandardFunctionContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *StandardFunctionContext) OverSpec() IOverSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverSpecContext)
}

func (s *StandardFunctionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IGNORE, 0)
}

func (s *StandardFunctionContext) T_RESPECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESPECT, 0)
}

func (s *StandardFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStandardFunction(s)
	}
}

func (s *StandardFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStandardFunction(s)
	}
}

func (p *UniversalParser) StandardFunction() (localctx IStandardFunctionContext) {
	localctx = NewStandardFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, UniversalParserRULE_standardFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1742)

		var _x = p.MultiIdentifier()

		localctx.(*StandardFunctionContext).functionName = _x
	}
	{
		p.SetState(1743)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1745)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1744)
			p.Arguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1747)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1749)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1748)
			p.FilterSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1751)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StandardFunctionContext).nullsOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_IGNORE || _la == UniversalParserT_RESPECT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StandardFunctionContext).nullsOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1752)
			p.Match(UniversalParserT_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1755)
			p.OverSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverSpecContext is an interface to support dynamic dispatch.
type IOverSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext

	// IsOverSpecContext differentiates from other interfaces.
	IsOverSpecContext()
}

type OverSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverSpecContext() *OverSpecContext {
	var p = new(OverSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_overSpec
	return p
}

func InitEmptyOverSpecContext(p *OverSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_overSpec
}

func (*OverSpecContext) IsOverSpecContext() {}

func NewOverSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverSpecContext {
	var p = new(OverSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_overSpec

	return p
}

func (s *OverSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *OverSpecContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OVER, 0)
}

func (s *OverSpecContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterOverSpec(s)
	}
}

func (s *OverSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitOverSpec(s)
	}
}

func (p *UniversalParser) OverSpec() (localctx IOverSpecContext) {
	localctx = NewOverSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, UniversalParserRULE_overSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1758)
		p.Match(UniversalParserT_OVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1759)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterSpecContext is an interface to support dynamic dispatch.
type IFilterSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// Getter signatures
	T_FILTER() antlr.TerminalNode
	K_OPEN_PAREN() antlr.TerminalNode
	T_WHERE() antlr.TerminalNode
	K_CLOSE_PAREN() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsFilterSpecContext differentiates from other interfaces.
	IsFilterSpecContext()
}

type FilterSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
}

func NewEmptyFilterSpecContext() *FilterSpecContext {
	var p = new(FilterSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_filterSpec
	return p
}

func InitEmptyFilterSpecContext(p *FilterSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_filterSpec
}

func (*FilterSpecContext) IsFilterSpecContext() {}

func NewFilterSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterSpecContext {
	var p = new(FilterSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_filterSpec

	return p
}

func (s *FilterSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterSpecContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *FilterSpecContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *FilterSpecContext) T_FILTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FILTER, 0)
}

func (s *FilterSpecContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *FilterSpecContext) T_WHERE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WHERE, 0)
}

func (s *FilterSpecContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *FilterSpecContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFilterSpec(s)
	}
}

func (s *FilterSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFilterSpec(s)
	}
}

func (p *UniversalParser) FilterSpec() (localctx IFilterSpecContext) {
	localctx = NewFilterSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, UniversalParserRULE_filterSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1761)
		p.Match(UniversalParserT_FILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1762)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1763)
		p.Match(UniversalParserT_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1764)

		var _x = p.booleanExpression(0)

		localctx.(*FilterSpecContext).where = _x
	}
	{
		p.SetState(1765)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TypeLiteralContext struct {
	ConstantContext
}

func NewTypeLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeLiteralContext {
	var p = new(TypeLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeLiteralContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TypeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTypeLiteral(s)
	}
}

func (s *TypeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTypeLiteral(s)
	}
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) Null() INullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullContext)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type BooleaniteralContext struct {
	ConstantContext
}

func NewBooleaniteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleaniteralContext {
	var p = new(BooleaniteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleaniteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleaniteralContext) Boolean() IBooleanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanContext)
}

func (s *BooleaniteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBooleaniteral(s)
	}
}

func (s *BooleaniteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBooleaniteral(s)
	}
}

type IntervalLiteralContext struct {
	ConstantContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type NumberLiteralContext struct {
	ConstantContext
}

func NewNumberLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *UniversalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, UniversalParserRULE_constant)
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1767)
			p.Null()
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1768)
			p.Interval()
		}

	case 3:
		localctx = NewNumberLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1769)
			p.Number()
		}

	case 4:
		localctx = NewTypeLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1770)
			p.Identifier()
		}
		{
			p.SetState(1771)
			p.String_()
		}

	case 5:
		localctx = NewBooleaniteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1773)
			p.Boolean()
		}

	case 6:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1774)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompareOperatorContext is an interface to support dynamic dispatch.
type ICompareOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EQ() antlr.TerminalNode
	K_EQ2() antlr.TerminalNode
	K_NEQ() antlr.TerminalNode
	K_NEQJ() antlr.TerminalNode
	K_LT() antlr.TerminalNode
	K_LTE() antlr.TerminalNode
	K_LTEJ() antlr.TerminalNode
	K_GT() antlr.TerminalNode
	K_GTE() antlr.TerminalNode
	K_GTEJ() antlr.TerminalNode
	K_NSEQ() antlr.TerminalNode
	K_ARROW() antlr.TerminalNode

	// IsCompareOperatorContext differentiates from other interfaces.
	IsCompareOperatorContext()
}

type CompareOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompareOperatorContext() *CompareOperatorContext {
	var p = new(CompareOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_compareOperator
	return p
}

func InitEmptyCompareOperatorContext(p *CompareOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_compareOperator
}

func (*CompareOperatorContext) IsCompareOperatorContext() {}

func NewCompareOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompareOperatorContext {
	var p = new(CompareOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_compareOperator

	return p
}

func (s *CompareOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CompareOperatorContext) K_EQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EQ, 0)
}

func (s *CompareOperatorContext) K_EQ2() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EQ2, 0)
}

func (s *CompareOperatorContext) K_NEQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_NEQ, 0)
}

func (s *CompareOperatorContext) K_NEQJ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_NEQJ, 0)
}

func (s *CompareOperatorContext) K_LT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LT, 0)
}

func (s *CompareOperatorContext) K_LTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LTE, 0)
}

func (s *CompareOperatorContext) K_LTEJ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LTEJ, 0)
}

func (s *CompareOperatorContext) K_GT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GT, 0)
}

func (s *CompareOperatorContext) K_GTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GTE, 0)
}

func (s *CompareOperatorContext) K_GTEJ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GTEJ, 0)
}

func (s *CompareOperatorContext) K_NSEQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_NSEQ, 0)
}

func (s *CompareOperatorContext) K_ARROW() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_ARROW, 0)
}

func (s *CompareOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompareOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompareOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCompareOperator(s)
	}
}

func (s *CompareOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCompareOperator(s)
	}
}

func (p *UniversalParser) CompareOperator() (localctx ICompareOperatorContext) {
	localctx = NewCompareOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, UniversalParserRULE_compareOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-774)) & ^0x3f) == 0 && ((int64(1)<<(_la-774))&4095) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MapDataTypeContext struct {
	DataTypeContext
	name antlr.Token
}

func NewMapDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapDataTypeContext {
	var p = new(MapDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *MapDataTypeContext) GetName() antlr.Token { return s.name }

func (s *MapDataTypeContext) SetName(v antlr.Token) { s.name = v }

func (s *MapDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapDataTypeContext) K_LT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LT, 0)
}

func (s *MapDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *MapDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *MapDataTypeContext) K_COMMA() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, 0)
}

func (s *MapDataTypeContext) K_GT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GT, 0)
}

func (s *MapDataTypeContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP, 0)
}

func (s *MapDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMapDataType(s)
	}
}

func (s *MapDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMapDataType(s)
	}
}

type StructDataTypeContext struct {
	DataTypeContext
	name antlr.Token
}

func NewStructDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructDataTypeContext {
	var p = new(StructDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *StructDataTypeContext) GetName() antlr.Token { return s.name }

func (s *StructDataTypeContext) SetName(v antlr.Token) { s.name = v }

func (s *StructDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDataTypeContext) T_STRUCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STRUCT, 0)
}

func (s *StructDataTypeContext) K_LT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LT, 0)
}

func (s *StructDataTypeContext) K_GT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GT, 0)
}

func (s *StructDataTypeContext) K_NEQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_NEQ, 0)
}

func (s *StructDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *StructDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStructDataType(s)
	}
}

func (s *StructDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStructDataType(s)
	}
}

type IntervalDataTypeContext struct {
	DataTypeContext
	from antlr.Token
	to   antlr.Token
}

func NewIntervalDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalDataTypeContext {
	var p = new(IntervalDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *IntervalDataTypeContext) GetFrom() antlr.Token { return s.from }

func (s *IntervalDataTypeContext) GetTo() antlr.Token { return s.to }

func (s *IntervalDataTypeContext) SetFrom(v antlr.Token) { s.from = v }

func (s *IntervalDataTypeContext) SetTo(v antlr.Token) { s.to = v }

func (s *IntervalDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalDataTypeContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTERVAL, 0)
}

func (s *IntervalDataTypeContext) T_YEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEAR, 0)
}

func (s *IntervalDataTypeContext) AllT_MONTH() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_MONTH)
}

func (s *IntervalDataTypeContext) T_MONTH(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTH, i)
}

func (s *IntervalDataTypeContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *IntervalDataTypeContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAY, 0)
}

func (s *IntervalDataTypeContext) AllT_HOUR() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_HOUR)
}

func (s *IntervalDataTypeContext) T_HOUR(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOUR, i)
}

func (s *IntervalDataTypeContext) AllT_MINUTE() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_MINUTE)
}

func (s *IntervalDataTypeContext) T_MINUTE(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTE, i)
}

func (s *IntervalDataTypeContext) AllT_SECOND() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_SECOND)
}

func (s *IntervalDataTypeContext) T_SECOND(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECOND, i)
}

func (s *IntervalDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterIntervalDataType(s)
	}
}

func (s *IntervalDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitIntervalDataType(s)
	}
}

type ArrayDataTypeContext struct {
	DataTypeContext
	name antlr.Token
}

func NewArrayDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayDataTypeContext {
	var p = new(ArrayDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ArrayDataTypeContext) GetName() antlr.Token { return s.name }

func (s *ArrayDataTypeContext) SetName(v antlr.Token) { s.name = v }

func (s *ArrayDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayDataTypeContext) K_LT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_LT, 0)
}

func (s *ArrayDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ArrayDataTypeContext) K_GT() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_GT, 0)
}

func (s *ArrayDataTypeContext) T_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY, 0)
}

func (s *ArrayDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterArrayDataType(s)
	}
}

func (s *ArrayDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitArrayDataType(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimitiveDataTypeContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserINTEGER_VALUE)
}

func (s *PrimitiveDataTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, i)
}

func (s *PrimitiveDataTypeContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *PrimitiveDataTypeContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *PrimitiveDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPrimitiveDataType(s)
	}
}

func (s *PrimitiveDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPrimitiveDataType(s)
	}
}

func (p *UniversalParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, UniversalParserRULE_dataType)
	var _la int

	p.SetState(1825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) {
	case 1:
		localctx = NewArrayDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1779)

			var _m = p.Match(UniversalParserT_ARRAY)

			localctx.(*ArrayDataTypeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1780)
			p.Match(UniversalParserK_LT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1781)
			p.DataType()
		}
		{
			p.SetState(1782)
			p.Match(UniversalParserK_GT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewMapDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1784)

			var _m = p.Match(UniversalParserT_MAP)

			localctx.(*MapDataTypeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.Match(UniversalParserK_LT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1786)
			p.DataType()
		}
		{
			p.SetState(1787)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.DataType()
		}
		{
			p.SetState(1789)
			p.Match(UniversalParserK_GT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewStructDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1791)

			var _m = p.Match(UniversalParserT_STRUCT)

			localctx.(*StructDataTypeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case UniversalParserK_LT:
			{
				p.SetState(1792)
				p.Match(UniversalParserK_LT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1794)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1793)
					p.ComplexColTypeList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1796)
				p.Match(UniversalParserK_GT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case UniversalParserK_NEQ:
			{
				p.SetState(1797)
				p.Match(UniversalParserK_NEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewIntervalDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1800)
			p.Match(UniversalParserT_INTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1801)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalDataTypeContext).from = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_MONTH || _la == UniversalParserT_YEAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalDataTypeContext).from = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_TO {
			{
				p.SetState(1802)
				p.Match(UniversalParserT_TO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1803)

				var _m = p.Match(UniversalParserT_MONTH)

				localctx.(*IntervalDataTypeContext).to = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewIntervalDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1806)
			p.Match(UniversalParserT_INTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1807)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalDataTypeContext).from = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_DAY || _la == UniversalParserT_HOUR || _la == UniversalParserT_MINUTE || _la == UniversalParserT_SECOND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalDataTypeContext).from = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_TO {
			{
				p.SetState(1808)
				p.Match(UniversalParserT_TO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1809)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*IntervalDataTypeContext).to = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == UniversalParserT_HOUR || _la == UniversalParserT_MINUTE || _la == UniversalParserT_SECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*IntervalDataTypeContext).to = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1812)
			p.Identifier()
		}
		p.SetState(1823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_OPEN_PAREN {
			{
				p.SetState(1813)
				p.Match(UniversalParserK_OPEN_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1814)
				p.Match(UniversalParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1819)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == UniversalParserK_COMMA {
				{
					p.SetState(1815)
					p.Match(UniversalParserK_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1816)
					p.Match(UniversalParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1821)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1822)
				p.Match(UniversalParserK_CLOSE_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *ComplexColTypeListContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterComplexColTypeList(s)
	}
}

func (s *ComplexColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitComplexColTypeList(s)
	}
}

func (p *UniversalParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, UniversalParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.ComplexColType()
	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(1828)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1829)
			p.ComplexColType()
		}

		p.SetState(1834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	K_COLON() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) K_COLON() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COLON, 0)
}

func (s *ComplexColTypeContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOT, 0)
}

func (s *ComplexColTypeContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULL, 0)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterComplexColType(s)
	}
}

func (s *ComplexColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitComplexColType(s)
	}
}

func (p *UniversalParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, UniversalParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1835)
		p.Identifier()
	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1836)
			p.Match(UniversalParserK_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1839)
		p.DataType()
	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NOT {
		{
			p.SetState(1840)
			p.Match(UniversalParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.Match(UniversalParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_COMMENT {
		{
			p.SetState(1844)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DISTINCT() antlr.TerminalNode
	T_ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISTINCT, 0)
}

func (s *SetQuantifierContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *UniversalParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, UniversalParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1847)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_ALL || _la == UniversalParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTERVAL() antlr.TerminalNode
	UnitToUnitInterval() IUnitToUnitIntervalContext
	MultiUnitsInterval() IMultiUnitsIntervalContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTERVAL, 0)
}

func (s *IntervalContext) UnitToUnitInterval() IUnitToUnitIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitIntervalContext)
}

func (s *IntervalContext) MultiUnitsInterval() IMultiUnitsIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsIntervalContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *UniversalParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, UniversalParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1849)
		p.Match(UniversalParserT_INTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1850)
			p.UnitToUnitInterval()
		}

	case 2:
		{
			p.SetState(1851)
			p.MultiUnitsInterval()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiUnitsIntervalContext is an interface to support dynamic dispatch.
type IMultiUnitsIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_multiUnits returns the _multiUnits rule contexts.
	Get_multiUnits() IMultiUnitsContext

	// Set_multiUnits sets the _multiUnits rule contexts.
	Set_multiUnits(IMultiUnitsContext)

	// GetUnit returns the unit rule context list.
	GetUnit() []IMultiUnitsContext

	// SetUnit sets the unit rule context list.
	SetUnit([]IMultiUnitsContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllMultiUnits() []IMultiUnitsContext
	MultiUnits(i int) IMultiUnitsContext

	// IsMultiUnitsIntervalContext differentiates from other interfaces.
	IsMultiUnitsIntervalContext()
}

type MultiUnitsIntervalContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_multiUnits IMultiUnitsContext
	unit        []IMultiUnitsContext
}

func NewEmptyMultiUnitsIntervalContext() *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiUnitsInterval
	return p
}

func InitEmptyMultiUnitsIntervalContext(p *MultiUnitsIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiUnitsInterval
}

func (*MultiUnitsIntervalContext) IsMultiUnitsIntervalContext() {}

func NewMultiUnitsIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiUnitsIntervalContext {
	var p = new(MultiUnitsIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_multiUnitsInterval

	return p
}

func (s *MultiUnitsIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiUnitsIntervalContext) Get_multiUnits() IMultiUnitsContext { return s._multiUnits }

func (s *MultiUnitsIntervalContext) Set_multiUnits(v IMultiUnitsContext) { s._multiUnits = v }

func (s *MultiUnitsIntervalContext) GetUnit() []IMultiUnitsContext { return s.unit }

func (s *MultiUnitsIntervalContext) SetUnit(v []IMultiUnitsContext) { s.unit = v }

func (s *MultiUnitsIntervalContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiUnitsIntervalContext) AllMultiUnits() []IMultiUnitsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiUnitsContext); ok {
			len++
		}
	}

	tst := make([]IMultiUnitsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiUnitsContext); ok {
			tst[i] = t.(IMultiUnitsContext)
			i++
		}
	}

	return tst
}

func (s *MultiUnitsIntervalContext) MultiUnits(i int) IMultiUnitsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiUnitsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiUnitsContext)
}

func (s *MultiUnitsIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiUnitsIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiUnitsIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiUnitsInterval(s)
	}
}

func (s *MultiUnitsIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiUnitsInterval(s)
	}
}

func (p *UniversalParser) MultiUnitsInterval() (localctx IMultiUnitsIntervalContext) {
	localctx = NewMultiUnitsIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, UniversalParserRULE_multiUnitsInterval)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1854)
				p.Expression()
			}
			{
				p.SetState(1855)

				var _x = p.MultiUnits()

				localctx.(*MultiUnitsIntervalContext)._multiUnits = _x
			}
			localctx.(*MultiUnitsIntervalContext).unit = append(localctx.(*MultiUnitsIntervalContext).unit, localctx.(*MultiUnitsIntervalContext)._multiUnits)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitToUnitIntervalContext is an interface to support dynamic dispatch.
type IUnitToUnitIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitToUnitContext

	// GetTo returns the to rule contexts.
	GetTo() IUnitToUnitContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitToUnitContext)

	// SetTo sets the to rule contexts.
	SetTo(IUnitToUnitContext)

	// Getter signatures
	T_TO() antlr.TerminalNode
	Expression() IExpressionContext
	AllUnitToUnit() []IUnitToUnitContext
	UnitToUnit(i int) IUnitToUnitContext

	// IsUnitToUnitIntervalContext differentiates from other interfaces.
	IsUnitToUnitIntervalContext()
}

type UnitToUnitIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   IUnitToUnitContext
	to     IUnitToUnitContext
}

func NewEmptyUnitToUnitIntervalContext() *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unitToUnitInterval
	return p
}

func InitEmptyUnitToUnitIntervalContext(p *UnitToUnitIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unitToUnitInterval
}

func (*UnitToUnitIntervalContext) IsUnitToUnitIntervalContext() {}

func NewUnitToUnitIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitToUnitIntervalContext {
	var p = new(UnitToUnitIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unitToUnitInterval

	return p
}

func (s *UnitToUnitIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitToUnitIntervalContext) GetValue() IExpressionContext { return s.value }

func (s *UnitToUnitIntervalContext) GetFrom() IUnitToUnitContext { return s.from }

func (s *UnitToUnitIntervalContext) GetTo() IUnitToUnitContext { return s.to }

func (s *UnitToUnitIntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *UnitToUnitIntervalContext) SetFrom(v IUnitToUnitContext) { s.from = v }

func (s *UnitToUnitIntervalContext) SetTo(v IUnitToUnitContext) { s.to = v }

func (s *UnitToUnitIntervalContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *UnitToUnitIntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnitToUnitIntervalContext) AllUnitToUnit() []IUnitToUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnitToUnitContext); ok {
			len++
		}
	}

	tst := make([]IUnitToUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnitToUnitContext); ok {
			tst[i] = t.(IUnitToUnitContext)
			i++
		}
	}

	return tst
}

func (s *UnitToUnitIntervalContext) UnitToUnit(i int) IUnitToUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitToUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitToUnitContext)
}

func (s *UnitToUnitIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitToUnitIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitToUnitIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnitToUnitInterval(s)
	}
}

func (s *UnitToUnitIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnitToUnitInterval(s)
	}
}

func (p *UniversalParser) UnitToUnitInterval() (localctx IUnitToUnitIntervalContext) {
	localctx = NewUnitToUnitIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, UniversalParserRULE_unitToUnitInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1861)

		var _x = p.Expression()

		localctx.(*UnitToUnitIntervalContext).value = _x
	}
	{
		p.SetState(1862)

		var _x = p.UnitToUnit()

		localctx.(*UnitToUnitIntervalContext).from = _x
	}
	{
		p.SetState(1863)
		p.Match(UniversalParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1864)

		var _x = p.UnitToUnit()

		localctx.(*UnitToUnitIntervalContext).to = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiUnitsContext is an interface to support dynamic dispatch.
type IMultiUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NANOSECOND() antlr.TerminalNode
	T_NANOSECONDS() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_MILLISECOND() antlr.TerminalNode
	T_MILLISECONDS() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode
	T_MINUTE() antlr.TerminalNode
	T_MINUTES() antlr.TerminalNode
	T_HOUR() antlr.TerminalNode
	T_HOURS() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_WEEK() antlr.TerminalNode
	T_WEEKS() antlr.TerminalNode
	T_MONTH() antlr.TerminalNode
	T_MONTHS() antlr.TerminalNode
	T_YEAR() antlr.TerminalNode
	T_YEARS() antlr.TerminalNode

	// IsMultiUnitsContext differentiates from other interfaces.
	IsMultiUnitsContext()
}

type MultiUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiUnitsContext() *MultiUnitsContext {
	var p = new(MultiUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiUnits
	return p
}

func InitEmptyMultiUnitsContext(p *MultiUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiUnits
}

func (*MultiUnitsContext) IsMultiUnitsContext() {}

func NewMultiUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiUnitsContext {
	var p = new(MultiUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_multiUnits

	return p
}

func (s *MultiUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiUnitsContext) T_NANOSECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NANOSECOND, 0)
}

func (s *MultiUnitsContext) T_NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NANOSECONDS, 0)
}

func (s *MultiUnitsContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MICROSECOND, 0)
}

func (s *MultiUnitsContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MICROSECONDS, 0)
}

func (s *MultiUnitsContext) T_MILLISECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MILLISECOND, 0)
}

func (s *MultiUnitsContext) T_MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MILLISECONDS, 0)
}

func (s *MultiUnitsContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECOND, 0)
}

func (s *MultiUnitsContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECONDS, 0)
}

func (s *MultiUnitsContext) T_MINUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTE, 0)
}

func (s *MultiUnitsContext) T_MINUTES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTES, 0)
}

func (s *MultiUnitsContext) T_HOUR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOUR, 0)
}

func (s *MultiUnitsContext) T_HOURS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOURS, 0)
}

func (s *MultiUnitsContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAY, 0)
}

func (s *MultiUnitsContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAYS, 0)
}

func (s *MultiUnitsContext) T_WEEK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEK, 0)
}

func (s *MultiUnitsContext) T_WEEKS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEKS, 0)
}

func (s *MultiUnitsContext) T_MONTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTH, 0)
}

func (s *MultiUnitsContext) T_MONTHS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTHS, 0)
}

func (s *MultiUnitsContext) T_YEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEAR, 0)
}

func (s *MultiUnitsContext) T_YEARS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEARS, 0)
}

func (s *MultiUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiUnits(s)
	}
}

func (s *MultiUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiUnits(s)
	}
}

func (p *UniversalParser) MultiUnits() (localctx IMultiUnitsContext) {
	localctx = NewMultiUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, UniversalParserRULE_multiUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_DAY || _la == UniversalParserT_DAYS || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&14002280579727363) != 0) || _la == UniversalParserT_SECOND || _la == UniversalParserT_SECONDS || ((int64((_la-292)) & ^0x3f) == 0 && ((int64(1)<<(_la-292))&387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitToUnitContext is an interface to support dynamic dispatch.
type IUnitToUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SECOND() antlr.TerminalNode
	T_MINUTE() antlr.TerminalNode
	T_HOUR() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_MONTH() antlr.TerminalNode
	T_YEAR() antlr.TerminalNode

	// IsUnitToUnitContext differentiates from other interfaces.
	IsUnitToUnitContext()
}

type UnitToUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitToUnitContext() *UnitToUnitContext {
	var p = new(UnitToUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unitToUnit
	return p
}

func InitEmptyUnitToUnitContext(p *UnitToUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_unitToUnit
}

func (*UnitToUnitContext) IsUnitToUnitContext() {}

func NewUnitToUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitToUnitContext {
	var p = new(UnitToUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_unitToUnit

	return p
}

func (s *UnitToUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitToUnitContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECOND, 0)
}

func (s *UnitToUnitContext) T_MINUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTE, 0)
}

func (s *UnitToUnitContext) T_HOUR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOUR, 0)
}

func (s *UnitToUnitContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAY, 0)
}

func (s *UnitToUnitContext) T_MONTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTH, 0)
}

func (s *UnitToUnitContext) T_YEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEAR, 0)
}

func (s *UnitToUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitToUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitToUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnitToUnit(s)
	}
}

func (s *UnitToUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnitToUnit(s)
	}
}

func (p *UniversalParser) UnitToUnit() (localctx IUnitToUnitContext) {
	localctx = NewUnitToUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, UniversalParserRULE_unitToUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_DAY || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&158329674399745) != 0) || _la == UniversalParserT_SECOND || _la == UniversalParserT_YEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	String_() IStringContext

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMMENT, 0)
}

func (s *CommentSpecContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCommentSpec(s)
	}
}

func (s *CommentSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCommentSpec(s)
	}
}

func (p *UniversalParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, UniversalParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1870)
		p.Match(UniversalParserT_COMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1871)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WINDOW() antlr.TerminalNode
	AllNamedWindow() []INamedWindowContext
	NamedWindow(i int) INamedWindowContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) T_WINDOW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WINDOW, 0)
}

func (s *WindowClauseContext) AllNamedWindow() []INamedWindowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedWindowContext); ok {
			len++
		}
	}

	tst := make([]INamedWindowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedWindowContext); ok {
			tst[i] = t.(INamedWindowContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) NamedWindow(i int) INamedWindowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedWindowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedWindowContext)
}

func (s *WindowClauseContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *WindowClauseContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (p *UniversalParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, UniversalParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		p.Match(UniversalParserT_WINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1874)
		p.NamedWindow()
	}
	p.SetState(1879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1875)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1876)
				p.NamedWindow()
			}

		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedWindowContext is an interface to support dynamic dispatch.
type INamedWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	T_AS() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	Identifier() IIdentifierContext

	// IsNamedWindowContext differentiates from other interfaces.
	IsNamedWindowContext()
}

type NamedWindowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedWindowContext() *NamedWindowContext {
	var p = new(NamedWindowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedWindow
	return p
}

func InitEmptyNamedWindowContext(p *NamedWindowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_namedWindow
}

func (*NamedWindowContext) IsNamedWindowContext() {}

func NewNamedWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedWindowContext {
	var p = new(NamedWindowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_namedWindow

	return p
}

func (s *NamedWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedWindowContext) GetName() IIdentifierContext { return s.name }

func (s *NamedWindowContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedWindowContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *NamedWindowContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *NamedWindowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNamedWindow(s)
	}
}

func (s *NamedWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNamedWindow(s)
	}
}

func (p *UniversalParser) NamedWindow() (localctx INamedWindowContext) {
	localctx = NewNamedWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, UniversalParserRULE_namedWindow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1882)

		var _x = p.Identifier()

		localctx.(*NamedWindowContext).name = _x
	}
	{
		p.SetState(1883)
		p.Match(UniversalParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1884)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) CopyAll(ctx *WindowSpecContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WindowRefContext struct {
	WindowSpecContext
	name IIdentifierContext
}

func NewWindowRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowRefContext {
	var p = new(WindowRefContext)

	InitEmptyWindowSpecContext(&p.WindowSpecContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowSpecContext))

	return p
}

func (s *WindowRefContext) GetName() IIdentifierContext { return s.name }

func (s *WindowRefContext) SetName(v IIdentifierContext) { s.name = v }

func (s *WindowRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowRefContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *WindowRefContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *WindowRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterWindowRef(s)
	}
}

func (s *WindowRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitWindowRef(s)
	}
}

type WindowDefContext struct {
	WindowSpecContext
}

func NewWindowDefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowDefContext {
	var p = new(WindowDefContext)

	InitEmptyWindowSpecContext(&p.WindowSpecContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowSpecContext))

	return p
}

func (s *WindowDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowDefContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *WindowDefContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *WindowDefContext) ClusterBy() IClusterByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterByContext)
}

func (s *WindowDefContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowDefContext) PartitionBy() IPartitionByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByContext)
}

func (s *WindowDefContext) DistributeBy() IDistributeByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeByContext)
}

func (s *WindowDefContext) OrderBy() IOrderByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByContext)
}

func (s *WindowDefContext) SortBy() ISortByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByContext)
}

func (s *WindowDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterWindowDef(s)
	}
}

func (s *WindowDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitWindowDef(s)
	}
}

func (p *UniversalParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, UniversalParserRULE_windowSpec)
	var _la int

	p.SetState(1907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWindowRefContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1886)

			var _x = p.Identifier()

			localctx.(*WindowRefContext).name = _x
		}

	case 2:
		localctx = NewWindowRefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1887)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1888)

			var _x = p.Identifier()

			localctx.(*WindowRefContext).name = _x
		}
		{
			p.SetState(1889)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewWindowDefContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1891)
			p.Match(UniversalParserK_OPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1892)
				p.ClusterBy()
			}

		case 2:
			p.SetState(1895)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case UniversalParserT_PARTITION:
				{
					p.SetState(1893)
					p.PartitionBy()
				}

			case UniversalParserT_DISTRIBUTE:
				{
					p.SetState(1894)
					p.DistributeBy()
				}

			case UniversalParserT_ORDER, UniversalParserT_RANGE, UniversalParserT_ROWS, UniversalParserT_SORT, UniversalParserT_SORTED, UniversalParserK_CLOSE_PAREN:

			default:
			}
			p.SetState(1899)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case UniversalParserT_ORDER:
				{
					p.SetState(1897)
					p.OrderBy()
				}

			case UniversalParserT_SORT, UniversalParserT_SORTED:
				{
					p.SetState(1898)
					p.SortBy()
				}

			case UniversalParserT_RANGE, UniversalParserT_ROWS, UniversalParserK_CLOSE_PAREN:

			default:
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_RANGE || _la == UniversalParserT_ROWS {
			{
				p.SetState(1903)
				p.WindowFrame()
			}

		}
		{
			p.SetState(1906)
			p.Match(UniversalParserK_CLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) CopyAll(ctx *WindowFrameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BetweenWindowFrameContext struct {
	WindowFrameContext
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewBetweenWindowFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenWindowFrameContext {
	var p = new(BetweenWindowFrameContext)

	InitEmptyWindowFrameContext(&p.WindowFrameContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowFrameContext))

	return p
}

func (s *BetweenWindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *BetweenWindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *BetweenWindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *BetweenWindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *BetweenWindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *BetweenWindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *BetweenWindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenWindowFrameContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BETWEEN, 0)
}

func (s *BetweenWindowFrameContext) T_AND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AND, 0)
}

func (s *BetweenWindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *BetweenWindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *BetweenWindowFrameContext) T_RANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RANGE, 0)
}

func (s *BetweenWindowFrameContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROWS, 0)
}

func (s *BetweenWindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBetweenWindowFrame(s)
	}
}

func (s *BetweenWindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBetweenWindowFrame(s)
	}
}

type StandardWindowFrameContext struct {
	WindowFrameContext
	frameType antlr.Token
	start_    IFrameBoundContext
}

func NewStandardWindowFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StandardWindowFrameContext {
	var p = new(StandardWindowFrameContext)

	InitEmptyWindowFrameContext(&p.WindowFrameContext)
	p.parser = parser
	p.CopyAll(ctx.(*WindowFrameContext))

	return p
}

func (s *StandardWindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *StandardWindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *StandardWindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *StandardWindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *StandardWindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardWindowFrameContext) FrameBound() IFrameBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *StandardWindowFrameContext) T_RANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RANGE, 0)
}

func (s *StandardWindowFrameContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROWS, 0)
}

func (s *StandardWindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStandardWindowFrame(s)
	}
}

func (s *StandardWindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStandardWindowFrame(s)
	}
}

func (p *UniversalParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, UniversalParserRULE_windowFrame)
	var _la int

	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStandardWindowFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1909)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StandardWindowFrameContext).frameType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_RANGE || _la == UniversalParserT_ROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StandardWindowFrameContext).frameType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1910)

			var _x = p.FrameBound()

			localctx.(*StandardWindowFrameContext).start_ = _x
		}

	case 2:
		localctx = NewBetweenWindowFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1911)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BetweenWindowFrameContext).frameType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_RANGE || _la == UniversalParserT_ROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BetweenWindowFrameContext).frameType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1912)
			p.Match(UniversalParserT_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1913)

			var _x = p.FrameBound()

			localctx.(*BetweenWindowFrameContext).start_ = _x
		}
		{
			p.SetState(1914)
			p.Match(UniversalParserT_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1915)

			var _x = p.FrameBound()

			localctx.(*BetweenWindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnboundedPrecedingContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedPrecedingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedPrecedingContext {
	var p = new(UnboundedPrecedingContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedPrecedingContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedPrecedingContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedPrecedingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedPrecedingContext) T_UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNBOUNDED, 0)
}

func (s *UnboundedPrecedingContext) T_PRECEDING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRECEDING, 0)
}

func (s *UnboundedPrecedingContext) T_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOLLOWING, 0)
}

func (s *UnboundedPrecedingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnboundedPreceding(s)
	}
}

func (s *UnboundedPrecedingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnboundedPreceding(s)
	}
}

type CurrentRowContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewCurrentRowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowContext {
	var p = new(CurrentRowContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowContext) GetBoundType() antlr.Token { return s.boundType }

func (s *CurrentRowContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *CurrentRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW, 0)
}

func (s *CurrentRowContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT, 0)
}

func (s *CurrentRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCurrentRow(s)
	}
}

func (s *CurrentRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCurrentRow(s)
	}
}

type PrecedingContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewPrecedingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrecedingContext {
	var p = new(PrecedingContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *PrecedingContext) GetBoundType() antlr.Token { return s.boundType }

func (s *PrecedingContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *PrecedingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecedingContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrecedingContext) T_PRECEDING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRECEDING, 0)
}

func (s *PrecedingContext) T_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOLLOWING, 0)
}

func (s *PrecedingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPreceding(s)
	}
}

func (s *PrecedingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPreceding(s)
	}
}

func (p *UniversalParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, UniversalParserRULE_frameBound)
	var _la int

	p.SetState(1926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedPrecedingContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1919)
			p.Match(UniversalParserT_UNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1920)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnboundedPrecedingContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_FOLLOWING || _la == UniversalParserT_PRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnboundedPrecedingContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		localctx = NewCurrentRowContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1921)

			var _m = p.Match(UniversalParserT_CURRENT)

			localctx.(*CurrentRowContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1922)
			p.Match(UniversalParserT_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPrecedingContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1923)
			p.Expression()
		}
		{
			p.SetState(1924)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PrecedingContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_FOLLOWING || _la == UniversalParserT_PRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PrecedingContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableProviderContext is an interface to support dynamic dispatch.
type ITableProviderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USING() antlr.TerminalNode
	MultiIdentifier() IMultiIdentifierContext

	// IsTableProviderContext differentiates from other interfaces.
	IsTableProviderContext()
}

type TableProviderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableProviderContext() *TableProviderContext {
	var p = new(TableProviderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableProvider
	return p
}

func InitEmptyTableProviderContext(p *TableProviderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_tableProvider
}

func (*TableProviderContext) IsTableProviderContext() {}

func NewTableProviderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableProviderContext {
	var p = new(TableProviderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_tableProvider

	return p
}

func (s *TableProviderContext) GetParser() antlr.Parser { return s.parser }

func (s *TableProviderContext) T_USING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_USING, 0)
}

func (s *TableProviderContext) MultiIdentifier() IMultiIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *TableProviderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableProviderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableProviderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTableProvider(s)
	}
}

func (s *TableProviderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTableProvider(s)
	}
}

func (p *UniversalParser) TableProvider() (localctx ITableProviderContext) {
	localctx = NewTableProviderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, UniversalParserRULE_tableProvider)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1928)
		p.Match(UniversalParserT_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1929)
		p.MultiIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileFormatContext is an interface to support dynamic dispatch.
type ICreateFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	FileFormat() IFileFormatContext
	T_BY() antlr.TerminalNode
	StorageHandler() IStorageHandlerContext

	// IsCreateFileFormatContext differentiates from other interfaces.
	IsCreateFileFormatContext()
}

type CreateFileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFileFormatContext() *CreateFileFormatContext {
	var p = new(CreateFileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createFileFormat
	return p
}

func InitEmptyCreateFileFormatContext(p *CreateFileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_createFileFormat
}

func (*CreateFileFormatContext) IsCreateFileFormatContext() {}

func NewCreateFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileFormatContext {
	var p = new(CreateFileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_createFileFormat

	return p
}

func (s *CreateFileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileFormatContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORED, 0)
}

func (s *CreateFileFormatContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *CreateFileFormatContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *CreateFileFormatContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *CreateFileFormatContext) StorageHandler() IStorageHandlerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageHandlerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageHandlerContext)
}

func (s *CreateFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterCreateFileFormat(s)
	}
}

func (s *CreateFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitCreateFileFormat(s)
	}
}

func (p *UniversalParser) CreateFileFormat() (localctx ICreateFileFormatContext) {
	localctx = NewCreateFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, UniversalParserRULE_createFileFormat)
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1931)
			p.Match(UniversalParserT_STORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1932)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			p.FileFormat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1934)
			p.Match(UniversalParserT_STORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.Match(UniversalParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1936)
			p.StorageHandler()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) CopyAll(ctx *FileFormatContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableFileFormatContext struct {
	FileFormatContext
	inFmt  IStringContext
	outFmt IStringContext
}

func NewTableFileFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFileFormatContext {
	var p = new(TableFileFormatContext)

	InitEmptyFileFormatContext(&p.FileFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*FileFormatContext))

	return p
}

func (s *TableFileFormatContext) GetInFmt() IStringContext { return s.inFmt }

func (s *TableFileFormatContext) GetOutFmt() IStringContext { return s.outFmt }

func (s *TableFileFormatContext) SetInFmt(v IStringContext) { s.inFmt = v }

func (s *TableFileFormatContext) SetOutFmt(v IStringContext) { s.outFmt = v }

func (s *TableFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFileFormatContext) T_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INPUTFORMAT, 0)
}

func (s *TableFileFormatContext) T_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUTPUTFORMAT, 0)
}

func (s *TableFileFormatContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *TableFileFormatContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TableFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTableFileFormat(s)
	}
}

func (s *TableFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTableFileFormat(s)
	}
}

type GenericFileFormatContext struct {
	FileFormatContext
}

func NewGenericFileFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GenericFileFormatContext {
	var p = new(GenericFileFormatContext)

	InitEmptyFileFormatContext(&p.FileFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*FileFormatContext))

	return p
}

func (s *GenericFileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericFileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GenericFileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterGenericFileFormat(s)
	}
}

func (s *GenericFileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitGenericFileFormat(s)
	}
}

func (p *UniversalParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, UniversalParserRULE_fileFormat)
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableFileFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1939)
			p.Match(UniversalParserT_INPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1940)

			var _x = p.String_()

			localctx.(*TableFileFormatContext).inFmt = _x
		}
		{
			p.SetState(1941)
			p.Match(UniversalParserT_OUTPUTFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1942)

			var _x = p.String_()

			localctx.(*TableFileFormatContext).outFmt = _x
		}

	case 2:
		localctx = NewGenericFileFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1944)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageHandlerContext is an interface to support dynamic dispatch.
type IStorageHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	String_() IStringContext
	T_WITH() antlr.TerminalNode
	T_SERDEPROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsStorageHandlerContext differentiates from other interfaces.
	IsStorageHandlerContext()
}

type StorageHandlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageHandlerContext() *StorageHandlerContext {
	var p = new(StorageHandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storageHandler
	return p
}

func InitEmptyStorageHandlerContext(p *StorageHandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_storageHandler
}

func (*StorageHandlerContext) IsStorageHandlerContext() {}

func NewStorageHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageHandlerContext {
	var p = new(StorageHandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_storageHandler

	return p
}

func (s *StorageHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageHandlerContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StorageHandlerContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *StorageHandlerContext) T_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDEPROPERTIES, 0)
}

func (s *StorageHandlerContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *StorageHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStorageHandler(s)
	}
}

func (s *StorageHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStorageHandler(s)
	}
}

func (p *UniversalParser) StorageHandler() (localctx IStorageHandlerContext) {
	localctx = NewStorageHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, UniversalParserRULE_storageHandler)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1947)
		p.String_()
	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_WITH {
		{
			p.SetState(1948)
			p.Match(UniversalParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1949)
			p.Match(UniversalParserT_SERDEPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1950)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowFormatContext is an interface to support dynamic dispatch.
type IRowFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRowFormatContext differentiates from other interfaces.
	IsRowFormatContext()
}

type RowFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowFormatContext() *RowFormatContext {
	var p = new(RowFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_rowFormat
	return p
}

func InitEmptyRowFormatContext(p *RowFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_rowFormat
}

func (*RowFormatContext) IsRowFormatContext() {}

func NewRowFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowFormatContext {
	var p = new(RowFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_rowFormat

	return p
}

func (s *RowFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *RowFormatContext) CopyAll(ctx *RowFormatContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RowFormatSerdeContext struct {
	RowFormatContext
	name  IStringContext
	props IPropertyListContext
}

func NewRowFormatSerdeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowFormatSerdeContext {
	var p = new(RowFormatSerdeContext)

	InitEmptyRowFormatContext(&p.RowFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowFormatContext))

	return p
}

func (s *RowFormatSerdeContext) GetName() IStringContext { return s.name }

func (s *RowFormatSerdeContext) GetProps() IPropertyListContext { return s.props }

func (s *RowFormatSerdeContext) SetName(v IStringContext) { s.name = v }

func (s *RowFormatSerdeContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *RowFormatSerdeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatSerdeContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW, 0)
}

func (s *RowFormatSerdeContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FORMAT, 0)
}

func (s *RowFormatSerdeContext) T_SERDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDE, 0)
}

func (s *RowFormatSerdeContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowFormatSerdeContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *RowFormatSerdeContext) T_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDEPROPERTIES, 0)
}

func (s *RowFormatSerdeContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RowFormatSerdeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRowFormatSerde(s)
	}
}

func (s *RowFormatSerdeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRowFormatSerde(s)
	}
}

type RowFormatDelimitedContext struct {
	RowFormatContext
	fieldsTerminatedBy          IStringContext
	escapedBy                   IStringContext
	collectionItemsTerminatedBy IStringContext
	keysTerminatedBy            IStringContext
	linesSeparatedBy            IStringContext
	nullDefinedAs               IStringContext
}

func NewRowFormatDelimitedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowFormatDelimitedContext {
	var p = new(RowFormatDelimitedContext)

	InitEmptyRowFormatContext(&p.RowFormatContext)
	p.parser = parser
	p.CopyAll(ctx.(*RowFormatContext))

	return p
}

func (s *RowFormatDelimitedContext) GetFieldsTerminatedBy() IStringContext {
	return s.fieldsTerminatedBy
}

func (s *RowFormatDelimitedContext) GetEscapedBy() IStringContext { return s.escapedBy }

func (s *RowFormatDelimitedContext) GetCollectionItemsTerminatedBy() IStringContext {
	return s.collectionItemsTerminatedBy
}

func (s *RowFormatDelimitedContext) GetKeysTerminatedBy() IStringContext { return s.keysTerminatedBy }

func (s *RowFormatDelimitedContext) GetLinesSeparatedBy() IStringContext { return s.linesSeparatedBy }

func (s *RowFormatDelimitedContext) GetNullDefinedAs() IStringContext { return s.nullDefinedAs }

func (s *RowFormatDelimitedContext) SetFieldsTerminatedBy(v IStringContext) { s.fieldsTerminatedBy = v }

func (s *RowFormatDelimitedContext) SetEscapedBy(v IStringContext) { s.escapedBy = v }

func (s *RowFormatDelimitedContext) SetCollectionItemsTerminatedBy(v IStringContext) {
	s.collectionItemsTerminatedBy = v
}

func (s *RowFormatDelimitedContext) SetKeysTerminatedBy(v IStringContext) { s.keysTerminatedBy = v }

func (s *RowFormatDelimitedContext) SetLinesSeparatedBy(v IStringContext) { s.linesSeparatedBy = v }

func (s *RowFormatDelimitedContext) SetNullDefinedAs(v IStringContext) { s.nullDefinedAs = v }

func (s *RowFormatDelimitedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowFormatDelimitedContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW, 0)
}

func (s *RowFormatDelimitedContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FORMAT, 0)
}

func (s *RowFormatDelimitedContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DELIMITED, 0)
}

func (s *RowFormatDelimitedContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIELDS, 0)
}

func (s *RowFormatDelimitedContext) AllT_TERMINATED() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_TERMINATED)
}

func (s *RowFormatDelimitedContext) T_TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TERMINATED, i)
}

func (s *RowFormatDelimitedContext) AllT_BY() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserT_BY)
}

func (s *RowFormatDelimitedContext) T_BY(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, i)
}

func (s *RowFormatDelimitedContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLECTION, 0)
}

func (s *RowFormatDelimitedContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ITEMS, 0)
}

func (s *RowFormatDelimitedContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP, 0)
}

func (s *RowFormatDelimitedContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEYS, 0)
}

func (s *RowFormatDelimitedContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LINES, 0)
}

func (s *RowFormatDelimitedContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULL, 0)
}

func (s *RowFormatDelimitedContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFINED, 0)
}

func (s *RowFormatDelimitedContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *RowFormatDelimitedContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *RowFormatDelimitedContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowFormatDelimitedContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ESCAPED, 0)
}

func (s *RowFormatDelimitedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterRowFormatDelimited(s)
	}
}

func (s *RowFormatDelimitedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitRowFormatDelimited(s)
	}
}

func (p *UniversalParser) RowFormat() (localctx IRowFormatContext) {
	localctx = NewRowFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, UniversalParserRULE_rowFormat)
	var _la int

	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRowFormatSerdeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1953)
			p.Match(UniversalParserT_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1954)
			p.Match(UniversalParserT_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Match(UniversalParserT_SERDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1956)

			var _x = p.String_()

			localctx.(*RowFormatSerdeContext).name = _x
		}
		p.SetState(1960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_WITH {
			{
				p.SetState(1957)
				p.Match(UniversalParserT_WITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1958)
				p.Match(UniversalParserT_SERDEPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1959)

				var _x = p.PropertyList()

				localctx.(*RowFormatSerdeContext).props = _x
			}

		}

	case 2:
		localctx = NewRowFormatDelimitedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1962)
			p.Match(UniversalParserT_ROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1963)
			p.Match(UniversalParserT_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1964)
			p.Match(UniversalParserT_DELIMITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_FIELDS {
			{
				p.SetState(1965)
				p.Match(UniversalParserT_FIELDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1966)
				p.Match(UniversalParserT_TERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1967)
				p.Match(UniversalParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1968)

				var _x = p.String_()

				localctx.(*RowFormatDelimitedContext).fieldsTerminatedBy = _x
			}
			p.SetState(1972)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == UniversalParserT_ESCAPED {
				{
					p.SetState(1969)
					p.Match(UniversalParserT_ESCAPED)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1970)
					p.Match(UniversalParserT_BY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1971)

					var _x = p.String_()

					localctx.(*RowFormatDelimitedContext).escapedBy = _x
				}

			}

		}
		p.SetState(1981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_COLLECTION {
			{
				p.SetState(1976)
				p.Match(UniversalParserT_COLLECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1977)
				p.Match(UniversalParserT_ITEMS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1978)
				p.Match(UniversalParserT_TERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1979)
				p.Match(UniversalParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1980)

				var _x = p.String_()

				localctx.(*RowFormatDelimitedContext).collectionItemsTerminatedBy = _x
			}

		}
		p.SetState(1988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_MAP {
			{
				p.SetState(1983)
				p.Match(UniversalParserT_MAP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1984)
				p.Match(UniversalParserT_KEYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1985)
				p.Match(UniversalParserT_TERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1986)
				p.Match(UniversalParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1987)

				var _x = p.String_()

				localctx.(*RowFormatDelimitedContext).keysTerminatedBy = _x
			}

		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_LINES {
			{
				p.SetState(1990)
				p.Match(UniversalParserT_LINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1991)
				p.Match(UniversalParserT_TERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1992)
				p.Match(UniversalParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1993)

				var _x = p.String_()

				localctx.(*RowFormatDelimitedContext).linesSeparatedBy = _x
			}

		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_NULL {
			{
				p.SetState(1996)
				p.Match(UniversalParserT_NULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1997)
				p.Match(UniversalParserT_DEFINED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1998)
				p.Match(UniversalParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1999)

				var _x = p.String_()

				localctx.(*RowFormatDelimitedContext).nullDefinedAs = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPEN_PAREN() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	K_CLOSE_PAREN() antlr.TerminalNode
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) K_OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_OPEN_PAREN, 0)
}

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) K_CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_CLOSE_PAREN, 0)
}

func (s *PropertyListContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *PropertyListContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (p *UniversalParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, UniversalParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2004)
		p.Match(UniversalParserK_OPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2005)
		p.Property()
	}
	p.SetState(2010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(2006)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.Property()
		}

		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2013)
		p.Match(UniversalParserK_CLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext
	K_EQ() antlr.TerminalNode

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyContext) K_EQ() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_EQ, 0)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *UniversalParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, UniversalParserRULE_property)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2015)

		var _x = p.PropertyKey()

		localctx.(*PropertyContext).key = _x
	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_FALSE || _la == UniversalParserT_TRUE || ((int64((_la-746)) & ^0x3f) == 0 && ((int64(1)<<(_la-746))&268435603) != 0) {
		p.SetState(2017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_EQ {
			{
				p.SetState(2016)
				p.Match(UniversalParserK_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2019)

			var _x = p.PropertyValue()

			localctx.(*PropertyContext).value = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllK_DOT() []antlr.TerminalNode
	K_DOT(i int) antlr.TerminalNode
	String_() IStringContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PropertyKeyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyKeyContext) AllK_DOT() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_DOT)
}

func (s *PropertyKeyContext) K_DOT(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_DOT, i)
}

func (s *PropertyKeyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPropertyKey(s)
	}
}

func (s *PropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPropertyKey(s)
	}
}

func (p *UniversalParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, UniversalParserRULE_propertyKey)
	var _la int

	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2022)
			p.Identifier()
		}
		p.SetState(2027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_DOT {
			{
				p.SetState(2023)
				p.Match(UniversalParserK_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2024)
				p.Identifier()
			}

			p.SetState(2029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2030)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	Boolean() IBooleanContext
	String_() IStringContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, 0)
}

func (s *PropertyValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserDECIMAL_VALUE, 0)
}

func (s *PropertyValueContext) Boolean() IBooleanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanContext)
}

func (s *PropertyValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *UniversalParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, UniversalParserRULE_propertyValue)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2033)
			p.Match(UniversalParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserDECIMAL_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2034)
			p.Match(UniversalParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserT_FALSE, UniversalParserT_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2035)
			p.Boolean()
		}

	case UniversalParserSINGLE_QUOTED_STRING, UniversalParserDOUBLE_QUOTED_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2036)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) CopyAll(ctx *ArgumentsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StarsContext struct {
	ArgumentsContext
}

func NewStarsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarsContext {
	var p = new(StarsContext)

	InitEmptyArgumentsContext(&p.ArgumentsContext)
	p.parser = parser
	p.CopyAll(ctx.(*ArgumentsContext))

	return p
}

func (s *StarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarsContext) K_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MULTIPLY, 0)
}

func (s *StarsContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *StarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStars(s)
	}
}

func (s *StarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStars(s)
	}
}

type StandardArgsContext struct {
	ArgumentsContext
	_expression        IExpressionContext
	argumentCollection []IExpressionContext
}

func NewStandardArgsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StandardArgsContext {
	var p = new(StandardArgsContext)

	InitEmptyArgumentsContext(&p.ArgumentsContext)
	p.parser = parser
	p.CopyAll(ctx.(*ArgumentsContext))

	return p
}

func (s *StandardArgsContext) Get_expression() IExpressionContext { return s._expression }

func (s *StandardArgsContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *StandardArgsContext) GetArgumentCollection() []IExpressionContext {
	return s.argumentCollection
}

func (s *StandardArgsContext) SetArgumentCollection(v []IExpressionContext) { s.argumentCollection = v }

func (s *StandardArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StandardArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StandardArgsContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *StandardArgsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *StandardArgsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *StandardArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterStandardArgs(s)
	}
}

func (s *StandardArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitStandardArgs(s)
	}
}

func (p *UniversalParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, UniversalParserRULE_arguments)
	var _la int

	p.SetState(2054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStandardArgsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2039)
				p.SetQuantifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2042)

			var _x = p.Expression()

			localctx.(*StandardArgsContext)._expression = _x
		}
		localctx.(*StandardArgsContext).argumentCollection = append(localctx.(*StandardArgsContext).argumentCollection, localctx.(*StandardArgsContext)._expression)
		p.SetState(2047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == UniversalParserK_COMMA {
			{
				p.SetState(2043)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2044)

				var _x = p.Expression()

				localctx.(*StandardArgsContext)._expression = _x
			}
			localctx.(*StandardArgsContext).argumentCollection = append(localctx.(*StandardArgsContext).argumentCollection, localctx.(*StandardArgsContext)._expression)

			p.SetState(2049)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewStarsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserT_ALL || _la == UniversalParserT_DISTINCT {
			{
				p.SetState(2050)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(2053)
			p.Match(UniversalParserK_MULTIPLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByContext is an interface to support dynamic dispatch.
type IOrderByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ORDER() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	SortItems() ISortItemsContext

	// IsOrderByContext differentiates from other interfaces.
	IsOrderByContext()
}

type OrderByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByContext() *OrderByContext {
	var p = new(OrderByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_orderBy
	return p
}

func InitEmptyOrderByContext(p *OrderByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_orderBy
}

func (*OrderByContext) IsOrderByContext() {}

func NewOrderByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByContext {
	var p = new(OrderByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_orderBy

	return p
}

func (s *OrderByContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ORDER, 0)
}

func (s *OrderByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *OrderByContext) SortItems() ISortItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemsContext)
}

func (s *OrderByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterOrderBy(s)
	}
}

func (s *OrderByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitOrderBy(s)
	}
}

func (p *UniversalParser) OrderBy() (localctx IOrderByContext) {
	localctx = NewOrderByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, UniversalParserRULE_orderBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Match(UniversalParserT_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2057)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2058)
		p.SortItems()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortByContext is an interface to support dynamic dispatch.
type ISortByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortKeyword returns the sortKeyword token.
	GetSortKeyword() antlr.Token

	// SetSortKeyword sets the sortKeyword token.
	SetSortKeyword(antlr.Token)

	// Getter signatures
	T_BY() antlr.TerminalNode
	SortItems() ISortItemsContext
	T_SORT() antlr.TerminalNode
	T_SORTED() antlr.TerminalNode

	// IsSortByContext differentiates from other interfaces.
	IsSortByContext()
}

type SortByContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	sortKeyword antlr.Token
}

func NewEmptySortByContext() *SortByContext {
	var p = new(SortByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortBy
	return p
}

func InitEmptySortByContext(p *SortByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortBy
}

func (*SortByContext) IsSortByContext() {}

func NewSortByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortByContext {
	var p = new(SortByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sortBy

	return p
}

func (s *SortByContext) GetParser() antlr.Parser { return s.parser }

func (s *SortByContext) GetSortKeyword() antlr.Token { return s.sortKeyword }

func (s *SortByContext) SetSortKeyword(v antlr.Token) { s.sortKeyword = v }

func (s *SortByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *SortByContext) SortItems() ISortItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemsContext)
}

func (s *SortByContext) T_SORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SORT, 0)
}

func (s *SortByContext) T_SORTED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SORTED, 0)
}

func (s *SortByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSortBy(s)
	}
}

func (s *SortByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSortBy(s)
	}
}

func (p *UniversalParser) SortBy() (localctx ISortByContext) {
	localctx = NewSortByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, UniversalParserRULE_sortBy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2060)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SortByContext).sortKeyword = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_SORT || _la == UniversalParserT_SORTED) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SortByContext).sortKeyword = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2061)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2062)
		p.SortItems()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributeByContext is an interface to support dynamic dispatch.
type IDistributeByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DISTRIBUTE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext

	// IsDistributeByContext differentiates from other interfaces.
	IsDistributeByContext()
}

type DistributeByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeByContext() *DistributeByContext {
	var p = new(DistributeByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_distributeBy
	return p
}

func InitEmptyDistributeByContext(p *DistributeByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_distributeBy
}

func (*DistributeByContext) IsDistributeByContext() {}

func NewDistributeByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeByContext {
	var p = new(DistributeByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_distributeBy

	return p
}

func (s *DistributeByContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeByContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISTRIBUTE, 0)
}

func (s *DistributeByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *DistributeByContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *DistributeByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributeByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDistributeBy(s)
	}
}

func (s *DistributeByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDistributeBy(s)
	}
}

func (p *UniversalParser) DistributeBy() (localctx IDistributeByContext) {
	localctx = NewDistributeByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, UniversalParserRULE_distributeBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2064)
		p.Match(UniversalParserT_DISTRIBUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2065)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2066)
		p.ExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionByContext is an interface to support dynamic dispatch.
type IPartitionByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITION() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext

	// IsPartitionByContext differentiates from other interfaces.
	IsPartitionByContext()
}

type PartitionByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByContext() *PartitionByContext {
	var p = new(PartitionByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionBy
	return p
}

func InitEmptyPartitionByContext(p *PartitionByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_partitionBy
}

func (*PartitionByContext) IsPartitionByContext() {}

func NewPartitionByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByContext {
	var p = new(PartitionByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_partitionBy

	return p
}

func (s *PartitionByContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITION, 0)
}

func (s *PartitionByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *PartitionByContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *PartitionByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterPartitionBy(s)
	}
}

func (s *PartitionByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitPartitionBy(s)
	}
}

func (p *UniversalParser) PartitionBy() (localctx IPartitionByContext) {
	localctx = NewPartitionByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, UniversalParserRULE_partitionBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.Match(UniversalParserT_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2069)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2070)
		p.ExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusterByContext is an interface to support dynamic dispatch.
type IClusterByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClusterKeyword returns the clusterKeyword token.
	GetClusterKeyword() antlr.Token

	// SetClusterKeyword sets the clusterKeyword token.
	SetClusterKeyword(antlr.Token)

	// GetOrdering returns the ordering rule contexts.
	GetOrdering() ISortTypeContext

	// SetOrdering sets the ordering rule contexts.
	SetOrdering(ISortTypeContext)

	// Getter signatures
	T_BY() antlr.TerminalNode
	ExpressionSeq() IExpressionSeqContext
	T_CLUSTER() antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	T_RANGE() antlr.TerminalNode
	SortType() ISortTypeContext

	// IsClusterByContext differentiates from other interfaces.
	IsClusterByContext()
}

type ClusterByContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	clusterKeyword antlr.Token
	ordering       ISortTypeContext
}

func NewEmptyClusterByContext() *ClusterByContext {
	var p = new(ClusterByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_clusterBy
	return p
}

func InitEmptyClusterByContext(p *ClusterByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_clusterBy
}

func (*ClusterByContext) IsClusterByContext() {}

func NewClusterByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterByContext {
	var p = new(ClusterByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_clusterBy

	return p
}

func (s *ClusterByContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterByContext) GetClusterKeyword() antlr.Token { return s.clusterKeyword }

func (s *ClusterByContext) SetClusterKeyword(v antlr.Token) { s.clusterKeyword = v }

func (s *ClusterByContext) GetOrdering() ISortTypeContext { return s.ordering }

func (s *ClusterByContext) SetOrdering(v ISortTypeContext) { s.ordering = v }

func (s *ClusterByContext) T_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BY, 0)
}

func (s *ClusterByContext) ExpressionSeq() IExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSeqContext)
}

func (s *ClusterByContext) T_CLUSTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLUSTER, 0)
}

func (s *ClusterByContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLUSTERED, 0)
}

func (s *ClusterByContext) T_RANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RANGE, 0)
}

func (s *ClusterByContext) SortType() ISortTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortTypeContext)
}

func (s *ClusterByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterClusterBy(s)
	}
}

func (s *ClusterByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitClusterBy(s)
	}
}

func (p *UniversalParser) ClusterBy() (localctx IClusterByContext) {
	localctx = NewClusterByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, UniversalParserRULE_clusterBy)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_RANGE {
		{
			p.SetState(2072)
			p.Match(UniversalParserT_RANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2075)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ClusterByContext).clusterKeyword = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_CLUSTER || _la == UniversalParserT_CLUSTERED) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ClusterByContext).clusterKeyword = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2076)
		p.Match(UniversalParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2077)
		p.ExpressionSeq()
	}
	p.SetState(2079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ASC || _la == UniversalParserT_DESC {
		{
			p.SetState(2078)

			var _x = p.SortType()

			localctx.(*ClusterByContext).ordering = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBucketsOptionContext is an interface to support dynamic dispatch.
type IBucketsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNum_buckets returns the num_buckets rule contexts.
	GetNum_buckets() INumberContext

	// SetNum_buckets sets the num_buckets rule contexts.
	SetNum_buckets(INumberContext)

	// Getter signatures
	T_INTO() antlr.TerminalNode
	T_BUCKETS() antlr.TerminalNode
	Number() INumberContext

	// IsBucketsOptionContext differentiates from other interfaces.
	IsBucketsOptionContext()
}

type BucketsOptionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	num_buckets INumberContext
}

func NewEmptyBucketsOptionContext() *BucketsOptionContext {
	var p = new(BucketsOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_bucketsOption
	return p
}

func InitEmptyBucketsOptionContext(p *BucketsOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_bucketsOption
}

func (*BucketsOptionContext) IsBucketsOptionContext() {}

func NewBucketsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BucketsOptionContext {
	var p = new(BucketsOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_bucketsOption

	return p
}

func (s *BucketsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BucketsOptionContext) GetNum_buckets() INumberContext { return s.num_buckets }

func (s *BucketsOptionContext) SetNum_buckets(v INumberContext) { s.num_buckets = v }

func (s *BucketsOptionContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTO, 0)
}

func (s *BucketsOptionContext) T_BUCKETS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BUCKETS, 0)
}

func (s *BucketsOptionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *BucketsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BucketsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BucketsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBucketsOption(s)
	}
}

func (s *BucketsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBucketsOption(s)
	}
}

func (p *UniversalParser) BucketsOption() (localctx IBucketsOptionContext) {
	localctx = NewBucketsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, UniversalParserRULE_bucketsOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2081)
		p.Match(UniversalParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2082)

		var _x = p.Number()

		localctx.(*BucketsOptionContext).num_buckets = _x
	}
	{
		p.SetState(2083)
		p.Match(UniversalParserT_BUCKETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitItemContext is an interface to support dynamic dispatch.
type ILimitItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expression() IExpressionContext
	T_ALL() antlr.TerminalNode

	// IsLimitItemContext differentiates from other interfaces.
	IsLimitItemContext()
}

type LimitItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitItemContext() *LimitItemContext {
	var p = new(LimitItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_limitItem
	return p
}

func InitEmptyLimitItemContext(p *LimitItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_limitItem
}

func (*LimitItemContext) IsLimitItemContext() {}

func NewLimitItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitItemContext {
	var p = new(LimitItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_limitItem

	return p
}

func (s *LimitItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitItemContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIMIT, 0)
}

func (s *LimitItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitItemContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALL, 0)
}

func (s *LimitItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLimitItem(s)
	}
}

func (s *LimitItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLimitItem(s)
	}
}

func (p *UniversalParser) LimitItem() (localctx ILimitItemContext) {
	localctx = NewLimitItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, UniversalParserRULE_limitItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2085)
		p.Match(UniversalParserT_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2086)
			p.Match(UniversalParserT_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2089)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOffsetItemContext is an interface to support dynamic dispatch.
type IOffsetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() IExpressionContext

	// SetOffset sets the offset rule contexts.
	SetOffset(IExpressionContext)

	// Getter signatures
	T_OFFSET() antlr.TerminalNode
	Expression() IExpressionContext

	// IsOffsetItemContext differentiates from other interfaces.
	IsOffsetItemContext()
}

type OffsetItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	offset IExpressionContext
}

func NewEmptyOffsetItemContext() *OffsetItemContext {
	var p = new(OffsetItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_offsetItem
	return p
}

func InitEmptyOffsetItemContext(p *OffsetItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_offsetItem
}

func (*OffsetItemContext) IsOffsetItemContext() {}

func NewOffsetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetItemContext {
	var p = new(OffsetItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_offsetItem

	return p
}

func (s *OffsetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetItemContext) GetOffset() IExpressionContext { return s.offset }

func (s *OffsetItemContext) SetOffset(v IExpressionContext) { s.offset = v }

func (s *OffsetItemContext) T_OFFSET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OFFSET, 0)
}

func (s *OffsetItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OffsetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterOffsetItem(s)
	}
}

func (s *OffsetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitOffsetItem(s)
	}
}

func (p *UniversalParser) OffsetItem() (localctx IOffsetItemContext) {
	localctx = NewOffsetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, UniversalParserRULE_offsetItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2091)
		p.Match(UniversalParserT_OFFSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2092)

		var _x = p.Expression()

		localctx.(*OffsetItemContext).offset = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemsContext is an interface to support dynamic dispatch.
type ISortItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_sortItem returns the _sortItem rule contexts.
	Get_sortItem() ISortItemContext

	// Set_sortItem sets the _sortItem rule contexts.
	Set_sortItem(ISortItemContext)

	// GetSortCollection returns the sortCollection rule context list.
	GetSortCollection() []ISortItemContext

	// SetSortCollection sets the sortCollection rule context list.
	SetSortCollection([]ISortItemContext)

	// Getter signatures
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsSortItemsContext differentiates from other interfaces.
	IsSortItemsContext()
}

type SortItemsContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_sortItem      ISortItemContext
	sortCollection []ISortItemContext
}

func NewEmptySortItemsContext() *SortItemsContext {
	var p = new(SortItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortItems
	return p
}

func InitEmptySortItemsContext(p *SortItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortItems
}

func (*SortItemsContext) IsSortItemsContext() {}

func NewSortItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemsContext {
	var p = new(SortItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sortItems

	return p
}

func (s *SortItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemsContext) Get_sortItem() ISortItemContext { return s._sortItem }

func (s *SortItemsContext) Set_sortItem(v ISortItemContext) { s._sortItem = v }

func (s *SortItemsContext) GetSortCollection() []ISortItemContext { return s.sortCollection }

func (s *SortItemsContext) SetSortCollection(v []ISortItemContext) { s.sortCollection = v }

func (s *SortItemsContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortItemsContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortItemsContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *SortItemsContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *SortItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSortItems(s)
	}
}

func (s *SortItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSortItems(s)
	}
}

func (p *UniversalParser) SortItems() (localctx ISortItemsContext) {
	localctx = NewSortItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, UniversalParserRULE_sortItems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2094)

		var _x = p.SortItem()

		localctx.(*SortItemsContext)._sortItem = _x
	}
	localctx.(*SortItemsContext).sortCollection = append(localctx.(*SortItemsContext).sortCollection, localctx.(*SortItemsContext)._sortItem)
	p.SetState(2099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(2095)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)

			var _x = p.SortItem()

			localctx.(*SortItemsContext)._sortItem = _x
		}
		localctx.(*SortItemsContext).sortCollection = append(localctx.(*SortItemsContext).sortCollection, localctx.(*SortItemsContext)._sortItem)

		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullOrder returns the nullOrder token.
	GetNullOrder() antlr.Token

	// SetNullOrder sets the nullOrder token.
	SetNullOrder(antlr.Token)

	// GetOrdering returns the ordering rule contexts.
	GetOrdering() ISortTypeContext

	// SetOrdering sets the ordering rule contexts.
	SetOrdering(ISortTypeContext)

	// Getter signatures
	Expression() IExpressionContext
	T_NULLS() antlr.TerminalNode
	SortType() ISortTypeContext
	T_LAST() antlr.TerminalNode
	T_FIRST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	ordering  ISortTypeContext
	nullOrder antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetNullOrder() antlr.Token { return s.nullOrder }

func (s *SortItemContext) SetNullOrder(v antlr.Token) { s.nullOrder = v }

func (s *SortItemContext) GetOrdering() ISortTypeContext { return s.ordering }

func (s *SortItemContext) SetOrdering(v ISortTypeContext) { s.ordering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *SortItemContext) SortType() ISortTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortTypeContext)
}

func (s *SortItemContext) T_LAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAST, 0)
}

func (s *SortItemContext) T_FIRST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIRST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *UniversalParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, UniversalParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2102)
		p.Expression()
	}
	p.SetState(2104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_ASC || _la == UniversalParserT_DESC {
		{
			p.SetState(2103)

			var _x = p.SortType()

			localctx.(*SortItemContext).ordering = _x
		}

	}
	p.SetState(2108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == UniversalParserT_NULLS {
		{
			p.SetState(2106)
			p.Match(UniversalParserT_NULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserT_FIRST || _la == UniversalParserT_LAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortTypeContext is an interface to support dynamic dispatch.
type ISortTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ASC() antlr.TerminalNode
	T_DESC() antlr.TerminalNode

	// IsSortTypeContext differentiates from other interfaces.
	IsSortTypeContext()
}

type SortTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortTypeContext() *SortTypeContext {
	var p = new(SortTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortType
	return p
}

func InitEmptySortTypeContext(p *SortTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_sortType
}

func (*SortTypeContext) IsSortTypeContext() {}

func NewSortTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortTypeContext {
	var p = new(SortTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_sortType

	return p
}

func (s *SortTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SortTypeContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ASC, 0)
}

func (s *SortTypeContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DESC, 0)
}

func (s *SortTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSortType(s)
	}
}

func (s *SortTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSortType(s)
	}
}

func (p *UniversalParser) SortType() (localctx ISortTypeContext) {
	localctx = NewSortTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, UniversalParserRULE_sortType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2110)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_ASC || _la == UniversalParserT_DESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasSpecContext is an interface to support dynamic dispatch.
type IAliasSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	T_AS() antlr.TerminalNode

	// IsAliasSpecContext differentiates from other interfaces.
	IsAliasSpecContext()
}

type AliasSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasSpecContext() *AliasSpecContext {
	var p = new(AliasSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_aliasSpec
	return p
}

func InitEmptyAliasSpecContext(p *AliasSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_aliasSpec
}

func (*AliasSpecContext) IsAliasSpecContext() {}

func NewAliasSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasSpecContext {
	var p = new(AliasSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_aliasSpec

	return p
}

func (s *AliasSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasSpecContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasSpecContext) T_AS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AS, 0)
}

func (s *AliasSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterAliasSpec(s)
	}
}

func (s *AliasSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitAliasSpec(s)
	}
}

func (p *UniversalParser) AliasSpec() (localctx IAliasSpecContext) {
	localctx = NewAliasSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, UniversalParserRULE_aliasSpec)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2112)
			p.Match(UniversalParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2115)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationSpecContext is an interface to support dynamic dispatch.
type ILocationSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LOCATION() antlr.TerminalNode
	String_() IStringContext

	// IsLocationSpecContext differentiates from other interfaces.
	IsLocationSpecContext()
}

type LocationSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationSpecContext() *LocationSpecContext {
	var p = new(LocationSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_locationSpec
	return p
}

func InitEmptyLocationSpecContext(p *LocationSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_locationSpec
}

func (*LocationSpecContext) IsLocationSpecContext() {}

func NewLocationSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationSpecContext {
	var p = new(LocationSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_locationSpec

	return p
}

func (s *LocationSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationSpecContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCATION, 0)
}

func (s *LocationSpecContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *LocationSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLocationSpec(s)
	}
}

func (s *LocationSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLocationSpec(s)
	}
}

func (p *UniversalParser) LocationSpec() (localctx ILocationSpecContext) {
	localctx = NewLocationSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, UniversalParserRULE_locationSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Match(UniversalParserT_LOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2118)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiIdentifierSeqContext is an interface to support dynamic dispatch.
type IMultiIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_multiIdentifier returns the _multiIdentifier rule contexts.
	Get_multiIdentifier() IMultiIdentifierContext

	// Set_multiIdentifier sets the _multiIdentifier rule contexts.
	Set_multiIdentifier(IMultiIdentifierContext)

	// GetMultiIdentifierList returns the multiIdentifierList rule context list.
	GetMultiIdentifierList() []IMultiIdentifierContext

	// SetMultiIdentifierList sets the multiIdentifierList rule context list.
	SetMultiIdentifierList([]IMultiIdentifierContext)

	// Getter signatures
	AllMultiIdentifier() []IMultiIdentifierContext
	MultiIdentifier(i int) IMultiIdentifierContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsMultiIdentifierSeqContext differentiates from other interfaces.
	IsMultiIdentifierSeqContext()
}

type MultiIdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_multiIdentifier    IMultiIdentifierContext
	multiIdentifierList []IMultiIdentifierContext
}

func NewEmptyMultiIdentifierSeqContext() *MultiIdentifierSeqContext {
	var p = new(MultiIdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiIdentifierSeq
	return p
}

func InitEmptyMultiIdentifierSeqContext(p *MultiIdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiIdentifierSeq
}

func (*MultiIdentifierSeqContext) IsMultiIdentifierSeqContext() {}

func NewMultiIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiIdentifierSeqContext {
	var p = new(MultiIdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_multiIdentifierSeq

	return p
}

func (s *MultiIdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiIdentifierSeqContext) Get_multiIdentifier() IMultiIdentifierContext {
	return s._multiIdentifier
}

func (s *MultiIdentifierSeqContext) Set_multiIdentifier(v IMultiIdentifierContext) {
	s._multiIdentifier = v
}

func (s *MultiIdentifierSeqContext) GetMultiIdentifierList() []IMultiIdentifierContext {
	return s.multiIdentifierList
}

func (s *MultiIdentifierSeqContext) SetMultiIdentifierList(v []IMultiIdentifierContext) {
	s.multiIdentifierList = v
}

func (s *MultiIdentifierSeqContext) AllMultiIdentifier() []IMultiIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultiIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiIdentifierContext); ok {
			tst[i] = t.(IMultiIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultiIdentifierSeqContext) MultiIdentifier(i int) IMultiIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiIdentifierContext)
}

func (s *MultiIdentifierSeqContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *MultiIdentifierSeqContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *MultiIdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiIdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiIdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiIdentifierSeq(s)
	}
}

func (s *MultiIdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiIdentifierSeq(s)
	}
}

func (p *UniversalParser) MultiIdentifierSeq() (localctx IMultiIdentifierSeqContext) {
	localctx = NewMultiIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, UniversalParserRULE_multiIdentifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2120)

		var _x = p.MultiIdentifier()

		localctx.(*MultiIdentifierSeqContext)._multiIdentifier = _x
	}
	localctx.(*MultiIdentifierSeqContext).multiIdentifierList = append(localctx.(*MultiIdentifierSeqContext).multiIdentifierList, localctx.(*MultiIdentifierSeqContext)._multiIdentifier)
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == UniversalParserK_COMMA {
		{
			p.SetState(2121)
			p.Match(UniversalParserK_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2122)

			var _x = p.MultiIdentifier()

			localctx.(*MultiIdentifierSeqContext)._multiIdentifier = _x
		}
		localctx.(*MultiIdentifierSeqContext).multiIdentifierList = append(localctx.(*MultiIdentifierSeqContext).multiIdentifierList, localctx.(*MultiIdentifierSeqContext)._multiIdentifier)

		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiIdentifierContext is an interface to support dynamic dispatch.
type IMultiIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllK_DOT() []antlr.TerminalNode
	K_DOT(i int) antlr.TerminalNode

	// IsMultiIdentifierContext differentiates from other interfaces.
	IsMultiIdentifierContext()
}

type MultiIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiIdentifierContext() *MultiIdentifierContext {
	var p = new(MultiIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiIdentifier
	return p
}

func InitEmptyMultiIdentifierContext(p *MultiIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_multiIdentifier
}

func (*MultiIdentifierContext) IsMultiIdentifierContext() {}

func NewMultiIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiIdentifierContext {
	var p = new(MultiIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_multiIdentifier

	return p
}

func (s *MultiIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiIdentifierContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultiIdentifierContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiIdentifierContext) AllK_DOT() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_DOT)
}

func (s *MultiIdentifierContext) K_DOT(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_DOT, i)
}

func (s *MultiIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterMultiIdentifier(s)
	}
}

func (s *MultiIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitMultiIdentifier(s)
	}
}

func (p *UniversalParser) MultiIdentifier() (localctx IMultiIdentifierContext) {
	localctx = NewMultiIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, UniversalParserRULE_multiIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2128)
		p.Identifier()
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2129)
				p.Match(UniversalParserK_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2130)
				p.Identifier()
			}

		}
		p.SetState(2135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetIdentifierCollection returns the identifierCollection rule context list.
	GetIdentifierCollection() []IIdentifierContext

	// SetIdentifierCollection sets the identifierCollection rule context list.
	SetIdentifierCollection([]IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllK_COMMA() []antlr.TerminalNode
	K_COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	_identifier          IIdentifierContext
	identifierCollection []IIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *IdentifierSeqContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *IdentifierSeqContext) GetIdentifierCollection() []IIdentifierContext {
	return s.identifierCollection
}

func (s *IdentifierSeqContext) SetIdentifierCollection(v []IIdentifierContext) {
	s.identifierCollection = v
}

func (s *IdentifierSeqContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierSeqContext) AllK_COMMA() []antlr.TerminalNode {
	return s.GetTokens(UniversalParserK_COMMA)
}

func (s *IdentifierSeqContext) K_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(UniversalParserK_COMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *UniversalParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, UniversalParserRULE_identifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)

		var _x = p.Identifier()

		localctx.(*IdentifierSeqContext)._identifier = _x
	}
	localctx.(*IdentifierSeqContext).identifierCollection = append(localctx.(*IdentifierSeqContext).identifierCollection, localctx.(*IdentifierSeqContext)._identifier)
	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2137)
				p.Match(UniversalParserK_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2138)

				var _x = p.Identifier()

				localctx.(*IdentifierSeqContext)._identifier = _x
			}
			localctx.(*IdentifierSeqContext).identifierCollection = append(localctx.(*IdentifierSeqContext).identifierCollection, localctx.(*IdentifierSeqContext)._identifier)

		}
		p.SetState(2143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type UnquotedIdentifierAlternativeContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierAlternativeContext {
	var p = new(UnquotedIdentifierAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierAlternativeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(UniversalParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierAlternativeContext) NoReservedKeywords() INoReservedKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoReservedKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoReservedKeywordsContext)
}

func (s *UnquotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterUnquotedIdentifierAlternative(s)
	}
}

func (s *UnquotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitUnquotedIdentifierAlternative(s)
	}
}

func (p *UniversalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, UniversalParserRULE_identifier)
	p.SetState(2147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnquotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2144)
			p.Match(UniversalParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2145)
			p.QuotedIdentifier()
		}

	case 3:
		localctx = NewUnquotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2146)
			p.NoReservedKeywords()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode
	DOUBLE_QUOTED_STRING() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(UniversalParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) DOUBLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserDOUBLE_QUOTED_STRING, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *UniversalParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, UniversalParserRULE_quotedIdentifier)
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2149)
			p.Match(UniversalParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2150)

		if !(DoubleQuotedIdentifierEnable) {
			p.SetError(antlr.NewFailedPredicateException(p, "DoubleQuotedIdentifierEnable", ""))
			goto errorExit
		}
		{
			p.SetState(2151)
			p.Match(UniversalParserDOUBLE_QUOTED_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type BigIntLiteralContext struct {
	NumberContext
}

func NewBigIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BigIntLiteralContext {
	var p = new(BigIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *BigIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigIntLiteralContext) BIGINT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserBIGINT_VALUE, 0)
}

func (s *BigIntLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *BigIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBigIntLiteral(s)
	}
}

func (s *BigIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBigIntLiteral(s)
	}
}

type TinyIntLiteralContext struct {
	NumberContext
}

func NewTinyIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TinyIntLiteralContext {
	var p = new(TinyIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *TinyIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TinyIntLiteralContext) TINYINT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserTINYINT_VALUE, 0)
}

func (s *TinyIntLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *TinyIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterTinyIntLiteral(s)
	}
}

func (s *TinyIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitTinyIntLiteral(s)
	}
}

type LegacyDecimalLiteralContext struct {
	NumberContext
}

func NewLegacyDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyDecimalLiteralContext {
	var p = new(LegacyDecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *LegacyDecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyDecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserEXPONENT_VALUE, 0)
}

func (s *LegacyDecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserDECIMAL_VALUE, 0)
}

func (s *LegacyDecimalLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *LegacyDecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterLegacyDecimalLiteral(s)
	}
}

func (s *LegacyDecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitLegacyDecimalLiteral(s)
	}
}

type BigDecimalLiteralContext struct {
	NumberContext
}

func NewBigDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BigDecimalLiteralContext {
	var p = new(BigDecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *BigDecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigDecimalLiteralContext) BIGDECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserBIGDECIMAL_VALUE, 0)
}

func (s *BigDecimalLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *BigDecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBigDecimalLiteral(s)
	}
}

func (s *BigDecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBigDecimalLiteral(s)
	}
}

type ExponentLiteralContext struct {
	NumberContext
}

func NewExponentLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExponentLiteralContext {
	var p = new(ExponentLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *ExponentLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExponentLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserEXPONENT_VALUE, 0)
}

func (s *ExponentLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *ExponentLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterExponentLiteral(s)
	}
}

func (s *ExponentLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitExponentLiteral(s)
	}
}

type DoubleLiteralContext struct {
	NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

type FloatLiteralContext struct {
	NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOAT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserFLOAT_VALUE, 0)
}

func (s *FloatLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type SmallIntLiteralContext struct {
	NumberContext
}

func NewSmallIntLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SmallIntLiteralContext {
	var p = new(SmallIntLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *SmallIntLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SmallIntLiteralContext) SMALLINT_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserSMALLINT_VALUE, 0)
}

func (s *SmallIntLiteralContext) K_MINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserK_MINUS, 0)
}

func (s *SmallIntLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterSmallIntLiteral(s)
	}
}

func (s *SmallIntLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitSmallIntLiteral(s)
	}
}

func (p *UniversalParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, UniversalParserRULE_number)
	var _la int

	p.SetState(2194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExponentLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2154)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2157)
			p.Match(UniversalParserEXPONENT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2158)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2161)
			p.Match(UniversalParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLegacyDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2162)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2165)
			_la = p.GetTokenStream().LA(1)

			if !(_la == UniversalParserEXPONENT_VALUE || _la == UniversalParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2166)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2169)
			p.Match(UniversalParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewBigIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2170)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2173)
			p.Match(UniversalParserBIGINT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewSmallIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2174)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2177)
			p.Match(UniversalParserSMALLINT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewTinyIntLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2178)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2181)
			p.Match(UniversalParserTINYINT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2182)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2185)
			p.Match(UniversalParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2186)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2189)
			p.Match(UniversalParserFLOAT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewBigDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		p.SetState(2191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == UniversalParserK_MINUS {
			{
				p.SetState(2190)
				p.Match(UniversalParserK_MINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2193)
			p.Match(UniversalParserBIGDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_STRING() antlr.TerminalNode
	DOUBLE_QUOTED_STRING() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) SINGLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserSINGLE_QUOTED_STRING, 0)
}

func (s *StringContext) DOUBLE_QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserDOUBLE_QUOTED_STRING, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitString(s)
	}
}

func (p *UniversalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, UniversalParserRULE_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserSINGLE_QUOTED_STRING || _la == UniversalParserDOUBLE_QUOTED_STRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanContext is an interface to support dynamic dispatch.
type IBooleanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUE() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode

	// IsBooleanContext differentiates from other interfaces.
	IsBooleanContext()
}

type BooleanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanContext() *BooleanContext {
	var p = new(BooleanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_boolean
	return p
}

func InitEmptyBooleanContext(p *BooleanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_boolean
}

func (*BooleanContext) IsBooleanContext() {}

func NewBooleanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanContext {
	var p = new(BooleanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_boolean

	return p
}

func (s *BooleanContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRUE, 0)
}

func (s *BooleanContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FALSE, 0)
}

func (s *BooleanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterBoolean(s)
	}
}

func (s *BooleanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitBoolean(s)
	}
}

func (p *UniversalParser) Boolean() (localctx IBooleanContext) {
	localctx = NewBooleanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, UniversalParserRULE_boolean)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2198)
		_la = p.GetTokenStream().LA(1)

		if !(_la == UniversalParserT_FALSE || _la == UniversalParserT_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullContext is an interface to support dynamic dispatch.
type INullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNullContext differentiates from other interfaces.
	IsNullContext()
}

type NullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullContext() *NullContext {
	var p = new(NullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_null
	return p
}

func InitEmptyNullContext(p *NullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_null
}

func (*NullContext) IsNullContext() {}

func NewNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullContext {
	var p = new(NullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_null

	return p
}

func (s *NullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULL, 0)
}

func (s *NullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNull(s)
	}
}

func (s *NullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNull(s)
	}
}

func (p *UniversalParser) Null() (localctx INullContext) {
	localctx = NewNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, UniversalParserRULE_null)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2200)
		p.Match(UniversalParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	String_() IStringContext

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_version
	return p
}

func InitEmptyVersionContext(p *VersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_version
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserINTEGER_VALUE, 0)
}

func (s *VersionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (p *UniversalParser) Version() (localctx IVersionContext) {
	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, UniversalParserRULE_version)
	p.SetState(2204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case UniversalParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2202)
			p.Match(UniversalParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case UniversalParserSINGLE_QUOTED_STRING, UniversalParserDOUBLE_QUOTED_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2203)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoReservedKeywordsContext is an interface to support dynamic dispatch.
type INoReservedKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ADD() antlr.TerminalNode
	T_AFTER() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_ALWAYS() antlr.TerminalNode
	T_ANALYZE() antlr.TerminalNode
	T_ANY() antlr.TerminalNode
	T_ANY_VALUE() antlr.TerminalNode
	T_ARCHIVE() antlr.TerminalNode
	T_ARRAY() antlr.TerminalNode
	T_ASC() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	T_AUTHORIZATION() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_BOTH() antlr.TerminalNode
	T_BUCKET() antlr.TerminalNode
	T_BUCKETS() antlr.TerminalNode
	T_CACHE() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode
	T_CASE() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_CATALOG() antlr.TerminalNode
	T_CATALOGS() antlr.TerminalNode
	T_CHANGE() antlr.TerminalNode
	T_CHECK() antlr.TerminalNode
	T_CLEAR() antlr.TerminalNode
	T_CLUSTER() antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	T_CODEGEN() antlr.TerminalNode
	T_COLLATE() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_COLUMN() antlr.TerminalNode
	T_COLUMNS() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_COMPACT() antlr.TerminalNode
	T_COMPACTIONS() antlr.TerminalNode
	T_COMPUTE() antlr.TerminalNode
	T_CONCATENATE() antlr.TerminalNode
	T_CONSTRAINT() antlr.TerminalNode
	T_COST() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_CUBE() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT_TIME() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_DAYOFYEAR() antlr.TerminalNode
	T_DATA() antlr.TerminalNode
	T_DATABASE() antlr.TerminalNode
	T_DATABASES() antlr.TerminalNode
	T_DATEADD() antlr.TerminalNode
	T_DATEDIFF() antlr.TerminalNode
	T_DBPROPERTIES() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_DESCRIBE() antlr.TerminalNode
	T_DFS() antlr.TerminalNode
	T_DIRECTORIES() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_DIV() antlr.TerminalNode
	T_DROP() antlr.TerminalNode
	T_ELSE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	T_ESCAPE() antlr.TerminalNode
	T_ESCAPED() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_EXCHANGE() antlr.TerminalNode
	T_EXCLUDE() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_EXPLAIN() antlr.TerminalNode
	T_EXPORT() antlr.TerminalNode
	T_EXTENDED() antlr.TerminalNode
	T_EXTERNAL() antlr.TerminalNode
	T_EXTRACT() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode
	T_FETCH() antlr.TerminalNode
	T_FIELDS() antlr.TerminalNode
	T_FILTER() antlr.TerminalNode
	T_FILEFORMAT() antlr.TerminalNode
	T_FIRST() antlr.TerminalNode
	T_FOLLOWING() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_FORMATTED() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	T_FUNCTIONS() antlr.TerminalNode
	T_GENERATED() antlr.TerminalNode
	T_GLOBAL() antlr.TerminalNode
	T_GRANT() antlr.TerminalNode
	T_GROUP() antlr.TerminalNode
	T_GROUPING() antlr.TerminalNode
	T_HOUR() antlr.TerminalNode
	T_HOURS() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_IMPORT() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	T_INCLUDE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_INDEXES() antlr.TerminalNode
	T_INPATH() antlr.TerminalNode
	T_INPUTFORMAT() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode
	T_INTERVAL() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LAST() antlr.TerminalNode
	T_LATERAL() antlr.TerminalNode
	T_LAZY() antlr.TerminalNode
	T_LEADING() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_ILIKE() antlr.TerminalNode
	T_LIMIT() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_LIST() antlr.TerminalNode
	T_LOAD() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	T_LOCATION() antlr.TerminalNode
	T_LOCK() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_LOGICAL() antlr.TerminalNode
	T_MACRO() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_MERGE() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_MILLISECOND() antlr.TerminalNode
	T_MILLISECONDS() antlr.TerminalNode
	T_MINUTE() antlr.TerminalNode
	T_MINUTES() antlr.TerminalNode
	T_MONTH() antlr.TerminalNode
	T_MONTHS() antlr.TerminalNode
	T_MSCK() antlr.TerminalNode
	T_NAMESPACE() antlr.TerminalNode
	T_NAMESPACES() antlr.TerminalNode
	T_NANOSECOND() antlr.TerminalNode
	T_NANOSECONDS() antlr.TerminalNode
	T_NATURAL() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_NULLS() antlr.TerminalNode
	T_OF() antlr.TerminalNode
	T_OFFSET() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_OPTION() antlr.TerminalNode
	T_OPTIONS() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_OUTPUTFORMAT() antlr.TerminalNode
	T_OVERLAPS() antlr.TerminalNode
	T_OVERLAY() antlr.TerminalNode
	T_PARTITIONED() antlr.TerminalNode
	T_PARTITIONS() antlr.TerminalNode
	T_PERCENTILE_CONT() antlr.TerminalNode
	T_PERCENTILE_DISC() antlr.TerminalNode
	T_PERCENTLIT() antlr.TerminalNode
	T_PIVOT() antlr.TerminalNode
	T_PLACING() antlr.TerminalNode
	T_POSITION() antlr.TerminalNode
	T_PRECEDING() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_PRINCIPALS() antlr.TerminalNode
	T_PROPERTIES() antlr.TerminalNode
	T_PURGE() antlr.TerminalNode
	T_QUARTER() antlr.TerminalNode
	T_QUERY() antlr.TerminalNode
	T_RANGE() antlr.TerminalNode
	T_RECORDREADER() antlr.TerminalNode
	T_RECORDWRITER() antlr.TerminalNode
	T_RECOVER() antlr.TerminalNode
	T_REDUCE() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	T_REFRESH() antlr.TerminalNode
	T_RENAME() antlr.TerminalNode
	T_REPAIR() antlr.TerminalNode
	T_REPEATABLE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_RESET() antlr.TerminalNode
	T_RESPECT() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_REVOKE() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	T_ROLES() antlr.TerminalNode
	T_ROLLBACK() antlr.TerminalNode
	T_ROLLUP() antlr.TerminalNode
	T_ROW() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_SCHEMAS() antlr.TerminalNode
	T_SEPARATED() antlr.TerminalNode
	T_SERDE() antlr.TerminalNode
	T_SERDEPROPERTIES() antlr.TerminalNode
	T_SESSION_USER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_SETMINUS() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	T_SHOW() antlr.TerminalNode
	T_SKEWED() antlr.TerminalNode
	T_SOME() antlr.TerminalNode
	T_SORT() antlr.TerminalNode
	T_SORTED() antlr.TerminalNode
	T_SOURCE() antlr.TerminalNode
	T_START() antlr.TerminalNode
	T_STATISTICS() antlr.TerminalNode
	T_STORED() antlr.TerminalNode
	T_STRATIFY() antlr.TerminalNode
	T_STRUCT() antlr.TerminalNode
	T_SUBSTR() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_SYNC() antlr.TerminalNode
	T_SYSTEM_TIME() antlr.TerminalNode
	T_SYSTEM_VERSION() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_TABLES() antlr.TerminalNode
	T_TABLESAMPLE() antlr.TerminalNode
	T_TARGET() antlr.TerminalNode
	T_TBLPROPERTIES() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_TIME() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TIMESTAMPADD() antlr.TerminalNode
	T_TIMESTAMPDIFF() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_TOUCH() antlr.TerminalNode
	T_TRAILING() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_TRANSACTIONS() antlr.TerminalNode
	T_TRANSFORM() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_TRUE() antlr.TerminalNode
	T_TRUNCATE() antlr.TerminalNode
	T_TRY_CAST() antlr.TerminalNode
	T_TYPE() antlr.TerminalNode
	T_UNARCHIVE() antlr.TerminalNode
	T_UNBOUNDED() antlr.TerminalNode
	T_UNCACHE() antlr.TerminalNode
	T_UNION() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_UNKNOWN() antlr.TerminalNode
	T_UNLOCK() antlr.TerminalNode
	T_UNPIVOT() antlr.TerminalNode
	T_UNSET() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_USING() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	T_VERSION() antlr.TerminalNode
	T_VIEW() antlr.TerminalNode
	T_VIEWS() antlr.TerminalNode
	T_WEEK() antlr.TerminalNode
	T_WEEKS() antlr.TerminalNode
	T_WHEN() antlr.TerminalNode
	T_WINDOW() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_WITHIN() antlr.TerminalNode
	T_YEAR() antlr.TerminalNode
	T_YEARS() antlr.TerminalNode
	T_ZONE() antlr.TerminalNode
	T_ACTION() antlr.TerminalNode
	T_ADD2() antlr.TerminalNode
	T_ALLOCATE() antlr.TerminalNode
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_ASSOCIATE() antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_AVG() antlr.TerminalNode
	T_BATCHSIZE() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BINARY_INTEGER() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	T_BREAK() antlr.TerminalNode
	T_BULK() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode
	T_CALL() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CASESPECIFIC() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode
	T_CLOSE() antlr.TerminalNode
	T_CMP() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode
	T_CONSTANT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_CONCAT() antlr.TerminalNode
	T_CONDITION() antlr.TerminalNode
	T_CONTINUE() antlr.TerminalNode
	T_COPY() antlr.TerminalNode
	T_COUNT() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DECLARE() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_DELIMITER() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	T_DIR() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode
	T_ELSEIF() antlr.TerminalNode
	T_ELSIF() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_EXCEPTION() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_FILE() antlr.TerminalNode
	T_FILES() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_GET() antlr.TerminalNode
	T_GO() antlr.TerminalNode
	T_HANDLER() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	T_HIVE() antlr.TerminalNode
	T_HOST() antlr.TerminalNode
	T_IDENTITY() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_ISOPEN() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_LANGUAGE() antlr.TerminalNode
	T_LEAVE() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_LOG() antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_LOOP() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NEW() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_NONE() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	T_OFF() antlr.TerminalNode
	T_OPEN() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_PLS_INTEGER() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	T_PRINT() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_QUALIFY() antlr.TerminalNode
	T_QUERY_BAND() antlr.TerminalNode
	T_QUIT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_RAISE() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_RESIGNAL() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_ROWTYPE() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_PWD() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_SEGMENT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	T_SESSIONS() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode
	T_SIGNAL() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SIMPLE_INTEGER() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	T_STEP() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SUBDIR() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_SUMMARY() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TABLESPACE() antlr.TerminalNode
	T_TEXTIMAGE_ON() antlr.TerminalNode
	T_TINYINT() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	T_TOP() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_VALUE() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	T_WHILE() antlr.TerminalNode
	T_WITHOUT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_YES() antlr.TerminalNode
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_MAX_PART_STRING() antlr.TerminalNode
	T_MIN_PART_STRING() antlr.TerminalNode
	T_MAX_PART_INT() antlr.TerminalNode
	T_MIN_PART_INT() antlr.TerminalNode
	T_MAX_PART_DATE() antlr.TerminalNode
	T_MIN_PART_DATE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode
	T_ABS() antlr.TerminalNode
	T_ACOS() antlr.TerminalNode
	T_ADD_MONTHS() antlr.TerminalNode
	T_ALL_MATCH() antlr.TerminalNode
	T_ANY_MATCH() antlr.TerminalNode
	T_ATAN2() antlr.TerminalNode
	T_APPROX_DISTINCT() antlr.TerminalNode
	T_ARG_MAX() antlr.TerminalNode
	T_ARG_MIN() antlr.TerminalNode
	T_ARRAY_CONTAINS() antlr.TerminalNode
	T_ARRAY_DISTINCT() antlr.TerminalNode
	T_ARRAY_EXCEPT() antlr.TerminalNode
	T_ARRAY_INTERSECT() antlr.TerminalNode
	T_ARRAY_JOIN() antlr.TerminalNode
	T_ARRAY_MAX() antlr.TerminalNode
	T_ARRAY_MIN() antlr.TerminalNode
	T_ARRAY_NORMALIZE() antlr.TerminalNode
	T_ARRAY_POSITION() antlr.TerminalNode
	T_ARRAY_REDUCE() antlr.TerminalNode
	T_ARRAY_REMOVE() antlr.TerminalNode
	T_ARRAY_REPEAT() antlr.TerminalNode
	T_ARRAY_SORT() antlr.TerminalNode
	T_ARRAY_UNION() antlr.TerminalNode
	T_ARRAYS_OVERLAP() antlr.TerminalNode
	T_ARRAYS_ZIP() antlr.TerminalNode
	T_ASCII() antlr.TerminalNode
	T_ASIN() antlr.TerminalNode
	T_ATAN() antlr.TerminalNode
	T_BASE64() antlr.TerminalNode
	T_BIN() antlr.TerminalNode
	T_BITWISE_AND_AGG() antlr.TerminalNode
	T_BITWISE_OR_AGG() antlr.TerminalNode
	T_CBRT() antlr.TerminalNode
	T_CEIL() antlr.TerminalNode
	T_CHAR_MATCHCOUNT() antlr.TerminalNode
	T_CHR() antlr.TerminalNode
	T_CLUSTER_SAMPLE() antlr.TerminalNode
	T_COALESCE() antlr.TerminalNode
	T_COLLECT_LIST() antlr.TerminalNode
	T_COLLECT_SET() antlr.TerminalNode
	T_COMBINATIONS() antlr.TerminalNode
	T_CONCAT_WS() antlr.TerminalNode
	T_CONV() antlr.TerminalNode
	T_CORR() antlr.TerminalNode
	T_COS() antlr.TerminalNode
	T_COSH() antlr.TerminalNode
	T_COT() antlr.TerminalNode
	T_COUNT_IF() antlr.TerminalNode
	T_COVAR_POP() antlr.TerminalNode
	T_COVAR_SAMP() antlr.TerminalNode
	T_CRC32() antlr.TerminalNode
	T_CURRENT_TIMEZONE() antlr.TerminalNode
	T_DATE_ADD() antlr.TerminalNode
	T_DATE_FORMAT() antlr.TerminalNode
	T_DATE_SUB() antlr.TerminalNode
	T_DATEPART() antlr.TerminalNode
	T_DATETRUNC() antlr.TerminalNode
	T_DAYOFMONTH() antlr.TerminalNode
	T_DAYOFWEEK() antlr.TerminalNode
	T_DECODE() antlr.TerminalNode
	T_DECOMPRESS() antlr.TerminalNode
	T_DEGREES() antlr.TerminalNode
	T_E() antlr.TerminalNode
	T_ENCODE() antlr.TerminalNode
	T_EXP() antlr.TerminalNode
	T_EXPLODE() antlr.TerminalNode
	T_FACTORIAL() antlr.TerminalNode
	T_FIELD() antlr.TerminalNode
	T_FIND_IN_SET() antlr.TerminalNode
	T_FLATTEN() antlr.TerminalNode
	T_FLOOR() antlr.TerminalNode
	T_FORMAT_NUMBER() antlr.TerminalNode
	T_FROM_JSON() antlr.TerminalNode
	T_FROM_UNIXTIME() antlr.TerminalNode
	T_FROM_UTC_TIMESTAMP() antlr.TerminalNode
	T_GET_IDCARD_AGE() antlr.TerminalNode
	T_GET_IDCARD_BIRTHDAY() antlr.TerminalNode
	T_GET_IDCARD_SEX() antlr.TerminalNode
	T_GET_JSON_OBJECT() antlr.TerminalNode
	T_GET_USER_ID() antlr.TerminalNode
	T_GETDATE() antlr.TerminalNode
	T_GREATEST() antlr.TerminalNode
	T_HEX() antlr.TerminalNode
	T_HISTOGRAM() antlr.TerminalNode
	T_INLINE() antlr.TerminalNode
	T_INITCAP() antlr.TerminalNode
	T_INSTR() antlr.TerminalNode
	T_IS_ENCODING() antlr.TerminalNode
	T_ISDATE() antlr.TerminalNode
	T_ISNAN() antlr.TerminalNode
	T_JSON_OBJECT() antlr.TerminalNode
	T_JSON_ARRAY() antlr.TerminalNode
	T_JSON_EXTRACT() antlr.TerminalNode
	T_JSON_EXISTS() antlr.TerminalNode
	T_JSON_PRETTY() antlr.TerminalNode
	T_JSON_TYPE() antlr.TerminalNode
	T_JSON_FORMAT() antlr.TerminalNode
	T_JSON_PARSE() antlr.TerminalNode
	T_JSON_VALID() antlr.TerminalNode
	T_JSON_TUPLE() antlr.TerminalNode
	T_KEYVALUE() antlr.TerminalNode
	T_KEYVALUE_TUPLE() antlr.TerminalNode
	T_LAST_DAY() antlr.TerminalNode
	T_LASTDAY() antlr.TerminalNode
	T_LEAST() antlr.TerminalNode
	T_LENGTH() antlr.TerminalNode
	T_LENGTHB() antlr.TerminalNode
	T_LN() antlr.TerminalNode
	T_LOCATE() antlr.TerminalNode
	T_LOG10() antlr.TerminalNode
	T_LOG2() antlr.TerminalNode
	T_LPAD() antlr.TerminalNode
	T_LTRIM() antlr.TerminalNode
	T_MAP_AGG() antlr.TerminalNode
	T_MAP_CONCAT() antlr.TerminalNode
	T_MAP_ENTRIES() antlr.TerminalNode
	T_MAP_FILTER() antlr.TerminalNode
	T_MAP_FROM_ARRAYS() antlr.TerminalNode
	T_MAP_FROM_ENTRIES() antlr.TerminalNode
	T_MAP_KEYS() antlr.TerminalNode
	T_MAP_UNION() antlr.TerminalNode
	T_MAP_UNION_SUM() antlr.TerminalNode
	T_MAP_VALUES() antlr.TerminalNode
	T_MAP_ZIP_WITH() antlr.TerminalNode
	T_MASK_HASH() antlr.TerminalNode
	T_MAX_BY() antlr.TerminalNode
	T_MAX_PT() antlr.TerminalNode
	T_MD5() antlr.TerminalNode
	T_MEDIAN() antlr.TerminalNode
	T_MIN_BY() antlr.TerminalNode
	T_MONTHS_BETWEEN() antlr.TerminalNode
	T_MULTIMAP_AGG() antlr.TerminalNode
	T_MULTIMAP_FROM_ENTRIES() antlr.TerminalNode
	T_NAMED_STRUCT() antlr.TerminalNode
	T_NEGATIVE() antlr.TerminalNode
	T_NEXT_DAY() antlr.TerminalNode
	T_NGRAMS() antlr.TerminalNode
	T_NOW() antlr.TerminalNode
	T_NTILE() antlr.TerminalNode
	T_NTH_VALUE() antlr.TerminalNode
	T_NULLIF() antlr.TerminalNode
	T_NUMERIC_HISTOGRAM() antlr.TerminalNode
	T_NVL() antlr.TerminalNode
	T_ORDINAL() antlr.TerminalNode
	T_PARSE_URL() antlr.TerminalNode
	T_PARSE_URL_TUPLE() antlr.TerminalNode
	T_PARTITION_EXISTS() antlr.TerminalNode
	T_PERCENT_RANK() antlr.TerminalNode
	T_PERCENTILE() antlr.TerminalNode
	T_PERCENTILE_APPROX() antlr.TerminalNode
	T_PI() antlr.TerminalNode
	T_POSEXPLODE() antlr.TerminalNode
	T_POSITIVE() antlr.TerminalNode
	T_POW() antlr.TerminalNode
	T_RADIANS() antlr.TerminalNode
	T_RAND() antlr.TerminalNode
	T_REGEXP_COUNT() antlr.TerminalNode
	T_REGEXP_EXTRACT() antlr.TerminalNode
	T_REGEXP_EXTRACT_ALL() antlr.TerminalNode
	T_REGEXP_INSTR() antlr.TerminalNode
	T_REGEXP_REPLACE() antlr.TerminalNode
	T_REGEXP_SUBSTR() antlr.TerminalNode
	T_REPEAT() antlr.TerminalNode
	T_ROUND() antlr.TerminalNode
	T_RPAD() antlr.TerminalNode
	T_RTRIM() antlr.TerminalNode
	T_SAMPLE() antlr.TerminalNode
	T_SEQUENCE() antlr.TerminalNode
	T_SHA() antlr.TerminalNode
	T_SHA1() antlr.TerminalNode
	T_SHA2() antlr.TerminalNode
	T_SHIFTLEFT() antlr.TerminalNode
	T_SHIFTRIGHT() antlr.TerminalNode
	T_SHIFTRIGHTUNSIGNED() antlr.TerminalNode
	T_SHUFFLE() antlr.TerminalNode
	T_SIGN() antlr.TerminalNode
	T_SIN() antlr.TerminalNode
	T_SINH() antlr.TerminalNode
	T_SIZE() antlr.TerminalNode
	T_SLICE() antlr.TerminalNode
	T_SORT_ARRAY() antlr.TerminalNode
	T_SOUNDEX() antlr.TerminalNode
	T_SPACE() antlr.TerminalNode
	T_SPLIT() antlr.TerminalNode
	T_SPLIT_PART() antlr.TerminalNode
	T_SQRT() antlr.TerminalNode
	T_STACK() antlr.TerminalNode
	T_STDDEV() antlr.TerminalNode
	T_STDDEV_SAMP() antlr.TerminalNode
	T_STR_TO_MAP() antlr.TerminalNode
	T_SUBSTRING_INDEX() antlr.TerminalNode
	T_SYM_DECRYPT() antlr.TerminalNode
	T_SYM_ENCRYPT() antlr.TerminalNode
	T_TABLE_EXISTS() antlr.TerminalNode
	T_TAN() antlr.TerminalNode
	T_TANH() antlr.TerminalNode
	T_TO_CHAR() antlr.TerminalNode
	T_TO_DATE() antlr.TerminalNode
	T_TO_JSON() antlr.TerminalNode
	T_TO_MILLIS() antlr.TerminalNode
	T_TOLOWER() antlr.TerminalNode
	T_TOUPPER() antlr.TerminalNode
	T_TRANS_ARRAY() antlr.TerminalNode
	T_TRANS_COLS() antlr.TerminalNode
	T_TRANSFORM_KEYS() antlr.TerminalNode
	T_TRANSFORM_VALUES() antlr.TerminalNode
	T_TRANSLATE() antlr.TerminalNode
	T_TRUNC() antlr.TerminalNode
	T_UNBASE64() antlr.TerminalNode
	T_UNHEX() antlr.TerminalNode
	T_UNIQUE_ID() antlr.TerminalNode
	T_UNIX_TIMESTAMP() antlr.TerminalNode
	T_URL_DECODE() antlr.TerminalNode
	T_URL_ENCODE() antlr.TerminalNode
	T_UUID() antlr.TerminalNode
	T_VAR_SAMP() antlr.TerminalNode
	T_VAR_POP() antlr.TerminalNode
	T_WEEKDAY() antlr.TerminalNode
	T_WEEKOFYEAR() antlr.TerminalNode
	T_WIDTH_BUCKET() antlr.TerminalNode
	T_WM_CONCAT() antlr.TerminalNode
	T_ZIP_WITH() antlr.TerminalNode

	// IsNoReservedKeywordsContext differentiates from other interfaces.
	IsNoReservedKeywordsContext()
}

type NoReservedKeywordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoReservedKeywordsContext() *NoReservedKeywordsContext {
	var p = new(NoReservedKeywordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_noReservedKeywords
	return p
}

func InitEmptyNoReservedKeywordsContext(p *NoReservedKeywordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = UniversalParserRULE_noReservedKeywords
}

func (*NoReservedKeywordsContext) IsNoReservedKeywordsContext() {}

func NewNoReservedKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoReservedKeywordsContext {
	var p = new(NoReservedKeywordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = UniversalParserRULE_noReservedKeywords

	return p
}

func (s *NoReservedKeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *NoReservedKeywordsContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ADD, 0)
}

func (s *NoReservedKeywordsContext) T_AFTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AFTER, 0)
}

func (s *NoReservedKeywordsContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALL, 0)
}

func (s *NoReservedKeywordsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALTER, 0)
}

func (s *NoReservedKeywordsContext) T_ALWAYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALWAYS, 0)
}

func (s *NoReservedKeywordsContext) T_ANALYZE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANALYZE, 0)
}

func (s *NoReservedKeywordsContext) T_ANY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANY, 0)
}

func (s *NoReservedKeywordsContext) T_ANY_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANY_VALUE, 0)
}

func (s *NoReservedKeywordsContext) T_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARCHIVE, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY, 0)
}

func (s *NoReservedKeywordsContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ASC, 0)
}

func (s *NoReservedKeywordsContext) T_AT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AT, 0)
}

func (s *NoReservedKeywordsContext) T_AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AUTHORIZATION, 0)
}

func (s *NoReservedKeywordsContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BETWEEN, 0)
}

func (s *NoReservedKeywordsContext) T_BOTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BOTH, 0)
}

func (s *NoReservedKeywordsContext) T_BUCKET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BUCKET, 0)
}

func (s *NoReservedKeywordsContext) T_BUCKETS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BUCKETS, 0)
}

func (s *NoReservedKeywordsContext) T_CACHE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CACHE, 0)
}

func (s *NoReservedKeywordsContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CASCADE, 0)
}

func (s *NoReservedKeywordsContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CASE, 0)
}

func (s *NoReservedKeywordsContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CAST, 0)
}

func (s *NoReservedKeywordsContext) T_CATALOG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CATALOG, 0)
}

func (s *NoReservedKeywordsContext) T_CATALOGS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CATALOGS, 0)
}

func (s *NoReservedKeywordsContext) T_CHANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHANGE, 0)
}

func (s *NoReservedKeywordsContext) T_CHECK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHECK, 0)
}

func (s *NoReservedKeywordsContext) T_CLEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLEAR, 0)
}

func (s *NoReservedKeywordsContext) T_CLUSTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLUSTER, 0)
}

func (s *NoReservedKeywordsContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLUSTERED, 0)
}

func (s *NoReservedKeywordsContext) T_CODEGEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CODEGEN, 0)
}

func (s *NoReservedKeywordsContext) T_COLLATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLATE, 0)
}

func (s *NoReservedKeywordsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLECTION, 0)
}

func (s *NoReservedKeywordsContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLUMN, 0)
}

func (s *NoReservedKeywordsContext) T_COLUMNS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLUMNS, 0)
}

func (s *NoReservedKeywordsContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMMENT, 0)
}

func (s *NoReservedKeywordsContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMMIT, 0)
}

func (s *NoReservedKeywordsContext) T_COMPACT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMPACT, 0)
}

func (s *NoReservedKeywordsContext) T_COMPACTIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMPACTIONS, 0)
}

func (s *NoReservedKeywordsContext) T_COMPUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMPUTE, 0)
}

func (s *NoReservedKeywordsContext) T_CONCATENATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONCATENATE, 0)
}

func (s *NoReservedKeywordsContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONSTRAINT, 0)
}

func (s *NoReservedKeywordsContext) T_COST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COST, 0)
}

func (s *NoReservedKeywordsContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATE, 0)
}

func (s *NoReservedKeywordsContext) T_CUBE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CUBE, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_DATE, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_TIME, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_TIMESTAMP, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_USER, 0)
}

func (s *NoReservedKeywordsContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAY, 0)
}

func (s *NoReservedKeywordsContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAYS, 0)
}

func (s *NoReservedKeywordsContext) T_DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAYOFYEAR, 0)
}

func (s *NoReservedKeywordsContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATA, 0)
}

func (s *NoReservedKeywordsContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATABASE, 0)
}

func (s *NoReservedKeywordsContext) T_DATABASES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATABASES, 0)
}

func (s *NoReservedKeywordsContext) T_DATEADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATEADD, 0)
}

func (s *NoReservedKeywordsContext) T_DATEDIFF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATEDIFF, 0)
}

func (s *NoReservedKeywordsContext) T_DBPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DBPROPERTIES, 0)
}

func (s *NoReservedKeywordsContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFAULT, 0)
}

func (s *NoReservedKeywordsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFINED, 0)
}

func (s *NoReservedKeywordsContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DELETE, 0)
}

func (s *NoReservedKeywordsContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DELIMITED, 0)
}

func (s *NoReservedKeywordsContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DESC, 0)
}

func (s *NoReservedKeywordsContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DESCRIBE, 0)
}

func (s *NoReservedKeywordsContext) T_DFS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DFS, 0)
}

func (s *NoReservedKeywordsContext) T_DIRECTORIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIRECTORIES, 0)
}

func (s *NoReservedKeywordsContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIRECTORY, 0)
}

func (s *NoReservedKeywordsContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISTINCT, 0)
}

func (s *NoReservedKeywordsContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DISTRIBUTE, 0)
}

func (s *NoReservedKeywordsContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIV, 0)
}

func (s *NoReservedKeywordsContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DROP, 0)
}

func (s *NoReservedKeywordsContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ELSE, 0)
}

func (s *NoReservedKeywordsContext) T_END() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_END, 0)
}

func (s *NoReservedKeywordsContext) T_ESCAPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ESCAPE, 0)
}

func (s *NoReservedKeywordsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ESCAPED, 0)
}

func (s *NoReservedKeywordsContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCEPT, 0)
}

func (s *NoReservedKeywordsContext) T_EXCHANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCHANGE, 0)
}

func (s *NoReservedKeywordsContext) T_EXCLUDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCLUDE, 0)
}

func (s *NoReservedKeywordsContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXISTS, 0)
}

func (s *NoReservedKeywordsContext) T_EXPLAIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXPLAIN, 0)
}

func (s *NoReservedKeywordsContext) T_EXPORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXPORT, 0)
}

func (s *NoReservedKeywordsContext) T_EXTENDED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTENDED, 0)
}

func (s *NoReservedKeywordsContext) T_EXTERNAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTERNAL, 0)
}

func (s *NoReservedKeywordsContext) T_EXTRACT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXTRACT, 0)
}

func (s *NoReservedKeywordsContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FALSE, 0)
}

func (s *NoReservedKeywordsContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FETCH, 0)
}

func (s *NoReservedKeywordsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIELDS, 0)
}

func (s *NoReservedKeywordsContext) T_FILTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FILTER, 0)
}

func (s *NoReservedKeywordsContext) T_FILEFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FILEFORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_FIRST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIRST, 0)
}

func (s *NoReservedKeywordsContext) T_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOLLOWING, 0)
}

func (s *NoReservedKeywordsContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOR, 0)
}

func (s *NoReservedKeywordsContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOREIGN, 0)
}

func (s *NoReservedKeywordsContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_FORMATTED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FORMATTED, 0)
}

func (s *NoReservedKeywordsContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FULL, 0)
}

func (s *NoReservedKeywordsContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FUNCTION, 0)
}

func (s *NoReservedKeywordsContext) T_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FUNCTIONS, 0)
}

func (s *NoReservedKeywordsContext) T_GENERATED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GENERATED, 0)
}

func (s *NoReservedKeywordsContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GLOBAL, 0)
}

func (s *NoReservedKeywordsContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GRANT, 0)
}

func (s *NoReservedKeywordsContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUP, 0)
}

func (s *NoReservedKeywordsContext) T_GROUPING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GROUPING, 0)
}

func (s *NoReservedKeywordsContext) T_HOUR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOUR, 0)
}

func (s *NoReservedKeywordsContext) T_HOURS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOURS, 0)
}

func (s *NoReservedKeywordsContext) T_IF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IF, 0)
}

func (s *NoReservedKeywordsContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IGNORE, 0)
}

func (s *NoReservedKeywordsContext) T_IMPORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IMPORT, 0)
}

func (s *NoReservedKeywordsContext) T_IN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IN, 0)
}

func (s *NoReservedKeywordsContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INCLUDE, 0)
}

func (s *NoReservedKeywordsContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INDEX, 0)
}

func (s *NoReservedKeywordsContext) T_INDEXES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INDEXES, 0)
}

func (s *NoReservedKeywordsContext) T_INPATH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INPATH, 0)
}

func (s *NoReservedKeywordsContext) T_INPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INPUTFORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTERSECT, 0)
}

func (s *NoReservedKeywordsContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTERVAL, 0)
}

func (s *NoReservedKeywordsContext) T_IS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IS, 0)
}

func (s *NoReservedKeywordsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ITEMS, 0)
}

func (s *NoReservedKeywordsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEYS, 0)
}

func (s *NoReservedKeywordsContext) T_LAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAST, 0)
}

func (s *NoReservedKeywordsContext) T_LATERAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LATERAL, 0)
}

func (s *NoReservedKeywordsContext) T_LAZY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAZY, 0)
}

func (s *NoReservedKeywordsContext) T_LEADING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEADING, 0)
}

func (s *NoReservedKeywordsContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIKE, 0)
}

func (s *NoReservedKeywordsContext) T_ILIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ILIKE, 0)
}

func (s *NoReservedKeywordsContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIMIT, 0)
}

func (s *NoReservedKeywordsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LINES, 0)
}

func (s *NoReservedKeywordsContext) T_LIST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LIST, 0)
}

func (s *NoReservedKeywordsContext) T_LOAD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOAD, 0)
}

func (s *NoReservedKeywordsContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCAL, 0)
}

func (s *NoReservedKeywordsContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCATION, 0)
}

func (s *NoReservedKeywordsContext) T_LOCK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCK, 0)
}

func (s *NoReservedKeywordsContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCKS, 0)
}

func (s *NoReservedKeywordsContext) T_LOGICAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOGICAL, 0)
}

func (s *NoReservedKeywordsContext) T_MACRO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MACRO, 0)
}

func (s *NoReservedKeywordsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP, 0)
}

func (s *NoReservedKeywordsContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MATCHED, 0)
}

func (s *NoReservedKeywordsContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MERGE, 0)
}

func (s *NoReservedKeywordsContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MICROSECOND, 0)
}

func (s *NoReservedKeywordsContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MICROSECONDS, 0)
}

func (s *NoReservedKeywordsContext) T_MILLISECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MILLISECOND, 0)
}

func (s *NoReservedKeywordsContext) T_MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MILLISECONDS, 0)
}

func (s *NoReservedKeywordsContext) T_MINUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTE, 0)
}

func (s *NoReservedKeywordsContext) T_MINUTES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MINUTES, 0)
}

func (s *NoReservedKeywordsContext) T_MONTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTH, 0)
}

func (s *NoReservedKeywordsContext) T_MONTHS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTHS, 0)
}

func (s *NoReservedKeywordsContext) T_MSCK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MSCK, 0)
}

func (s *NoReservedKeywordsContext) T_NAMESPACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NAMESPACE, 0)
}

func (s *NoReservedKeywordsContext) T_NAMESPACES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NAMESPACES, 0)
}

func (s *NoReservedKeywordsContext) T_NANOSECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NANOSECOND, 0)
}

func (s *NoReservedKeywordsContext) T_NANOSECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NANOSECONDS, 0)
}

func (s *NoReservedKeywordsContext) T_NATURAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NATURAL, 0)
}

func (s *NoReservedKeywordsContext) T_NO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NO, 0)
}

func (s *NoReservedKeywordsContext) T_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLS, 0)
}

func (s *NoReservedKeywordsContext) T_OF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OF, 0)
}

func (s *NoReservedKeywordsContext) T_OFFSET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OFFSET, 0)
}

func (s *NoReservedKeywordsContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ONLY, 0)
}

func (s *NoReservedKeywordsContext) T_OPTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OPTION, 0)
}

func (s *NoReservedKeywordsContext) T_OPTIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OPTIONS, 0)
}

func (s *NoReservedKeywordsContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUT, 0)
}

func (s *NoReservedKeywordsContext) T_OUTPUTFORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OUTPUTFORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OVERLAPS, 0)
}

func (s *NoReservedKeywordsContext) T_OVERLAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OVERLAY, 0)
}

func (s *NoReservedKeywordsContext) T_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITIONED, 0)
}

func (s *NoReservedKeywordsContext) T_PARTITIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITIONS, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENTILE_CONT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE_CONT, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENTILE_DISC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE_DISC, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENTLIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTLIT, 0)
}

func (s *NoReservedKeywordsContext) T_PIVOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PIVOT, 0)
}

func (s *NoReservedKeywordsContext) T_PLACING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PLACING, 0)
}

func (s *NoReservedKeywordsContext) T_POSITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_POSITION, 0)
}

func (s *NoReservedKeywordsContext) T_PRECEDING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRECEDING, 0)
}

func (s *NoReservedKeywordsContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRIMARY, 0)
}

func (s *NoReservedKeywordsContext) T_PRINCIPALS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRINCIPALS, 0)
}

func (s *NoReservedKeywordsContext) T_PROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PROPERTIES, 0)
}

func (s *NoReservedKeywordsContext) T_PURGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PURGE, 0)
}

func (s *NoReservedKeywordsContext) T_QUARTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUARTER, 0)
}

func (s *NoReservedKeywordsContext) T_QUERY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUERY, 0)
}

func (s *NoReservedKeywordsContext) T_RANGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RANGE, 0)
}

func (s *NoReservedKeywordsContext) T_RECORDREADER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RECORDREADER, 0)
}

func (s *NoReservedKeywordsContext) T_RECORDWRITER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RECORDWRITER, 0)
}

func (s *NoReservedKeywordsContext) T_RECOVER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RECOVER, 0)
}

func (s *NoReservedKeywordsContext) T_REDUCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REDUCE, 0)
}

func (s *NoReservedKeywordsContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REFERENCES, 0)
}

func (s *NoReservedKeywordsContext) T_REFRESH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REFRESH, 0)
}

func (s *NoReservedKeywordsContext) T_RENAME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RENAME, 0)
}

func (s *NoReservedKeywordsContext) T_REPAIR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPAIR, 0)
}

func (s *NoReservedKeywordsContext) T_REPEATABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPEATABLE, 0)
}

func (s *NoReservedKeywordsContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPLACE, 0)
}

func (s *NoReservedKeywordsContext) T_RESET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESET, 0)
}

func (s *NoReservedKeywordsContext) T_RESPECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESPECT, 0)
}

func (s *NoReservedKeywordsContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESTRICT, 0)
}

func (s *NoReservedKeywordsContext) T_REVOKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REVOKE, 0)
}

func (s *NoReservedKeywordsContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RLIKE, 0)
}

func (s *NoReservedKeywordsContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLE, 0)
}

func (s *NoReservedKeywordsContext) T_ROLES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLES, 0)
}

func (s *NoReservedKeywordsContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLLBACK, 0)
}

func (s *NoReservedKeywordsContext) T_ROLLUP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROLLUP, 0)
}

func (s *NoReservedKeywordsContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW, 0)
}

func (s *NoReservedKeywordsContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROWS, 0)
}

func (s *NoReservedKeywordsContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECOND, 0)
}

func (s *NoReservedKeywordsContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECONDS, 0)
}

func (s *NoReservedKeywordsContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SCHEMA, 0)
}

func (s *NoReservedKeywordsContext) T_SCHEMAS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SCHEMAS, 0)
}

func (s *NoReservedKeywordsContext) T_SEPARATED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEPARATED, 0)
}

func (s *NoReservedKeywordsContext) T_SERDE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDE, 0)
}

func (s *NoReservedKeywordsContext) T_SERDEPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SERDEPROPERTIES, 0)
}

func (s *NoReservedKeywordsContext) T_SESSION_USER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SESSION_USER, 0)
}

func (s *NoReservedKeywordsContext) T_SET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SET, 0)
}

func (s *NoReservedKeywordsContext) T_SETMINUS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SETMINUS, 0)
}

func (s *NoReservedKeywordsContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SETS, 0)
}

func (s *NoReservedKeywordsContext) T_SHOW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHOW, 0)
}

func (s *NoReservedKeywordsContext) T_SKEWED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SKEWED, 0)
}

func (s *NoReservedKeywordsContext) T_SOME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SOME, 0)
}

func (s *NoReservedKeywordsContext) T_SORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SORT, 0)
}

func (s *NoReservedKeywordsContext) T_SORTED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SORTED, 0)
}

func (s *NoReservedKeywordsContext) T_SOURCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SOURCE, 0)
}

func (s *NoReservedKeywordsContext) T_START() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_START, 0)
}

func (s *NoReservedKeywordsContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STATISTICS, 0)
}

func (s *NoReservedKeywordsContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORED, 0)
}

func (s *NoReservedKeywordsContext) T_STRATIFY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STRATIFY, 0)
}

func (s *NoReservedKeywordsContext) T_STRUCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STRUCT, 0)
}

func (s *NoReservedKeywordsContext) T_SUBSTR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBSTR, 0)
}

func (s *NoReservedKeywordsContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBSTRING, 0)
}

func (s *NoReservedKeywordsContext) T_SYNC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYNC, 0)
}

func (s *NoReservedKeywordsContext) T_SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYSTEM_TIME, 0)
}

func (s *NoReservedKeywordsContext) T_SYSTEM_VERSION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYSTEM_VERSION, 0)
}

func (s *NoReservedKeywordsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE, 0)
}

func (s *NoReservedKeywordsContext) T_TABLES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLES, 0)
}

func (s *NoReservedKeywordsContext) T_TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLESAMPLE, 0)
}

func (s *NoReservedKeywordsContext) T_TARGET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TARGET, 0)
}

func (s *NoReservedKeywordsContext) T_TBLPROPERTIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TBLPROPERTIES, 0)
}

func (s *NoReservedKeywordsContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TEMPORARY, 0)
}

func (s *NoReservedKeywordsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TERMINATED, 0)
}

func (s *NoReservedKeywordsContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_THEN, 0)
}

func (s *NoReservedKeywordsContext) T_TIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TIME, 0)
}

func (s *NoReservedKeywordsContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TIMESTAMP, 0)
}

func (s *NoReservedKeywordsContext) T_TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TIMESTAMPADD, 0)
}

func (s *NoReservedKeywordsContext) T_TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TIMESTAMPDIFF, 0)
}

func (s *NoReservedKeywordsContext) T_TO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO, 0)
}

func (s *NoReservedKeywordsContext) T_TOUCH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TOUCH, 0)
}

func (s *NoReservedKeywordsContext) T_TRAILING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRAILING, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSACTION, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSACTIONS, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSFORM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSFORM, 0)
}

func (s *NoReservedKeywordsContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRIM, 0)
}

func (s *NoReservedKeywordsContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRUE, 0)
}

func (s *NoReservedKeywordsContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRUNCATE, 0)
}

func (s *NoReservedKeywordsContext) T_TRY_CAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRY_CAST, 0)
}

func (s *NoReservedKeywordsContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TYPE, 0)
}

func (s *NoReservedKeywordsContext) T_UNARCHIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNARCHIVE, 0)
}

func (s *NoReservedKeywordsContext) T_UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNBOUNDED, 0)
}

func (s *NoReservedKeywordsContext) T_UNCACHE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNCACHE, 0)
}

func (s *NoReservedKeywordsContext) T_UNION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNION, 0)
}

func (s *NoReservedKeywordsContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNIQUE, 0)
}

func (s *NoReservedKeywordsContext) T_UNKNOWN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNKNOWN, 0)
}

func (s *NoReservedKeywordsContext) T_UNLOCK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNLOCK, 0)
}

func (s *NoReservedKeywordsContext) T_UNPIVOT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNPIVOT, 0)
}

func (s *NoReservedKeywordsContext) T_UNSET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNSET, 0)
}

func (s *NoReservedKeywordsContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UPDATE, 0)
}

func (s *NoReservedKeywordsContext) T_USE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_USE, 0)
}

func (s *NoReservedKeywordsContext) T_USER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_USER, 0)
}

func (s *NoReservedKeywordsContext) T_USING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_USING, 0)
}

func (s *NoReservedKeywordsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VALUES, 0)
}

func (s *NoReservedKeywordsContext) T_VERSION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VERSION, 0)
}

func (s *NoReservedKeywordsContext) T_VIEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEW, 0)
}

func (s *NoReservedKeywordsContext) T_VIEWS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VIEWS, 0)
}

func (s *NoReservedKeywordsContext) T_WEEK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEK, 0)
}

func (s *NoReservedKeywordsContext) T_WEEKS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEKS, 0)
}

func (s *NoReservedKeywordsContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WHEN, 0)
}

func (s *NoReservedKeywordsContext) T_WINDOW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WINDOW, 0)
}

func (s *NoReservedKeywordsContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITH, 0)
}

func (s *NoReservedKeywordsContext) T_WITHIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITHIN, 0)
}

func (s *NoReservedKeywordsContext) T_YEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEAR, 0)
}

func (s *NoReservedKeywordsContext) T_YEARS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YEARS, 0)
}

func (s *NoReservedKeywordsContext) T_ZONE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ZONE, 0)
}

func (s *NoReservedKeywordsContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ACTION, 0)
}

func (s *NoReservedKeywordsContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ADD2, 0)
}

func (s *NoReservedKeywordsContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALLOCATE, 0)
}

func (s *NoReservedKeywordsContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANSI_NULLS, 0)
}

func (s *NoReservedKeywordsContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANSI_PADDING, 0)
}

func (s *NoReservedKeywordsContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ASSOCIATE, 0)
}

func (s *NoReservedKeywordsContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AUTO_INCREMENT, 0)
}

func (s *NoReservedKeywordsContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_AVG, 0)
}

func (s *NoReservedKeywordsContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BATCHSIZE, 0)
}

func (s *NoReservedKeywordsContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BEGIN, 0)
}

func (s *NoReservedKeywordsContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BIGINT, 0)
}

func (s *NoReservedKeywordsContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BINARY_DOUBLE, 0)
}

func (s *NoReservedKeywordsContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BINARY_FLOAT, 0)
}

func (s *NoReservedKeywordsContext) T_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BINARY_INTEGER, 0)
}

func (s *NoReservedKeywordsContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BIT, 0)
}

func (s *NoReservedKeywordsContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BODY, 0)
}

func (s *NoReservedKeywordsContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BREAK, 0)
}

func (s *NoReservedKeywordsContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BULK, 0)
}

func (s *NoReservedKeywordsContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BYTE, 0)
}

func (s *NoReservedKeywordsContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CALL, 0)
}

func (s *NoReservedKeywordsContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CALLER, 0)
}

func (s *NoReservedKeywordsContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CASESPECIFIC, 0)
}

func (s *NoReservedKeywordsContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHAR, 0)
}

func (s *NoReservedKeywordsContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHARACTER, 0)
}

func (s *NoReservedKeywordsContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHARSET, 0)
}

func (s *NoReservedKeywordsContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLIENT, 0)
}

func (s *NoReservedKeywordsContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLOSE, 0)
}

func (s *NoReservedKeywordsContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CMP, 0)
}

func (s *NoReservedKeywordsContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLECT, 0)
}

func (s *NoReservedKeywordsContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONSTANT, 0)
}

func (s *NoReservedKeywordsContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMPRESS, 0)
}

func (s *NoReservedKeywordsContext) T_CONCAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONCAT, 0)
}

func (s *NoReservedKeywordsContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONDITION, 0)
}

func (s *NoReservedKeywordsContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONTINUE, 0)
}

func (s *NoReservedKeywordsContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COPY, 0)
}

func (s *NoReservedKeywordsContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COUNT, 0)
}

func (s *NoReservedKeywordsContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COUNT_BIG, 0)
}

func (s *NoReservedKeywordsContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATION, 0)
}

func (s *NoReservedKeywordsContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CREATOR, 0)
}

func (s *NoReservedKeywordsContext) T_CS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CS, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_SCHEMA, 0)
}

func (s *NoReservedKeywordsContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURSOR, 0)
}

func (s *NoReservedKeywordsContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATE, 0)
}

func (s *NoReservedKeywordsContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATETIME, 0)
}

func (s *NoReservedKeywordsContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEC, 0)
}

func (s *NoReservedKeywordsContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DECIMAL, 0)
}

func (s *NoReservedKeywordsContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DECLARE, 0)
}

func (s *NoReservedKeywordsContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFERRED, 0)
}

func (s *NoReservedKeywordsContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFINER, 0)
}

func (s *NoReservedKeywordsContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEFINITION, 0)
}

func (s *NoReservedKeywordsContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DELIMITER, 0)
}

func (s *NoReservedKeywordsContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIAGNOSTICS, 0)
}

func (s *NoReservedKeywordsContext) T_DIR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DIR, 0)
}

func (s *NoReservedKeywordsContext) T_DO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DO, 0)
}

func (s *NoReservedKeywordsContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DOUBLE, 0)
}

func (s *NoReservedKeywordsContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DYNAMIC, 0)
}

func (s *NoReservedKeywordsContext) T_ELSEIF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ELSEIF, 0)
}

func (s *NoReservedKeywordsContext) T_ELSIF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ELSIF, 0)
}

func (s *NoReservedKeywordsContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ENABLE, 0)
}

func (s *NoReservedKeywordsContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ENGINE, 0)
}

func (s *NoReservedKeywordsContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXEC, 0)
}

func (s *NoReservedKeywordsContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXECUTE, 0)
}

func (s *NoReservedKeywordsContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCEPTION, 0)
}

func (s *NoReservedKeywordsContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXCLUSIVE, 0)
}

func (s *NoReservedKeywordsContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXIT, 0)
}

func (s *NoReservedKeywordsContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FALLBACK, 0)
}

func (s *NoReservedKeywordsContext) T_FILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FILE, 0)
}

func (s *NoReservedKeywordsContext) T_FILES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FILES, 0)
}

func (s *NoReservedKeywordsContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FLOAT, 0)
}

func (s *NoReservedKeywordsContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FOUND, 0)
}

func (s *NoReservedKeywordsContext) T_GET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET, 0)
}

func (s *NoReservedKeywordsContext) T_GO() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GO, 0)
}

func (s *NoReservedKeywordsContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HANDLER, 0)
}

func (s *NoReservedKeywordsContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HASH, 0)
}

func (s *NoReservedKeywordsContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HDFS, 0)
}

func (s *NoReservedKeywordsContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HIVE, 0)
}

func (s *NoReservedKeywordsContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HOST, 0)
}

func (s *NoReservedKeywordsContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IDENTITY, 0)
}

func (s *NoReservedKeywordsContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IMMEDIATE, 0)
}

func (s *NoReservedKeywordsContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INITRANS, 0)
}

func (s *NoReservedKeywordsContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INOUT, 0)
}

func (s *NoReservedKeywordsContext) T_INT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INT, 0)
}

func (s *NoReservedKeywordsContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INT2, 0)
}

func (s *NoReservedKeywordsContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INT4, 0)
}

func (s *NoReservedKeywordsContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INT8, 0)
}

func (s *NoReservedKeywordsContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INTEGER, 0)
}

func (s *NoReservedKeywordsContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INVOKER, 0)
}

func (s *NoReservedKeywordsContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ISOPEN, 0)
}

func (s *NoReservedKeywordsContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEEP, 0)
}

func (s *NoReservedKeywordsContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEY, 0)
}

func (s *NoReservedKeywordsContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LANGUAGE, 0)
}

func (s *NoReservedKeywordsContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEAVE, 0)
}

func (s *NoReservedKeywordsContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCATOR, 0)
}

func (s *NoReservedKeywordsContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCATORS, 0)
}

func (s *NoReservedKeywordsContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOG, 0)
}

func (s *NoReservedKeywordsContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOGGED, 0)
}

func (s *NoReservedKeywordsContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOGGING, 0)
}

func (s *NoReservedKeywordsContext) T_LOOP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOOP, 0)
}

func (s *NoReservedKeywordsContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX, 0)
}

func (s *NoReservedKeywordsContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAXTRANS, 0)
}

func (s *NoReservedKeywordsContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MESSAGE_TEXT, 0)
}

func (s *NoReservedKeywordsContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MIN, 0)
}

func (s *NoReservedKeywordsContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MULTISET, 0)
}

func (s *NoReservedKeywordsContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NCHAR, 0)
}

func (s *NoReservedKeywordsContext) T_NEW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NEW, 0)
}

func (s *NoReservedKeywordsContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NVARCHAR, 0)
}

func (s *NoReservedKeywordsContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOCOUNT, 0)
}

func (s *NoReservedKeywordsContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOCOMPRESS, 0)
}

func (s *NoReservedKeywordsContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOLOGGING, 0)
}

func (s *NoReservedKeywordsContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NONE, 0)
}

func (s *NoReservedKeywordsContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOTFOUND, 0)
}

func (s *NoReservedKeywordsContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NUMERIC, 0)
}

func (s *NoReservedKeywordsContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NUMBER, 0)
}

func (s *NoReservedKeywordsContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OBJECT, 0)
}

func (s *NoReservedKeywordsContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OFF, 0)
}

func (s *NoReservedKeywordsContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OPEN, 0)
}

func (s *NoReservedKeywordsContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_OWNER, 0)
}

func (s *NoReservedKeywordsContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PACKAGE, 0)
}

func (s *NoReservedKeywordsContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PCTFREE, 0)
}

func (s *NoReservedKeywordsContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PCTUSED, 0)
}

func (s *NoReservedKeywordsContext) T_PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PLS_INTEGER, 0)
}

func (s *NoReservedKeywordsContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRECISION, 0)
}

func (s *NoReservedKeywordsContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRESERVE, 0)
}

func (s *NoReservedKeywordsContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PRINT, 0)
}

func (s *NoReservedKeywordsContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PROC, 0)
}

func (s *NoReservedKeywordsContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PROCEDURE, 0)
}

func (s *NoReservedKeywordsContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUALIFY, 0)
}

func (s *NoReservedKeywordsContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUERY_BAND, 0)
}

func (s *NoReservedKeywordsContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUIT, 0)
}

func (s *NoReservedKeywordsContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_QUOTED_IDENTIFIER, 0)
}

func (s *NoReservedKeywordsContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RAISE, 0)
}

func (s *NoReservedKeywordsContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REAL, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP, 0)
}

func (s *NoReservedKeywordsContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESIGNAL, 0)
}

func (s *NoReservedKeywordsContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESULT, 0)
}

func (s *NoReservedKeywordsContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RESULT_SET_LOCATOR, 0)
}

func (s *NoReservedKeywordsContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RETURN, 0)
}

func (s *NoReservedKeywordsContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RETURNS, 0)
}

func (s *NoReservedKeywordsContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REVERSE, 0)
}

func (s *NoReservedKeywordsContext) T_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROWTYPE, 0)
}

func (s *NoReservedKeywordsContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW_COUNT, 0)
}

func (s *NoReservedKeywordsContext) T_RR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RR, 0)
}

func (s *NoReservedKeywordsContext) T_RS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RS, 0)
}

func (s *NoReservedKeywordsContext) T_PWD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PWD, 0)
}

func (s *NoReservedKeywordsContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SECURITY, 0)
}

func (s *NoReservedKeywordsContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEGMENT, 0)
}

func (s *NoReservedKeywordsContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEL, 0)
}

func (s *NoReservedKeywordsContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SESSION, 0)
}

func (s *NoReservedKeywordsContext) T_SESSIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SESSIONS, 0)
}

func (s *NoReservedKeywordsContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHARE, 0)
}

func (s *NoReservedKeywordsContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIGNAL, 0)
}

func (s *NoReservedKeywordsContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIMPLE_DOUBLE, 0)
}

func (s *NoReservedKeywordsContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIMPLE_FLOAT, 0)
}

func (s *NoReservedKeywordsContext) T_SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIMPLE_INTEGER, 0)
}

func (s *NoReservedKeywordsContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SMALLDATETIME, 0)
}

func (s *NoReservedKeywordsContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SMALLINT, 0)
}

func (s *NoReservedKeywordsContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQL, 0)
}

func (s *NoReservedKeywordsContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQLEXCEPTION, 0)
}

func (s *NoReservedKeywordsContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQLINSERT, 0)
}

func (s *NoReservedKeywordsContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQLSTATE, 0)
}

func (s *NoReservedKeywordsContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQLWARNING, 0)
}

func (s *NoReservedKeywordsContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STATS, 0)
}

func (s *NoReservedKeywordsContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STEP, 0)
}

func (s *NoReservedKeywordsContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STORAGE, 0)
}

func (s *NoReservedKeywordsContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STRING, 0)
}

func (s *NoReservedKeywordsContext) T_SUBDIR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBDIR, 0)
}

func (s *NoReservedKeywordsContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUM, 0)
}

func (s *NoReservedKeywordsContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUMMARY, 0)
}

func (s *NoReservedKeywordsContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYS_REFCURSOR, 0)
}

func (s *NoReservedKeywordsContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLESPACE, 0)
}

func (s *NoReservedKeywordsContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TEXTIMAGE_ON, 0)
}

func (s *NoReservedKeywordsContext) T_TINYINT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TINYINT, 0)
}

func (s *NoReservedKeywordsContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TITLE, 0)
}

func (s *NoReservedKeywordsContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TOP, 0)
}

func (s *NoReservedKeywordsContext) T_UR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UR, 0)
}

func (s *NoReservedKeywordsContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VALUE, 0)
}

func (s *NoReservedKeywordsContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VAR, 0)
}

func (s *NoReservedKeywordsContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VARCHAR, 0)
}

func (s *NoReservedKeywordsContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VARCHAR2, 0)
}

func (s *NoReservedKeywordsContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VARYING, 0)
}

func (s *NoReservedKeywordsContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VOLATILE, 0)
}

func (s *NoReservedKeywordsContext) T_WHILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WHILE, 0)
}

func (s *NoReservedKeywordsContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WITHOUT, 0)
}

func (s *NoReservedKeywordsContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WORK, 0)
}

func (s *NoReservedKeywordsContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_XACT_ABORT, 0)
}

func (s *NoReservedKeywordsContext) T_XML() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_XML, 0)
}

func (s *NoReservedKeywordsContext) T_YES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_YES, 0)
}

func (s *NoReservedKeywordsContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ACTIVITY_COUNT, 0)
}

func (s *NoReservedKeywordsContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CUME_DIST, 0)
}

func (s *NoReservedKeywordsContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DENSE_RANK, 0)
}

func (s *NoReservedKeywordsContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIRST_VALUE, 0)
}

func (s *NoReservedKeywordsContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAG, 0)
}

func (s *NoReservedKeywordsContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAST_VALUE, 0)
}

func (s *NoReservedKeywordsContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEAD, 0)
}

func (s *NoReservedKeywordsContext) T_MAX_PART_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX_PART_STRING, 0)
}

func (s *NoReservedKeywordsContext) T_MIN_PART_STRING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MIN_PART_STRING, 0)
}

func (s *NoReservedKeywordsContext) T_MAX_PART_INT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX_PART_INT, 0)
}

func (s *NoReservedKeywordsContext) T_MIN_PART_INT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MIN_PART_INT, 0)
}

func (s *NoReservedKeywordsContext) T_MAX_PART_DATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX_PART_DATE, 0)
}

func (s *NoReservedKeywordsContext) T_MIN_PART_DATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MIN_PART_DATE, 0)
}

func (s *NoReservedKeywordsContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PART_COUNT, 0)
}

func (s *NoReservedKeywordsContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PART_LOC, 0)
}

func (s *NoReservedKeywordsContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RANK, 0)
}

func (s *NoReservedKeywordsContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROW_NUMBER, 0)
}

func (s *NoReservedKeywordsContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STDEV, 0)
}

func (s *NoReservedKeywordsContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYSDATE, 0)
}

func (s *NoReservedKeywordsContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VARIANCE, 0)
}

func (s *NoReservedKeywordsContext) T_ABS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ABS, 0)
}

func (s *NoReservedKeywordsContext) T_ACOS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ACOS, 0)
}

func (s *NoReservedKeywordsContext) T_ADD_MONTHS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ADD_MONTHS, 0)
}

func (s *NoReservedKeywordsContext) T_ALL_MATCH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ALL_MATCH, 0)
}

func (s *NoReservedKeywordsContext) T_ANY_MATCH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ANY_MATCH, 0)
}

func (s *NoReservedKeywordsContext) T_ATAN2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ATAN2, 0)
}

func (s *NoReservedKeywordsContext) T_APPROX_DISTINCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_APPROX_DISTINCT, 0)
}

func (s *NoReservedKeywordsContext) T_ARG_MAX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARG_MAX, 0)
}

func (s *NoReservedKeywordsContext) T_ARG_MIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARG_MIN, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_CONTAINS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_CONTAINS, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_DISTINCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_DISTINCT, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_EXCEPT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_EXCEPT, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_INTERSECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_INTERSECT, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_JOIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_JOIN, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_MAX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_MAX, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_MIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_MIN, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_NORMALIZE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_NORMALIZE, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_POSITION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_POSITION, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_REDUCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_REDUCE, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_REMOVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_REMOVE, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_REPEAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_REPEAT, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_SORT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_SORT, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAY_UNION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAY_UNION, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAYS_OVERLAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAYS_OVERLAP, 0)
}

func (s *NoReservedKeywordsContext) T_ARRAYS_ZIP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ARRAYS_ZIP, 0)
}

func (s *NoReservedKeywordsContext) T_ASCII() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ASCII, 0)
}

func (s *NoReservedKeywordsContext) T_ASIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ASIN, 0)
}

func (s *NoReservedKeywordsContext) T_ATAN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ATAN, 0)
}

func (s *NoReservedKeywordsContext) T_BASE64() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BASE64, 0)
}

func (s *NoReservedKeywordsContext) T_BIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BIN, 0)
}

func (s *NoReservedKeywordsContext) T_BITWISE_AND_AGG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BITWISE_AND_AGG, 0)
}

func (s *NoReservedKeywordsContext) T_BITWISE_OR_AGG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_BITWISE_OR_AGG, 0)
}

func (s *NoReservedKeywordsContext) T_CBRT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CBRT, 0)
}

func (s *NoReservedKeywordsContext) T_CEIL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CEIL, 0)
}

func (s *NoReservedKeywordsContext) T_CHAR_MATCHCOUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHAR_MATCHCOUNT, 0)
}

func (s *NoReservedKeywordsContext) T_CHR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CHR, 0)
}

func (s *NoReservedKeywordsContext) T_CLUSTER_SAMPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CLUSTER_SAMPLE, 0)
}

func (s *NoReservedKeywordsContext) T_COALESCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COALESCE, 0)
}

func (s *NoReservedKeywordsContext) T_COLLECT_LIST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLECT_LIST, 0)
}

func (s *NoReservedKeywordsContext) T_COLLECT_SET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COLLECT_SET, 0)
}

func (s *NoReservedKeywordsContext) T_COMBINATIONS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COMBINATIONS, 0)
}

func (s *NoReservedKeywordsContext) T_CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONCAT_WS, 0)
}

func (s *NoReservedKeywordsContext) T_CONV() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CONV, 0)
}

func (s *NoReservedKeywordsContext) T_CORR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CORR, 0)
}

func (s *NoReservedKeywordsContext) T_COS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COS, 0)
}

func (s *NoReservedKeywordsContext) T_COSH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COSH, 0)
}

func (s *NoReservedKeywordsContext) T_COT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COT, 0)
}

func (s *NoReservedKeywordsContext) T_COUNT_IF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COUNT_IF, 0)
}

func (s *NoReservedKeywordsContext) T_COVAR_POP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COVAR_POP, 0)
}

func (s *NoReservedKeywordsContext) T_COVAR_SAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_COVAR_SAMP, 0)
}

func (s *NoReservedKeywordsContext) T_CRC32() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CRC32, 0)
}

func (s *NoReservedKeywordsContext) T_CURRENT_TIMEZONE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_CURRENT_TIMEZONE, 0)
}

func (s *NoReservedKeywordsContext) T_DATE_ADD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATE_ADD, 0)
}

func (s *NoReservedKeywordsContext) T_DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATE_FORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_DATE_SUB() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATE_SUB, 0)
}

func (s *NoReservedKeywordsContext) T_DATEPART() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATEPART, 0)
}

func (s *NoReservedKeywordsContext) T_DATETRUNC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DATETRUNC, 0)
}

func (s *NoReservedKeywordsContext) T_DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAYOFMONTH, 0)
}

func (s *NoReservedKeywordsContext) T_DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DAYOFWEEK, 0)
}

func (s *NoReservedKeywordsContext) T_DECODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DECODE, 0)
}

func (s *NoReservedKeywordsContext) T_DECOMPRESS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DECOMPRESS, 0)
}

func (s *NoReservedKeywordsContext) T_DEGREES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_DEGREES, 0)
}

func (s *NoReservedKeywordsContext) T_E() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_E, 0)
}

func (s *NoReservedKeywordsContext) T_ENCODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ENCODE, 0)
}

func (s *NoReservedKeywordsContext) T_EXP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXP, 0)
}

func (s *NoReservedKeywordsContext) T_EXPLODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_EXPLODE, 0)
}

func (s *NoReservedKeywordsContext) T_FACTORIAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FACTORIAL, 0)
}

func (s *NoReservedKeywordsContext) T_FIELD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIELD, 0)
}

func (s *NoReservedKeywordsContext) T_FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FIND_IN_SET, 0)
}

func (s *NoReservedKeywordsContext) T_FLATTEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FLATTEN, 0)
}

func (s *NoReservedKeywordsContext) T_FLOOR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FLOOR, 0)
}

func (s *NoReservedKeywordsContext) T_FORMAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FORMAT_NUMBER, 0)
}

func (s *NoReservedKeywordsContext) T_FROM_JSON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM_JSON, 0)
}

func (s *NoReservedKeywordsContext) T_FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM_UNIXTIME, 0)
}

func (s *NoReservedKeywordsContext) T_FROM_UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_FROM_UTC_TIMESTAMP, 0)
}

func (s *NoReservedKeywordsContext) T_GET_IDCARD_AGE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET_IDCARD_AGE, 0)
}

func (s *NoReservedKeywordsContext) T_GET_IDCARD_BIRTHDAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET_IDCARD_BIRTHDAY, 0)
}

func (s *NoReservedKeywordsContext) T_GET_IDCARD_SEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET_IDCARD_SEX, 0)
}

func (s *NoReservedKeywordsContext) T_GET_JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET_JSON_OBJECT, 0)
}

func (s *NoReservedKeywordsContext) T_GET_USER_ID() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GET_USER_ID, 0)
}

func (s *NoReservedKeywordsContext) T_GETDATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GETDATE, 0)
}

func (s *NoReservedKeywordsContext) T_GREATEST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_GREATEST, 0)
}

func (s *NoReservedKeywordsContext) T_HEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HEX, 0)
}

func (s *NoReservedKeywordsContext) T_HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_HISTOGRAM, 0)
}

func (s *NoReservedKeywordsContext) T_INLINE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INLINE, 0)
}

func (s *NoReservedKeywordsContext) T_INITCAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INITCAP, 0)
}

func (s *NoReservedKeywordsContext) T_INSTR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_INSTR, 0)
}

func (s *NoReservedKeywordsContext) T_IS_ENCODING() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_IS_ENCODING, 0)
}

func (s *NoReservedKeywordsContext) T_ISDATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ISDATE, 0)
}

func (s *NoReservedKeywordsContext) T_ISNAN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ISNAN, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_OBJECT, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_ARRAY, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_EXTRACT, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_EXISTS, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_PRETTY, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_TYPE, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_FORMAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_FORMAT, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_PARSE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_PARSE, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_VALID() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_VALID, 0)
}

func (s *NoReservedKeywordsContext) T_JSON_TUPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_JSON_TUPLE, 0)
}

func (s *NoReservedKeywordsContext) T_KEYVALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEYVALUE, 0)
}

func (s *NoReservedKeywordsContext) T_KEYVALUE_TUPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_KEYVALUE_TUPLE, 0)
}

func (s *NoReservedKeywordsContext) T_LAST_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LAST_DAY, 0)
}

func (s *NoReservedKeywordsContext) T_LASTDAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LASTDAY, 0)
}

func (s *NoReservedKeywordsContext) T_LEAST() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LEAST, 0)
}

func (s *NoReservedKeywordsContext) T_LENGTH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LENGTH, 0)
}

func (s *NoReservedKeywordsContext) T_LENGTHB() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LENGTHB, 0)
}

func (s *NoReservedKeywordsContext) T_LN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LN, 0)
}

func (s *NoReservedKeywordsContext) T_LOCATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOCATE, 0)
}

func (s *NoReservedKeywordsContext) T_LOG10() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOG10, 0)
}

func (s *NoReservedKeywordsContext) T_LOG2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LOG2, 0)
}

func (s *NoReservedKeywordsContext) T_LPAD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LPAD, 0)
}

func (s *NoReservedKeywordsContext) T_LTRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_LTRIM, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_AGG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_AGG, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_CONCAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_CONCAT, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_ENTRIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_ENTRIES, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_FILTER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_FILTER, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_FROM_ARRAYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_FROM_ARRAYS, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_FROM_ENTRIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_FROM_ENTRIES, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_KEYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_KEYS, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_UNION() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_UNION, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_UNION_SUM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_UNION_SUM, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_VALUES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_VALUES, 0)
}

func (s *NoReservedKeywordsContext) T_MAP_ZIP_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAP_ZIP_WITH, 0)
}

func (s *NoReservedKeywordsContext) T_MASK_HASH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MASK_HASH, 0)
}

func (s *NoReservedKeywordsContext) T_MAX_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX_BY, 0)
}

func (s *NoReservedKeywordsContext) T_MAX_PT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MAX_PT, 0)
}

func (s *NoReservedKeywordsContext) T_MD5() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MD5, 0)
}

func (s *NoReservedKeywordsContext) T_MEDIAN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MEDIAN, 0)
}

func (s *NoReservedKeywordsContext) T_MIN_BY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MIN_BY, 0)
}

func (s *NoReservedKeywordsContext) T_MONTHS_BETWEEN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MONTHS_BETWEEN, 0)
}

func (s *NoReservedKeywordsContext) T_MULTIMAP_AGG() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MULTIMAP_AGG, 0)
}

func (s *NoReservedKeywordsContext) T_MULTIMAP_FROM_ENTRIES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_MULTIMAP_FROM_ENTRIES, 0)
}

func (s *NoReservedKeywordsContext) T_NAMED_STRUCT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NAMED_STRUCT, 0)
}

func (s *NoReservedKeywordsContext) T_NEGATIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NEGATIVE, 0)
}

func (s *NoReservedKeywordsContext) T_NEXT_DAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NEXT_DAY, 0)
}

func (s *NoReservedKeywordsContext) T_NGRAMS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NGRAMS, 0)
}

func (s *NoReservedKeywordsContext) T_NOW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NOW, 0)
}

func (s *NoReservedKeywordsContext) T_NTILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NTILE, 0)
}

func (s *NoReservedKeywordsContext) T_NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NTH_VALUE, 0)
}

func (s *NoReservedKeywordsContext) T_NULLIF() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NULLIF, 0)
}

func (s *NoReservedKeywordsContext) T_NUMERIC_HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NUMERIC_HISTOGRAM, 0)
}

func (s *NoReservedKeywordsContext) T_NVL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_NVL, 0)
}

func (s *NoReservedKeywordsContext) T_ORDINAL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ORDINAL, 0)
}

func (s *NoReservedKeywordsContext) T_PARSE_URL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARSE_URL, 0)
}

func (s *NoReservedKeywordsContext) T_PARSE_URL_TUPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARSE_URL_TUPLE, 0)
}

func (s *NoReservedKeywordsContext) T_PARTITION_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PARTITION_EXISTS, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENT_RANK, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENTILE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE, 0)
}

func (s *NoReservedKeywordsContext) T_PERCENTILE_APPROX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PERCENTILE_APPROX, 0)
}

func (s *NoReservedKeywordsContext) T_PI() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_PI, 0)
}

func (s *NoReservedKeywordsContext) T_POSEXPLODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_POSEXPLODE, 0)
}

func (s *NoReservedKeywordsContext) T_POSITIVE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_POSITIVE, 0)
}

func (s *NoReservedKeywordsContext) T_POW() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_POW, 0)
}

func (s *NoReservedKeywordsContext) T_RADIANS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RADIANS, 0)
}

func (s *NoReservedKeywordsContext) T_RAND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RAND, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_COUNT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_COUNT, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_EXTRACT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_EXTRACT, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_EXTRACT_ALL() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_EXTRACT_ALL, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_INSTR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_INSTR, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_REPLACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_REPLACE, 0)
}

func (s *NoReservedKeywordsContext) T_REGEXP_SUBSTR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REGEXP_SUBSTR, 0)
}

func (s *NoReservedKeywordsContext) T_REPEAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_REPEAT, 0)
}

func (s *NoReservedKeywordsContext) T_ROUND() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ROUND, 0)
}

func (s *NoReservedKeywordsContext) T_RPAD() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RPAD, 0)
}

func (s *NoReservedKeywordsContext) T_RTRIM() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_RTRIM, 0)
}

func (s *NoReservedKeywordsContext) T_SAMPLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SAMPLE, 0)
}

func (s *NoReservedKeywordsContext) T_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SEQUENCE, 0)
}

func (s *NoReservedKeywordsContext) T_SHA() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHA, 0)
}

func (s *NoReservedKeywordsContext) T_SHA1() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHA1, 0)
}

func (s *NoReservedKeywordsContext) T_SHA2() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHA2, 0)
}

func (s *NoReservedKeywordsContext) T_SHIFTLEFT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHIFTLEFT, 0)
}

func (s *NoReservedKeywordsContext) T_SHIFTRIGHT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHIFTRIGHT, 0)
}

func (s *NoReservedKeywordsContext) T_SHIFTRIGHTUNSIGNED() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHIFTRIGHTUNSIGNED, 0)
}

func (s *NoReservedKeywordsContext) T_SHUFFLE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SHUFFLE, 0)
}

func (s *NoReservedKeywordsContext) T_SIGN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIGN, 0)
}

func (s *NoReservedKeywordsContext) T_SIN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIN, 0)
}

func (s *NoReservedKeywordsContext) T_SINH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SINH, 0)
}

func (s *NoReservedKeywordsContext) T_SIZE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SIZE, 0)
}

func (s *NoReservedKeywordsContext) T_SLICE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SLICE, 0)
}

func (s *NoReservedKeywordsContext) T_SORT_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SORT_ARRAY, 0)
}

func (s *NoReservedKeywordsContext) T_SOUNDEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SOUNDEX, 0)
}

func (s *NoReservedKeywordsContext) T_SPACE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SPACE, 0)
}

func (s *NoReservedKeywordsContext) T_SPLIT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SPLIT, 0)
}

func (s *NoReservedKeywordsContext) T_SPLIT_PART() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SPLIT_PART, 0)
}

func (s *NoReservedKeywordsContext) T_SQRT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SQRT, 0)
}

func (s *NoReservedKeywordsContext) T_STACK() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STACK, 0)
}

func (s *NoReservedKeywordsContext) T_STDDEV() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STDDEV, 0)
}

func (s *NoReservedKeywordsContext) T_STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STDDEV_SAMP, 0)
}

func (s *NoReservedKeywordsContext) T_STR_TO_MAP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_STR_TO_MAP, 0)
}

func (s *NoReservedKeywordsContext) T_SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SUBSTRING_INDEX, 0)
}

func (s *NoReservedKeywordsContext) T_SYM_DECRYPT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYM_DECRYPT, 0)
}

func (s *NoReservedKeywordsContext) T_SYM_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_SYM_ENCRYPT, 0)
}

func (s *NoReservedKeywordsContext) T_TABLE_EXISTS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TABLE_EXISTS, 0)
}

func (s *NoReservedKeywordsContext) T_TAN() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TAN, 0)
}

func (s *NoReservedKeywordsContext) T_TANH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TANH, 0)
}

func (s *NoReservedKeywordsContext) T_TO_CHAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO_CHAR, 0)
}

func (s *NoReservedKeywordsContext) T_TO_DATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO_DATE, 0)
}

func (s *NoReservedKeywordsContext) T_TO_JSON() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO_JSON, 0)
}

func (s *NoReservedKeywordsContext) T_TO_MILLIS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TO_MILLIS, 0)
}

func (s *NoReservedKeywordsContext) T_TOLOWER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TOLOWER, 0)
}

func (s *NoReservedKeywordsContext) T_TOUPPER() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TOUPPER, 0)
}

func (s *NoReservedKeywordsContext) T_TRANS_ARRAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANS_ARRAY, 0)
}

func (s *NoReservedKeywordsContext) T_TRANS_COLS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANS_COLS, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSFORM_KEYS() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSFORM_KEYS, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSFORM_VALUES() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSFORM_VALUES, 0)
}

func (s *NoReservedKeywordsContext) T_TRANSLATE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRANSLATE, 0)
}

func (s *NoReservedKeywordsContext) T_TRUNC() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_TRUNC, 0)
}

func (s *NoReservedKeywordsContext) T_UNBASE64() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNBASE64, 0)
}

func (s *NoReservedKeywordsContext) T_UNHEX() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNHEX, 0)
}

func (s *NoReservedKeywordsContext) T_UNIQUE_ID() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNIQUE_ID, 0)
}

func (s *NoReservedKeywordsContext) T_UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UNIX_TIMESTAMP, 0)
}

func (s *NoReservedKeywordsContext) T_URL_DECODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_URL_DECODE, 0)
}

func (s *NoReservedKeywordsContext) T_URL_ENCODE() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_URL_ENCODE, 0)
}

func (s *NoReservedKeywordsContext) T_UUID() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_UUID, 0)
}

func (s *NoReservedKeywordsContext) T_VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VAR_SAMP, 0)
}

func (s *NoReservedKeywordsContext) T_VAR_POP() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_VAR_POP, 0)
}

func (s *NoReservedKeywordsContext) T_WEEKDAY() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEKDAY, 0)
}

func (s *NoReservedKeywordsContext) T_WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WEEKOFYEAR, 0)
}

func (s *NoReservedKeywordsContext) T_WIDTH_BUCKET() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WIDTH_BUCKET, 0)
}

func (s *NoReservedKeywordsContext) T_WM_CONCAT() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_WM_CONCAT, 0)
}

func (s *NoReservedKeywordsContext) T_ZIP_WITH() antlr.TerminalNode {
	return s.GetToken(UniversalParserT_ZIP_WITH, 0)
}

func (s *NoReservedKeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoReservedKeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoReservedKeywordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.EnterNoReservedKeywords(s)
	}
}

func (s *NoReservedKeywordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(UniversalParserListener); ok {
		listenerT.ExitNoReservedKeywords(s)
	}
}

func (p *UniversalParser) NoReservedKeywords() (localctx INoReservedKeywordsContext) {
	localctx = NewNoReservedKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, UniversalParserRULE_noReservedKeywords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2206)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-140737490461058) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2630137435475935233) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-57073862025674785) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-51543801857) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-274877906945) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-1) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-1) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&-1) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&-1) != 0) || ((int64((_la-577)) & ^0x3f) == 0 && ((int64(1)<<(_la-577))&-1) != 0) || ((int64((_la-641)) & ^0x3f) == 0 && ((int64(1)<<(_la-641))&-1) != 0) || ((int64((_la-705)) & ^0x3f) == 0 && ((int64(1)<<(_la-705))&67108863) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *UniversalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 58:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 107:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 109:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 110:
		var t *DefaultExpressionContext = nil
		if localctx != nil {
			t = localctx.(*DefaultExpressionContext)
		}
		return p.DefaultExpression_Sempred(t, predIndex)

	case 177:
		var t *QuotedIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*QuotedIdentifierContext)
		}
		return p.QuotedIdentifier_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *UniversalParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *UniversalParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *UniversalParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *UniversalParser) DefaultExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *UniversalParser) QuotedIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return DoubleQuotedIdentifierEnable

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
